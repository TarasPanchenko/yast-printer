/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:        include/printer/basicadd.ycp
 * Package:     Configuration of printer
 * Summary:     Basic add dialog definition
 * Authors:     Johannes Meixner <jsmeix@suse.de>
 *
 * $Id: basicadd.ycp 27914 2006-02-13 14:32:08Z locilka $
 */

{

textdomain "printer";

import "Label";
import "Wizard";
import "Printer";
import "Printerlib";
import "Popup";

include "printer/helps.ycp";

/**
 * BasicAddDialog dialog
 * @return dialog result
 */
any BasicAddDialog()
{ y2milestone( "entering BasicAddDialog" );
  // Caption for the "Add Printer" dialog (BasicAddDialog):
  string caption = _("Add New Printer Configuration");
  // Clear whatever content of a previous dialog which would show up here for several seconds
  // until all the following stuff is done before Wizard::SetContentsButtons is called
  // which finally shows the right content for this dialog.
  Wizard::SetContents( caption,
                       `Empty(),
                       HELPS["basic_add_dialog"]:"",
                       false,
                       false
                     );
  Wizard::HideAbortButton();
  string driver_filter_string = "BasicAddDialog";
  string driver_filter_input_text = "";
  string queue_name_proposal = "";
  string model = Printer::connections[Printer::selected_connections_index,"model"]:"";
  if( "" != model
      && "unknown" != tolower( model )
    )
  { queue_name_proposal = Printer::NewQueueName( tolower( model ) );
    // Match only at the beginning of the NickName entry in the PPD:
    driver_filter_string = "^" + filterchars( tolower( model ), Printer::lower_alnum_chars );
    if( "^" != driver_filter_string )
    { driver_filter_input_text = model;
    }
  }
  term contents = `VBox
                  ( `VBox
                    ( `HBox
                      ( `Label
                        ( // Caption for a Table with a list of printer connections:
                          _("Determine Connection")
                        ),
                        `HStretch(),
                        `PushButton
                        ( `id(`more_connections),
                          // Label of a PushButton to show more available printer connections
                          // in the Table with a list of printer connections:
                          _("&More Connections")
                        ),
                        `PushButton
                        ( `id(`connection_wizard),
                          // Label of a PushButton to go to the "Connection Wizard"
                          // to specify the printer connection individually:
                          _("Connection &Wizard")
                        )
                      ),
                      `ReplacePoint
                      ( `id(`connection_selection_replace_point),
                        `Table
                        ( `id(`connection_selection),
                          // By default there is no UserInput()
                          // if only something was selected in the Table
                          // (without clicking additionally a button)
                          // but the notify and immediate options
                          // forces UserInput() in this case:
                          `opt(`notify, `immediate, `keepSorting),
                          // Headers of a Table with a list of printer connections:
                          `header
                          ( // Header of a Table column with a list of printer connections.
                            // Printer model name:
                            _("Model"),
                            // Header of a Table column with a list of printer connections.
                            // Connection of the printer (e.g. via USB or via parallel port):
                            _("Connection"),
                            // Header of a Table column with a list of printer connections.
                            // Additional description of the printer or its particular connection:
                            _("Description")
                          ),
                          Printer::ConnectionItems( "BasicAddDialog" )
                        )
                      )
                    ),
                    `VStretch(),
                    `VBox
                    ( `Left
                      ( `Label
                        ( // Caption for a printer driver selection:
                          _("Assign Driver")
                        )
                      ),
                      `HBox
                      ( `PushButton
                        ( `id(`apply_driver_filter),
                          // This button must be the default
                          // (it is activated when the user pressed the Enter key)
                          // because when the user has clicked into TextEntry to enter something
                          // it is normal to finish entering by pressing the Enter key
                          // but if the Enter key was linked to 'Next' or 'Back',
                          // the user would get the wrong action.
                          `opt(`default),
                          // Label of a PushButton to search a list for a search string
                          // and then show the search result:
                          _("&Search")
                        ),
                        `ReplacePoint
                        ( `id(`driver_filter_input_replace_point),
                          `InputField
                          ( `id(`driver_filter_input),
                            `opt(`hstretch),
                            // No InputField header because there is the "Caption for a printer driver selection":
                            "",
                            driver_filter_input_text
                          )
                        ),
                        `PushButton
                        ( `id(`more_drivers),
                          // Label of a PushButton to show more available printer drivers:
                          _("More &Drivers")
                        ),
                        `PushButton
                        ( `id(`add_driver),
                          // Label of a PushButton to go to the "Add Driver" dialog
                          // to install a new driver (and perhaps download it before):
                          _("&Add Driver")
                        )
                      ),
                      `ReplacePoint
                      ( `id(`driver_selection_replace_point),
                        `SelectionBox
                        ( `id(`driver_selection),
                          // By default there is no UserInput()
                          // if only something was selected in the SelectionBox
                          // (without clicking additionally a button)
                          // but the notify option forces UserInput() in this case:
                          `opt(`notify),
                          "",
                          [ `item( `id( -1 ), _("Select a driver.") ) ]
                        )
                      ),
                      `RadioButtonGroup
                      ( `id(`paper_size_radio_buttons),
                        `HBox
                        ( `Label
                          ( // Label of a RadioButtonGroup to specify the default paper size:
                            _("Default paper size (if printer and driver supports it)")
                          ),
                          // Have none of the RadioButtons preselected which means that
                          // by default the CUPS default is used for the default paper size.
                          // For the CUPS 1.3 default see http://www.cups.org/str.php?L2846
                          // For CUPS 1.4 the default depends on the "DefaultPaperSize" setting in cupsd.conf
                          // see https://bugzilla.novell.com/show_bug.cgi?id=395760
                          // and http://www.cups.org/str.php?L2848
                          `HSpacing( 2 ),
                          `RadioButton( `id(`a4), "A&4" ),
                          `HSpacing( 1 ),
                          `RadioButton( `id(`letter), "Le&tter" ),
                          `HStretch()
                        )
                      )
                    ),
                    `VStretch(),
                    `Left
                    ( `ReplacePoint
                      ( `id(`queue_name_input_replace_point),
                        `InputField
                        ( `id(`queue_name_input),
                          // Header of a TextEntry to enter the queue name:
                          _("Set &Name"),
                          queue_name_proposal
                        )
                      )
                    )
                  );
  // According to http://en.opensuse.org/YaST/Style_Guide#Single_Configuration.2FOverview.2FEdit_Dialog
  // there is no longer a "abort" functionality which exits the whole module.
  // Instead this button is now named "Cancel" and its functionality is
  // to go back to the Overview dialog (i.e. what the "back" button would do)
  // because it reads "Cancel - Closes the window and returns to the overview."
  // Therefore the button with the "abort" functionality is not shown at all
  // and the button with the "back" functionality is named "Cancel".
  // According to http://en.opensuse.org/YaST/Style_Guide#Single_Configuration.2FOverview.2FEdit_Dialog
  // the "finish" button in a single (step) configuration dialog must now be named "OK".
  Wizard::SetContentsButtons( caption,
                              contents,
                              HELPS["basic_add_dialog"]:"",
                              // Set a new label for the "back" button, see the comment above:
                              Label::CancelButton(),
                              // Set a new label for the "next" button, see the comment above:
                              Label::OKButton()
                            );
  Wizard::HideAbortButton();
  // Try to preselect the connection which matches to the current_device_uri
  // if such a connection exists in the connection_selection table:
  if( Printer::selected_connections_index >= 0 )
  { // An item which matches to Printer::selected_connections_index
    // exists in the connection_selection table because the Printer::ConnectionItems function
    // sets Printer::selected_connections_index != -1 only if such an item exists in the table
    // so that this item can be preselected:
    y2milestone( "Preselected connection: '%1'", Printer::connections[Printer::selected_connections_index]:$[] );
    UI::ChangeWidget( `connection_selection, `CurrentItem, `id(Printer::selected_connections_index) );
  }
  UI::FakeUserInput( `connection_selection );
  any ret = nil;
  while(true)
  { ret = UI::UserInput();
    if( ret == `abort || ret == `cancel || ret == `back ) break;
    if( ret == `next )
    { if( Printer::selected_connections_index < 0
          && Printer::selected_ppds_index < 0
        )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when neither a connection
                           // nor a driver was selected:
                           _("Nothing Selected"),
                           // Body of a Popup::AnyMessage when neither a connection
                           // nor a driver was selected:
                           _("Select a connection and then assign a driver.")
                         );
        continue;
      }
      if( Printer::selected_connections_index < 0 )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when no connection was selected:
                           _("No Connection Selected"),
                           // Body of a Popup::AnyMessage when no connection was selected:
                           _("Select a connection.")
                         );
        continue;
      }
      if( Printer::selected_ppds_index < 0 )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when no driver was selected:
                           _("No Driver Selected"),
                           // Body of a Popup::AnyMessage when no driver was selected:
                           _("Select a driver.")
                         );
        continue;
      }
      string queue_name = (string)UI::QueryWidget( `id(`queue_name_input), `Value );
      if( "" == queue_name )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when no queue name was entered:
                           _("No Queue Name"),
                           // Body of a Popup::AnyMessage when no queue name was entered:
                           _("Enter a queue name.")
                         );
        continue;
      }
      if( "" != deletechars( queue_name, Printer::alnum_chars + "_" ) )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when a wrong queue name was entered:
                           _("Invalid Queue Name"),
                           // Body of a Popup::AnyMessage when a wrong queue name was entered:
                           _("Only letters (a-z and A-Z), numbers (0-9), and the underscore '_' are allowed for the queue name.")
                         );
        continue;
      }
      string validated_queue_name = Printer::NewQueueName( queue_name );
      if( queue_name != validated_queue_name )
      { if( ! Popup::ContinueCancelHeadline( // Header of a Popup::ContinueCancelHeadline
                                             // when a queue name is changed to be valid:
                                             _("Confirm Validated Queue Name"),
                                             // Body of a Popup::ContinueCancelHeadline
                                             // when a queue name was automatically changed to be valid
                                             // where %1 will be replaced by the old invalid queue name
                                             // and %2 will be replaced by a new valid queue name
                                             sformat( _("'%1' is invalid or it exists already. Use '%2' instead?"), queue_name, validated_queue_name )
                                           )
          )
        { // The user has decided not to accept the changed queue name:
          continue;
        }
        queue_name = validated_queue_name;
      }
      string default_paper_size = "";
      any paper_size = UI::QueryWidget( `id(`paper_size_radio_buttons), `CurrentButton );
      if( `a4 == paper_size )
      { default_paper_size = "A4";
      }
      if( `letter == paper_size )
      { default_paper_size = "Letter";
      }
      Wizard::DisableBackButton();
      Wizard::DisableNextButton();
      // No error messages here because Printer::AddQueue already shows them:
      Printer::AddQueue( queue_name, default_paper_size );
      // After a local queue was added, enforce to show also local queues
      // in particular when no local queues were shown before:
      Printer::queue_filter_show_local = true;
      // Since CUPS 1.4 the new DirtyCleanInterval directive controls the delay when cupsd updates config files:
      if( ! Printerlib::WaitForUpdatedConfigFiles( _("Created New Printer Setup") ) )
      { // It returns false if the user had interrupted the waiting for updated config files:
        Popup::ErrorDetails( // Message of a Popup::ErrorDetails:
                             _("New Printer Configuration not yet Stored in the System"),
                             // Explanation details of a Popup::ErrorDetails.
                             // The 'next dialog' is the overview dialog where the printer configurations are shown
                             // which has a 'Refresh List' button to update the shown printer configurations:
                             _("If the next dialog does not show the new printer configuration as expected, wait some time and use the 'Refresh List' button.")
                           );
      }
      Wizard::EnableBackButton();
      Wizard::EnableNextButton();
      // Exit this dialog in any case:
      break;
    }
    if( ret == `connection_wizard )
    { // Exit this dialog and go to the ConnectionWizardDialog via the sequencer in wizards.ycp:
      break;
    }
    if( ret == `add_driver )
    { // Exit this dialog and go to the AddDriverDialog via the sequencer in wizards.ycp:
      break;
    }
    if( ret == `more_connections )
    { UI::ReplaceWidget( `id(`connection_selection_replace_point),
                         `Table( `id(`connection_selection),
                                 // By default there is no UserInput()
                                 // if only something was selected in the Table
                                 // (without clicking additionally a button)
                                 // but the notify and immediate options
                                 // forces UserInput() in this case:
                                 `opt(`notify, `immediate, `keepSorting),
                                 // Headers of a Table with a list of printer connections:
                                 `header( // Header of a Table column with a list of printer connections.
                                          // Printer model name:
                                          _("Model"),
                                          // Header of a Table column with a list of printer connections.
                                          // Connection of the printer (e.g. via USB or via parallel port):
                                          _("Connection"),
                                          // Header of a Table column with a list of printer connections.
                                          // Additional description of the printer or its particular connection:
                                          _("Description")
                                        ),
                                 Printer::ConnectionItems( "MoreConnections" )
                               )
                       );
      // Try to preselect the connection which matches to the current_device_uri
      // if such a connection exists in the connection_selection table:
      if( Printer::selected_connections_index >= 0 )
      { // An item which matches to Printer::selected_connections_index
        // exists in the connection_selection table because the Printer::ConnectionItems function
        // sets Printer::selected_connections_index != -1 only if such an item exists in the table
        // so that this item can be preselected:
        y2milestone( "Preselected connection: '%1'", Printer::connections[Printer::selected_connections_index]:$[] );
        UI::ChangeWidget( `connection_selection, `CurrentItem, `id(Printer::selected_connections_index) );
      }
      UI::FakeUserInput( `connection_selection );
      continue;
    }
    if( ret == `connection_selection )
    { integer selected_connection_index = (integer)UI::QueryWidget( `id(`connection_selection), `CurrentItem );
      if( nil == selected_connection_index )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when no connection was selected:
                           _("No Connection Selected"),
                           // Body of a Popup::AnyMessage when no connection was selected:
                           _("Select a connection.")
                         );
        continue;
      }
      if( selected_connection_index != Printer::selected_connections_index )
      { Printer::selected_connections_index = selected_connection_index;
        Printer::current_device_uri = Printer::connections[selected_connection_index,"uri"]:"";
        y2milestone( "Selected connection is: %1", Printer::connections[selected_connection_index]:$[] );
        // Invalidate any previously selected driver, if a connection is selected anew
        // or if a previously selected connection had changed:
        Printer::selected_ppds_index = -1;
      }
      driver_filter_string = "";
      driver_filter_input_text = "";
      queue_name_proposal = "";
      model = Printer::connections[Printer::selected_connections_index,"model"]:"";
      y2milestone( "Drivers for '%1'", model );
      if( "" != model
          && "unknown" != tolower( model )
        )
      { queue_name_proposal = Printer::NewQueueName( tolower( model ) );
        driver_filter_input_text = model;
        // Replace each sequence of spaces in driver_filter_input_text
        // by the regular expression '.*' so that the search result
        // hopefully fits better to what the user expects to get,
        // for example searching with "ACME 1000" should work to also
        // find "ACME FunPrinter 1000" and "ACME Fancy Printer 1000 XL"
        list <string> words = splitstring( driver_filter_input_text, " " );
        // A sequence of spaces results empty strings in words which are removed here:
        words = filter( string word,
                        words,
                        { return( "" != word );
                        }
                      );
        // Besides the regular expression characters '.*'
        // only the special character '+' is also taken into account
        // because this is also a meaningful character in model names
        // for example the '+' at the end of a Kyocera model name
        // indicates that this model has a built-in PostScript interpreter
        // while the model without the '+' understands only PCL.
        driver_filter_string = filterchars( tolower( mergestring( words, ".*" ) ), Printer::lower_alnum_chars + ".*+" );
        // Replace '+' by '\\+' which evaluates to '\+' (because of YCP quoting with '\\')
        // to get a '+' character in a word quoted as '\+' because otherwise
        // a '+' character would be interpreded as a special regular expression character
        // when the driver_filter_string is used as pattern for regexpmatch in DriverItems().
        driver_filter_string = mergestring( splitstring( driver_filter_string, "+" ), "\\+" );
        // The first word in the driver_filter_string is usually the first word of the manufacturer name.
        // This fuzzy match is intended so that e.g. "Kyocera" and "Kyocera Mita" result the same.
        // Note that because of the above the words in driver_filter_string are joined with '.*'
        // so that the first word in driver_filter_string must be split from the rest at '.':
        string manufacturer = splitstring( driver_filter_string, "." )[0]:"";
        // Even more fuzziness for very ambiguous manufacturer names:
        if( "hewlett" == substring( tolower( manufacturer ), 0, 7 ) )
        { // Let "Hewlett-Packard", "Hewlett Packard", and "HP be the same:
          manufacturer = "HP";
        }
        if( "oki" == substring( tolower( manufacturer ), 0, 3 ) )
        { // Let "Oki", "Okidata", and "Okipage" be the same:
          manufacturer = "Oki";
        }
        // Match at the beginning only if the first word in the driver_filter_string
        // is actually a known manufacturer name
        // (there is only "Kyocera" but not "Kyocera Mita" in the known_manufacturers list).
        foreach( string known_manufacturer,
                 Printer::known_manufacturers,
                 { if( manufacturer == tolower( known_manufacturer ) )
                   { driver_filter_string = "^" + driver_filter_string;
                     break;
                   }
                 }
               );
      }
      if( "" == driver_filter_string )
      { // Set a fallback driver_filter_string which does not match to anything
        // to avoid that the full list of thousands of PPDs is shown automatically
        // because it can take a very long time until the user can proceed:
        driver_filter_input_text = _("Enter your printer model here.");
        driver_filter_string = "qqqqqqqqqq";
      }
      UI::ReplaceWidget( `id(`driver_filter_input_replace_point),
                          `InputField
                          ( `id(`driver_filter_input), `opt(`hstretch),
                            // No InputField header because there is the "Caption for a printer driver selection":
                            "",
                            driver_filter_input_text
                          )
                       );
      UI::ReplaceWidget( `id(`driver_selection_replace_point),
                         `SelectionBox( `id(`driver_selection),
                                        // By default there is no UserInput()
                                        // if only something was selected in the SelectionBox
                                        // (without clicking additionally a button)
                                        // but the notify option forces UserInput() in this case:
                                        `opt(`notify),
                                        "",
                                        Printer::DriverItems( driver_filter_string, true )
                                      )
                       );
      UI::ReplaceWidget( `id(`queue_name_input_replace_point),
                         `InputField
                         ( `id(`queue_name_input),
                           // Header of a TextEntry to enter the queue name:
                           _("Set &Name"),
                           queue_name_proposal
                         )
                       );
      continue;
    }
    if( ret == `driver_selection )
    { integer selected_ppd_index = (integer)UI::QueryWidget( `id(`driver_selection), `CurrentItem );
      if( nil == selected_ppd_index )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when no driver was selected:
                           _("No Driver Selected"),
                           // Body of a Popup::AnyMessage when no driver was selected:
                           _("Select a driver.")
                         );
        continue;
      }
      if( selected_ppd_index != Printer::selected_ppds_index )
      { Printer::selected_ppds_index = selected_ppd_index;
        y2milestone( "Selected driver is: %1", Printer::ppds[selected_ppd_index]:$[] );
      }
      continue;
    }
    if( ret == `apply_driver_filter )
    { driver_filter_string = "";
      driver_filter_input_text = (string)UI::QueryWidget( `id(`driver_filter_input), `Value );
      y2milestone( "Drivers for '%1'", driver_filter_input_text );
      // Match anywhere in the NickName entry in the PPD (i.e. without leading '^').
      // Replace each sequence of spaces in driver_filter_input_text
      // by the regular expression '.*' so that the search result
      // hopefully fits better to what the user expects to get,
      // for example searching with "ACME 1000" should work to also
      // find "ACME FunPrinter 1000" and "ACME Fancy Printer 1000 XL"
      list <string> words = splitstring( driver_filter_input_text, " " );
      // A sequence of spaces results empty strings in words which are removed here:
      words = filter( string word,
                      words,
                      { return( "" != word );
                      }
                    );
      // Besides the regular expression characters '.*'
      // only the special character '+' is also taken into account
      // because this is also a meaningful character in model names
      // for example the '+' at the end of a Kyocera model name
      // indicates that this model has a built-in PostScript interpreter
      // while the model without the '+' understands only PCL.
      driver_filter_string = filterchars( tolower( mergestring( words, ".*" ) ), Printer::lower_alnum_chars + ".*+" );
      // Replace '+' by '\\+' which evaluates to '\+' (because of YCP quoting with '\\')
      // to get a '+' character in a word quoted as '\+' because otherwise
      // a '+' character would be interpreded as a special regular expression character
      // when the driver_filter_string is used as pattern for regexpmatch in DriverItems().
      driver_filter_string = mergestring( splitstring( driver_filter_string, "+" ), "\\+" );
      if( "" == driver_filter_string )
      { driver_filter_input_text = _("any model");
      }
      UI::ReplaceWidget( `id(`driver_filter_input_replace_point),
                          `InputField
                          ( `id(`driver_filter_input), `opt(`hstretch),
                            // No InputField header because there is the "Caption for a printer driver selection":
                            "",
                            driver_filter_input_text
                          )
                       );
      UI::ReplaceWidget( `id(`driver_selection_replace_point),
                         `SelectionBox( `id(`driver_selection),
                                        // By default there is no UserInput()
                                        // if only something was selected in the SelectionBox
                                        // (without clicking additionally a button)
                                        // but the notify option forces UserInput() in this case:
                                        `opt(`notify),
                                        "",
                                        Printer::DriverItems( driver_filter_string, true )
                                      )
                       );
      continue;
    }
    if( ret == `more_drivers )
    { if( "qqqqqqqqqq" != driver_filter_string )
      { driver_filter_string = "";
      }
      boolean valid_driver_found = false;
      list driver_items = [];
      // Use the existing value of driver_filter_input_text
      // which is by default set to the autodetected model name
      // but it could be any string which was entered before by the user.
      // The "more drivers" functionality must work based on the current search string
      // and when nothing is found based on the current search string
      // it falls back to show all drivers so that there is a valid result in any case.
      driver_filter_input_text = (string)UI::QueryWidget( `id(`driver_filter_input), `Value );
      y2milestone( "More drivers for '%1'", driver_filter_input_text );
      if( "" != driver_filter_input_text
          && "unknown" != tolower( driver_filter_input_text )
          && "qqqqqqqqqq" != driver_filter_string
        )
      { // If the driver_filter_input_text string does not contain a space,
        // words is a singleton list which contains only one word.
        list <string> words = splitstring( driver_filter_input_text, " " );
        if( size( words ) >= 1 )
        { // Even if it is only one word, the following makes sense
          // because the one word could already be the model_number_word.
          // Try to find the word which contains a model number.
          // This is usually the first word which contains a number.
          string model_number_word = "";
          foreach( string word,
                   words,
                   { if( "" != filterchars( word, Printer::number_chars ) )
                     { model_number_word = word;
                       break;
                     }
                   }
                 );
          // Provide visible feeback what is going on:
          UI::ReplaceWidget( `id(`driver_filter_input_replace_point),
                             `InputField
                             ( `id(`driver_filter_input),
                               `opt(`hstretch),
                               // No InputField header because there is the "Caption for a printer driver selection":
                               "",
                               model_number_word
                             )
                           );
          // Only the special character '+' is also taken into account
          // because this is also a meaningful character in model names
          // for example the '+' at the end of a Kyocera model name
          // indicates that this model has a built-in PostScript interpreter
          // while the model without the '+' understands only PCL.
          driver_filter_string = filterchars( tolower( model_number_word ), Printer::lower_alnum_chars + "+" );
          // Replace '+' by '\\+' which evaluates to '\+' (because of YCP quoting with '\\')
          // to get a '+' character in a word quoted as '\+' because otherwise
          // a '+' character would be interpreded as a special regular expression character
          // when the driver_filter_string is used as pattern for regexpmatch in DriverItems().
          driver_filter_string = mergestring( splitstring( driver_filter_string, "+" ), "\\+" );
          if( "" != driver_filter_string )
          { driver_items = Printer::DriverItems( driver_filter_string, true );
            // Printer::DriverItems may result a driver_items list with one single element
            //   [ `item( `id( -1 ), _("No matching driver found.") ) ]
            // to show at least a meaningful text as fallback entry to the user
            // or Printer::DriverItems may result a driver_items list with the first item
            //   [ `item( `id( -1 ), _("Select a driver.") ), ... ]
            // when Printer::DriverItems could not preselect a driver item.
            // If a valid driver was found (but perhaps none was preselected),
            // there would be a non-negative id value of the first or second element
            // which is driver_items[0,0,0] or driver_items[1,0,0]
            // (id[0] is the value of the id, see the comment in Printer::DriverItems).
            if( driver_items[0,0,0]:-1 >= 0
                || driver_items[1,0,0]:-1 >= 0
              )
            { valid_driver_found = true;
            }
          }
        }
        // Try to use the manufacturer when nothing was found above:
        if( ! valid_driver_found )
        { driver_filter_string = "";
          // The first word in the driver_filter_input_text is usually the first word of the manufacturer name.
          // This fuzzy match is intended so that e.g. "Kyocera" and "Kyocera Mita" are the same.
          string manufacturer = splitstring( driver_filter_input_text, " " )[0]:"";
          if( "" != manufacturer )
          { // Even more fuzziness for very ambiguous manufacturer names:
            if( "hewlett" == substring( tolower( driver_filter_input_text ), 0, 7 ) )
            { // Let "Hewlett-Packard", "Hewlett Packard", and "HP be the same:
              manufacturer = "HP";
            }
            if( "oki" == substring( tolower( driver_filter_input_text ), 0, 3 ) )
            { // Let "Oki", "Okidata", and "Okipage" be the same:
              manufacturer = "Oki";
            }
            // Provide visible feeback what is going on:
            UI::ReplaceWidget( `id(`driver_filter_input_replace_point),
                               `InputField
                               ( `id(`driver_filter_input),
                                 `opt(`hstretch),
                                 // No InputField header because there is the "Caption for a printer driver selection":
                                  "",
                                 manufacturer
                               )
                             );
            driver_filter_string = filterchars( tolower( manufacturer ), Printer::lower_alnum_chars );
            if( "" != driver_filter_string )
            { // Match at the beginning only if the driver_filter_string is actually a known manufacturer:
              foreach( string known_manufacturer,
                       Printer::known_manufacturers,
                       { if( driver_filter_string == tolower( known_manufacturer ) )
                         { driver_filter_string = "^" + driver_filter_string;
                           break;
                         }
                       }
                     );
              driver_items = Printer::DriverItems( driver_filter_string, true );
              // Printer::DriverItems may result a driver_items list with one single element
              //   [ `item( `id( -1 ), _("No matching driver found.") ) ]
              // to show at least a meaningful text as fallback entry to the user
              // or Printer::DriverItems may result a driver_items list with the first item
              //   [ `item( `id( -1 ), _("Select a driver.") ), ... ]
              // when Printer::DriverItems could not preselect a driver item.
              // If a valid driver was found (but perhaps none was preselected),
              // there would be a non-negative id value of the first or second element
              // which is driver_items[0,0,0] or driver_items[1,0,0]
              // (id[0] is the value of the id, see the comment in Printer::DriverItems).
              if( driver_items[0,0,0]:-1 >= 0
                  || driver_items[1,0,0]:-1 >= 0
                )
              { valid_driver_found = true;
              }
            }
          }
        }
      }
      // Nothing was found above.
      // Fall back to show all drivers:
      if( ! valid_driver_found )
      { // Provide visible feeback what is going on:
        UI::ReplaceWidget( `id(`driver_filter_input_replace_point),
                           `InputField
                           ( `id(`driver_filter_input),
                             `opt(`hstretch),
                             // No InputField header because there is the "Caption for a printer driver selection":
                             "",
                             _("any model")
                           )
                         );
        driver_items = Printer::DriverItems( "", true );
      }
      UI::ReplaceWidget( `id(`driver_selection_replace_point),
                         `SelectionBox
                         ( `id(`driver_selection),
                           // By default there is no UserInput()
                           // if only something was selected in the SelectionBox
                           // (without clicking additionally a button)
                           // but the notify option forces UserInput() in this case:
                           `opt(`notify),
                           "",
                           driver_items
                         )
                       );
      continue;
    }
    y2milestone( "Ignoring unexpected returncode in BasicAddDialog: %1", ret );
    continue;
  }
  y2milestone( "leaving BasicAddDialog" );
  return ret;
}

/* EOF */
}
