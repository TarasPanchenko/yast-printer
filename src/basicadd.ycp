/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:        include/printer/basicadd.ycp
 * Package:     Configuration of printer
 * Summary:     Basic add dialog definition
 * Authors:     Johannes Meixner <jsmeix@suse.de>
 *
 * $Id: basicadd.ycp 27914 2006-02-13 14:32:08Z locilka $
 */

{

textdomain "printer";

import "Label";
import "Wizard";
import "Printer";
import "Printerlib";
import "Popup";

include "printer/helps.ycp";

/**
 * BasicAddDialog dialog
 * @return dialog result
 */
any BasicAddDialog()
{ y2milestone( "entering BasicAddDialog" );
  string any_model_driver_filter_input_text = _("any model");
  string non_matching_fallback_driver_filter_string = "qqqqqqqqqq";
  // Caption for the "Add Printer" dialog (BasicAddDialog):
  string caption = _("Add New Printer Configuration");
  // Clear whatever content of a previous dialog which would show up here for several seconds
  // until all the following stuff is done before Wizard::SetContentsButtons is called
  // which finally shows the right content for this dialog.
  Wizard::SetContents( caption,
                       `Empty(),
                       HELPS["basic_add_dialog"]:"",
                       false,
                       false
                     );
  Wizard::HideAbortButton();
  string driver_filter_string = "BasicAddDialog";
  string driver_filter_input_text = "";
  string queue_name_proposal = "";
  string model = Printer::connections[Printer::selected_connections_index,"model"]:"";
  if( "" != model
      && "unknown" != tolower( model )
    )
  { queue_name_proposal = Printer::NewQueueName( tolower( model ) );
    driver_filter_input_text = Printer::DeriveModelName( model, 0 );
    driver_filter_string = Printer::DeriveDriverFilterString( driver_filter_input_text );
  }
  if( "" == driver_filter_string )
  { // Set a fallback driver_filter_string which does not match to anything
    // to avoid that the full list of thousands of PPDs is shown automatically
    // because it can take a very long time until the user can proceed:
    driver_filter_input_text = _("Enter your printer model here.");
    driver_filter_string = non_matching_fallback_driver_filter_string;
  }
  term contents = `VBox
                  ( `VBox
                    ( `HBox
                      ( `Label
                        ( // Caption for a Table with a list of printer connections:
                          _("Specify the Connection")
                        ),
                        `HStretch(),
                        `PushButton
                        ( `id(`more_connections),
                          // Label of a PushButton to restart printer autodetection
                          // to show more available printer connections
                          // in the Table with a list of printer connections:
                          _("&Detect More")
                        ),
                        `PushButton
                        ( `id(`connection_wizard),
                          // Label of a PushButton to go to the "Connection Wizard"
                          // to specify the printer connection individually:
                          _("Connection &Wizard")
                        )
                      ),
                      `ReplacePoint
                      ( `id(`connection_selection_replace_point),
                        `Table
                        ( `id(`connection_selection),
                          // By default there is no UserInput()
                          // if only something was selected in the Table
                          // (without clicking additionally a button)
                          // but the notify and immediate options
                          // forces UserInput() in this case:
                          `opt(`notify, `immediate, `keepSorting),
                          // Headers of a Table with a list of printer connections:
                          `header
                          ( // Header of a Table column with a list of printer connections.
                            // Printer model name:
                            _("Model"),
                            // Header of a Table column with a list of printer connections.
                            // Connection of the printer (e.g. via USB or via parallel port):
                            _("Connection"),
                            // Header of a Table column with a list of printer connections.
                            // Additional description of the printer or its particular connection:
                            _("Description")
                          ),
                          Printer::ConnectionItems( "BasicAddDialog" )
                        )
                      )
                    ),
                    `VStretch(),
                    `VBox
                    ( `Left
                      ( `Label
                        ( // Caption for a printer driver selection:
                          _("Find and Assign a Driver")
                        )
                      ),
                      `HBox
                      ( `ReplacePoint
                        ( `id(`apply_driver_filter_replace_point),
                          `PushButton
                          ( `id(`apply_driver_filter),
                            // This button must be the default
                            // (it is activated when the user pressed the Enter key)
                            // because when the user has clicked into InputField to enter something
                            // it is normal to finish entering by pressing the Enter key
                            // but if the Enter key was linked to 'Next' or 'Back',
                            // the user would get the wrong action.
                            `opt(`default),
                            // Label of a PushButton to search a list for a search string
                            // and then show the search result:
                            _("&Search for")
                          )
                        ),
                        `ReplacePoint
                        ( `id(`driver_filter_input_replace_point),
                          `InputField
                          ( `id(`driver_filter_input),
                            `opt(`hstretch),
                            // No InputField header because there is the "Caption for a printer driver selection":
                            "",
                            // Make it lowercase to make it more obvious that this is a search string
                            // which the user could change as needed and not a final fixed model name.
                            // Many users do not understand that the model name which is preset here
                            // (i.e. initially for this dialog and when the user selected a connection)
                            // as search string can be changed by the user as needed to find drivers.
                            tolower( driver_filter_input_text )
                          )
                        ),
                        `PushButton
                        ( `id(`more_drivers),
                          // Label of a PushButton to find and show more available printer drivers:
                          _("&Find More")
                        ),
                        `PushButton
                        ( `id(`add_driver),
                          // Label of a PushButton to go to the "Add Driver" dialog
                          // to install or remove driver packages (and perhaps download it before):
                          _("Driver &Packages")
                        )
                      ),
                      `ReplacePoint
                      ( `id(`driver_selection_replace_point),
                        `SelectionBox
                        ( `id(`driver_selection),
                          // By default there is no UserInput()
                          // if only something was selected in the SelectionBox
                          // (without clicking additionally a button)
                          // but the notify option forces UserInput() in this case:
                          `opt(`notify),
                          "",
                          [ `item( `id( -1 ), _("Select a driver.") ) ]
                        )
                      ),
                      `RadioButtonGroup
                      ( `id(`paper_size_radio_buttons),
                        `HBox
                        ( `Label
                          ( // Label of a RadioButtonGroup to specify the default paper size:
                            _("Default paper size (if printer and driver supports it)")
                          ),
                          // Have none of the RadioButtons preselected which means that
                          // by default the CUPS default is used for the default paper size.
                          // For the CUPS 1.3 default see http://www.cups.org/str.php?L2846
                          // For CUPS 1.4 the default depends on the "DefaultPaperSize" setting in cupsd.conf
                          // see https://bugzilla.novell.com/show_bug.cgi?id=395760
                          // and http://www.cups.org/str.php?L2848
                          `HSpacing( 2 ),
                          `RadioButton( `id(`a4), "A&4" ),
                          `HSpacing( 1 ),
                          `RadioButton( `id(`letter), "Le&tter" ),
                          `HStretch()
                        )
                      )
                    ),
                    `VStretch(),
                    `Left
                    ( `HBox
                      ( `ReplacePoint
                        ( `id(`queue_name_input_replace_point),
                          `InputField
                          ( `id(`queue_name_input),
                            // Avoid that it becomes squeezed to only a few characters in text mode:
                            `opt(`hstretch),
                            // Header of a TextEntry to enter the queue name:
                            _("Set Arbitrary &Name"),
                            queue_name_proposal
                          )
                        ),
                        `HStretch(),
                        `VBox
                        ( `Right
                          ( `Label
                            ( // Label text to run HPLIP's printer setup tool 'hp-setup'
                              // to set up HP printers which runs only in English language:
                              _("Alternative setup for HP printers (English only):")
                            )
                          ),
                          `Right
                          ( `PushButton
                            ( `id(`run_hpsetup),
                              // Label of a PushButton to run HPLIP's printer setup tool 'hp-setup'.
                              // Do not change or translate "hp-setup", it is a program name:
                              _("Run &hp-setup")
                            )
                          )
                        )
                      )
                    )
                  );
  // According to http://en.opensuse.org/YaST/Style_Guide#Single_Configuration.2FOverview.2FEdit_Dialog
  // there is no longer a "abort" functionality which exits the whole module.
  // Instead this button is now named "Cancel" and its functionality is
  // to go back to the Overview dialog (i.e. what the "back" button would do)
  // because it reads "Cancel - Closes the window and returns to the overview."
  // Therefore the button with the "abort" functionality is not shown at all
  // and the button with the "back" functionality is named "Cancel".
  // According to http://en.opensuse.org/YaST/Style_Guide#Single_Configuration.2FOverview.2FEdit_Dialog
  // the "finish" button in a single (step) configuration dialog must now be named "OK".
  Wizard::SetContentsButtons( caption,
                              contents,
                              HELPS["basic_add_dialog"]:"",
                              // Set a new label for the "back" button, see the comment above:
                              Label::CancelButton(),
                              // Set a new label for the "next" button, see the comment above:
                              Label::OKButton()
                            );
  Wizard::HideAbortButton();
  // Try to preselect the connection which matches to the current_device_uri
  // if such a connection exists in the connection_selection table:
  if( Printer::selected_connections_index >= 0 )
  { // An item which matches to Printer::selected_connections_index
    // exists in the connection_selection table because the Printer::ConnectionItems function
    // sets Printer::selected_connections_index != -1 only if such an item exists in the table
    // so that this item can be preselected:
    y2milestone( "Preselected connection: '%1'", Printer::connections[Printer::selected_connections_index]:$[] );
    UI::ChangeWidget( `connection_selection, `CurrentItem, `id(Printer::selected_connections_index) );
  }
  UI::FakeUserInput( `connection_selection );
  any user_input = nil;
  while( true )
  { // Replace the [Search for] button with itself to enforce it is the default widget
    // (the default widget is the result of UI::UserInput when the user pressed the Enter key)
    // regardless whatever function call or UI bug (e.g. bnc#558900) may have changed the default widget:
    UI::ReplaceWidget( `id(`apply_driver_filter_replace_point),
                       `PushButton
                       ( `id(`apply_driver_filter),
                         // This button must be the default
                         // (it is activated when the user pressed the Enter key)
                         // because when the user has clicked into InputField to enter something
                         // it is normal to finish entering by pressing the Enter key
                         // but if the Enter key was linked to 'Next' or 'Back',
                         // the user would get the wrong action.
                         `opt(`default),
                         // Label of a PushButton to search a list for a search string
                         // and then show the search result:
                         _("&Search for")
                       )
                     );
    // Set the focus to the InputField for the driver search string
    // so that the user can just start typing:
    UI::SetFocus( `driver_filter_input );
    // Wait for user input:
    user_input = UI::UserInput();
    if( `abort == user_input || `cancel == user_input || `back == user_input ) break;
    if( `next == user_input )
    { if( Printer::selected_connections_index < 0
          && Printer::selected_ppds_index < 0
        )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when neither a connection
                           // nor a driver was selected:
                           _("Nothing Selected"),
                           // Body of a Popup::AnyMessage when neither a connection
                           // nor a driver was selected:
                           _("Select a connection and then assign a driver.")
                         );
        continue;
      }
      if( Printer::selected_connections_index < 0 )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when no connection was selected:
                           _("No Connection Selected"),
                           // Body of a Popup::AnyMessage when no connection was selected:
                           _("Select a connection.")
                         );
        continue;
      }
      if( Printer::selected_ppds_index < 0 )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when no driver was selected:
                           _("No Driver Selected"),
                           // Body of a Popup::AnyMessage when no driver was selected:
                           _("Select a driver.")
                         );
        continue;
      }
      string queue_name = (string)UI::QueryWidget( `id(`queue_name_input), `Value );
      if( "" == queue_name )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when no queue name was entered:
                           _("No Queue Name"),
                           // Body of a Popup::AnyMessage when no queue name was entered:
                           _("Enter a queue name.")
                         );
        continue;
      }
      if( "" != deletechars( queue_name, Printer::alnum_chars + "_" ) )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when a wrong queue name was entered:
                           _("Invalid Queue Name"),
                           // Body of a Popup::AnyMessage when a wrong queue name was entered:
                           _("Only letters (a-z and A-Z), numbers (0-9), and the underscore '_' are allowed for the queue name.")
                         );
        continue;
      }
      string validated_queue_name = Printer::NewQueueName( queue_name );
      if( queue_name != validated_queue_name )
      { if( ! Popup::ContinueCancelHeadline( // Header of a Popup::ContinueCancelHeadline
                                             // when a queue name is changed to be valid:
                                             _("Confirm Validated Queue Name"),
                                             // Body of a Popup::ContinueCancelHeadline
                                             // when a queue name was automatically changed to be valid
                                             // where %1 will be replaced by the old invalid queue name
                                             // and %2 will be replaced by a new valid queue name
                                             sformat( _("'%1' is invalid or it exists already. Use '%2' instead?"), queue_name, validated_queue_name )
                                           )
          )
        { // The user has decided not to accept the changed queue name:
          continue;
        }
        queue_name = validated_queue_name;
      }
      string default_paper_size = "";
      any paper_size = UI::QueryWidget( `id(`paper_size_radio_buttons), `CurrentButton );
      if( `a4 == paper_size )
      { default_paper_size = "A4";
      }
      if( `letter == paper_size )
      { default_paper_size = "Letter";
      }
      Wizard::DisableBackButton();
      Wizard::DisableNextButton();
      // No error messages here because Printer::AddQueue already shows them:
      Printer::AddQueue( queue_name, default_paper_size );
      // After a local queue was added, enforce to show also local queues
      // in particular when no local queues were shown before:
      Printer::queue_filter_show_local = true;
      // Since CUPS 1.4 the new DirtyCleanInterval directive controls the delay when cupsd updates config files:
      if( ! Printerlib::WaitForUpdatedConfigFiles( _("Created New Printer Setup") ) )
      { // It returns false if the user had interrupted the waiting for updated config files:
        Popup::ErrorDetails( // Message of a Popup::ErrorDetails:
                             _("New Printer Configuration not yet Stored in the System"),
                             // Explanation details of a Popup::ErrorDetails.
                             // The 'next dialog' is the overview dialog where the printer configurations are shown
                             // which has a 'Refresh List' button to update the shown printer configurations:
                             _("If the next dialog does not show the new printer configuration as expected, wait some time and use the 'Refresh List' button.")
                           );
      }
      Wizard::EnableBackButton();
      Wizard::EnableNextButton();
      // Exit this dialog in any case:
      break;
    }
    if( `connection_wizard == user_input )
    { // Exit this dialog and go to the ConnectionWizardDialog via the sequencer in wizards.ycp:
      break;
    }
    if( `add_driver == user_input )
    { // Exit this dialog and go to the AddDriverDialog via the sequencer in wizards.ycp:
      break;
    }
    if( `more_connections == user_input )
    { UI::ReplaceWidget( `id(`connection_selection_replace_point),
                         `Table( `id(`connection_selection),
                                 // By default there is no UserInput()
                                 // if only something was selected in the Table
                                 // (without clicking additionally a button)
                                 // but the notify and immediate options
                                 // forces UserInput() in this case:
                                 `opt(`notify, `immediate, `keepSorting),
                                 // Headers of a Table with a list of printer connections:
                                 `header( // Header of a Table column with a list of printer connections.
                                          // Printer model name:
                                          _("Model"),
                                          // Header of a Table column with a list of printer connections.
                                          // Connection of the printer (e.g. via USB or via parallel port):
                                          _("Connection"),
                                          // Header of a Table column with a list of printer connections.
                                          // Additional description of the printer or its particular connection:
                                          _("Description")
                                        ),
                                 Printer::ConnectionItems( "MoreConnections" )
                               )
                       );
      // Try to preselect the connection which matches to the current_device_uri
      // if such a connection exists in the connection_selection table:
      if( Printer::selected_connections_index >= 0 )
      { // An item which matches to Printer::selected_connections_index
        // exists in the connection_selection table because the Printer::ConnectionItems function
        // sets Printer::selected_connections_index != -1 only if such an item exists in the table
        // so that this item can be preselected:
        y2milestone( "Preselected connection: '%1'", Printer::connections[Printer::selected_connections_index]:$[] );
        UI::ChangeWidget( `connection_selection, `CurrentItem, `id(Printer::selected_connections_index) );
      }
      UI::FakeUserInput( `connection_selection );
      continue;
    }
    if( `connection_selection == user_input )
    { integer selected_connection_index = (integer)UI::QueryWidget( `id(`connection_selection), `CurrentItem );
      if( nil == selected_connection_index )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when no connection was selected:
                           _("No Connection Selected"),
                           // Body of a Popup::AnyMessage when no connection was selected:
                           _("Select a connection.")
                         );
        continue;
      }
      if( selected_connection_index != Printer::selected_connections_index )
      { Printer::selected_connections_index = selected_connection_index;
        Printer::current_device_uri = Printer::connections[selected_connection_index,"uri"]:"";
        y2milestone( "Selected connection is: %1", Printer::connections[selected_connection_index]:$[] );
        // Invalidate any previously selected driver, if a connection is selected anew
        // or if a previously selected connection had changed:
        Printer::selected_ppds_index = -1;
      }
      driver_filter_string = "";
      driver_filter_input_text = "";
      queue_name_proposal = "";
      model = Printer::connections[Printer::selected_connections_index,"model"]:"";
      y2milestone( "Drivers for '%1'", model );
      if( "" != model
          && "unknown" != tolower( model )
        )
      { queue_name_proposal = Printer::NewQueueName( tolower( model ) );
        driver_filter_input_text = Printer::DeriveModelName( model, 0 );
        driver_filter_string = Printer::DeriveDriverFilterString( driver_filter_input_text );
      }
      if( "" == driver_filter_string )
      { // Set a fallback driver_filter_string which does not match to anything
        // to avoid that the full list of thousands of PPDs is shown automatically
        // because it can take a very long time until the user can proceed:
        driver_filter_input_text = _("Enter your printer model here.");
        driver_filter_string = non_matching_fallback_driver_filter_string;
      }
      UI::ReplaceWidget( `id(`driver_filter_input_replace_point),
                          `InputField
                          ( `id(`driver_filter_input), `opt(`hstretch),
                            // No InputField header because there is the "Caption for a printer driver selection":
                            "",
                            // Make it lowercase to make it more obvious that this is a search string
                            // which the user could change as needed and not a final fixed model name.
                            // Many users do not understand that the model name which is preset here
                            // (i.e. initially for this dialog and when the user selected a connection)
                            // as search string can be changed by the user as needed to find drivers.
                            tolower( driver_filter_input_text )
                          )
                       );
      UI::ReplaceWidget( `id(`driver_selection_replace_point),
                         `SelectionBox( `id(`driver_selection),
                                        // By default there is no UserInput()
                                        // if only something was selected in the SelectionBox
                                        // (without clicking additionally a button)
                                        // but the notify option forces UserInput() in this case:
                                        `opt(`notify),
                                        "",
                                        Printer::DriverItems( driver_filter_string, true )
                                      )
                       );
      UI::ReplaceWidget( `id(`queue_name_input_replace_point),
                         `InputField
                         ( `id(`queue_name_input),
                            // Avoid that it becomes squeezed to only a few characters in text mode:
                            `opt(`hstretch),
                           // Header of a TextEntry to enter the queue name:
                           _("Set Arbitrary &Name"),
                           queue_name_proposal
                         )
                       );
      continue;
    }
    if( `driver_selection == user_input )
    { integer selected_ppd_index = (integer)UI::QueryWidget( `id(`driver_selection), `CurrentItem );
      if( nil == selected_ppd_index )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when no driver was selected:
                           _("No Driver Selected"),
                           // Body of a Popup::AnyMessage when no driver was selected:
                           _("Select a driver.")
                         );
        continue;
      }
      if( selected_ppd_index != Printer::selected_ppds_index )
      { Printer::selected_ppds_index = selected_ppd_index;
        y2milestone( "Selected driver is: %1", Printer::ppds[selected_ppd_index]:$[] );
      }
      continue;
    }
    if( `apply_driver_filter == user_input )
    { driver_filter_input_text = (string)UI::QueryWidget( `id(`driver_filter_input), `Value );
      y2milestone( "Drivers for '%1'", driver_filter_input_text );
      if( any_model_driver_filter_input_text == driver_filter_input_text )
      { driver_filter_input_text = "";
      }
      driver_filter_string = Printer::DeriveDriverFilterString( driver_filter_input_text );
      if( "" == driver_filter_string )
      { driver_filter_input_text = any_model_driver_filter_input_text;
      }
      UI::ReplaceWidget( `id(`driver_filter_input_replace_point),
                          `InputField
                          ( `id(`driver_filter_input), `opt(`hstretch),
                            // No InputField header because there is the "Caption for a printer driver selection":
                            "",
                            driver_filter_input_text
                          )
                       );
      UI::ReplaceWidget( `id(`driver_selection_replace_point),
                         `SelectionBox( `id(`driver_selection),
                                        // By default there is no UserInput()
                                        // if only something was selected in the SelectionBox
                                        // (without clicking additionally a button)
                                        // but the notify option forces UserInput() in this case:
                                        `opt(`notify),
                                        "",
                                        Printer::DriverItems( driver_filter_string, true )
                                      )
                       );
      continue;
    }
    if( `more_drivers == user_input )
    { if( non_matching_fallback_driver_filter_string != driver_filter_string )
      { driver_filter_string = "";
      }
      boolean valid_driver_found = false;
      list driver_items = [];
      // Use the existing value of driver_filter_input_text
      // which is by default set to the autodetected model name
      // but it could be any string which was entered before by the user.
      // The "more drivers" functionality must work based on the current search string
      // and when nothing is found based on the current search string
      // it falls back to show all drivers so that there is a valid result in any case.
      driver_filter_input_text = (string)UI::QueryWidget( `id(`driver_filter_input), `Value );
      y2milestone( "More drivers for '%1'", driver_filter_input_text );
      if( "" != driver_filter_input_text
          && "unknown" != tolower( driver_filter_input_text )
          && any_model_driver_filter_input_text != driver_filter_input_text
          && non_matching_fallback_driver_filter_string != driver_filter_string
        )
      { string manufacturer_and_model_number = Printer::DeriveModelName( driver_filter_input_text, 2 );
        // Note that manufacturer_and_model_number may be the empty string
        // (when driver_filter_input_text does not contain word which contains a number)
        // or manufacturer_and_model_number may be only one word
        // (when driver_filter_input_text starts with a known manufacturer
        //  but does not contain a word which contains a number
        //  or when driver_filter_input_text does not start with a known manufacturer
        //  but contains a word which contains a number).
        if( "" != manufacturer_and_model_number
            && issubstring( manufacturer_and_model_number, " ")
          )
        { // Provide visible feeback what is going on:
          UI::ReplaceWidget( `id(`driver_filter_input_replace_point),
                             `InputField
                             ( `id(`driver_filter_input),
                               `opt(`hstretch),
                               // No InputField header because there is the "Caption for a printer driver selection":
                               "",
                               manufacturer_and_model_number
                             )
                           );
          driver_filter_string = Printer::DeriveDriverFilterString( manufacturer_and_model_number );
          if( "" != driver_filter_string )
          { driver_items = Printer::DriverItems( driver_filter_string, true );
            // Printer::DriverItems may result a driver_items list with one single element
            //   [ `item( `id( -1 ), _("No matching driver found.") ) ]
            // to show at least a meaningful text as fallback entry to the user
            // or Printer::DriverItems may result a driver_items list with the first item
            //   [ `item( `id( -1 ), _("Select a driver.") ), ... ]
            // when Printer::DriverItems could not preselect a driver item.
            // If a valid driver was found (but perhaps none was preselected),
            // there would be a non-negative id value of the first or second element
            // which is driver_items[0,0,0] or driver_items[1,0,0]
            // (id[0] is the value of the id, see the comment in Printer::DriverItems).
            if( driver_items[0,0,0]:-1 >= 0
                || driver_items[1,0,0]:-1 >= 0
              )
            { valid_driver_found = true;
            }
          }
        }
        // Try to use only the manufacturer or only the model number when nothing was found above:
        if( ! valid_driver_found )
        { string manufacturer_or_model_number = Printer::DeriveModelName( driver_filter_input_text, 1 );
          if( "" != manufacturer_or_model_number )
          { // Provide visible feeback what is going on:
            UI::ReplaceWidget( `id(`driver_filter_input_replace_point),
                               `InputField
                               ( `id(`driver_filter_input),
                                 `opt(`hstretch),
                                 // No InputField header because there is the "Caption for a printer driver selection":
                                 "",
                                 manufacturer_or_model_number
                               )
                             );
            driver_filter_string = Printer::DeriveDriverFilterString( manufacturer_or_model_number );
            if( "" != driver_filter_string )
            { driver_items = Printer::DriverItems( driver_filter_string, true );
              // Printer::DriverItems may result a driver_items list with one single element
              //   [ `item( `id( -1 ), _("No matching driver found.") ) ]
              // to show at least a meaningful text as fallback entry to the user
              // or Printer::DriverItems may result a driver_items list with the first item
              //   [ `item( `id( -1 ), _("Select a driver.") ), ... ]
              // when Printer::DriverItems could not preselect a driver item.
              // If a valid driver was found (but perhaps none was preselected),
              // there would be a non-negative id value of the first or second element
              // which is driver_items[0,0,0] or driver_items[1,0,0]
              // (id[0] is the value of the id, see the comment in Printer::DriverItems).
              if( driver_items[0,0,0]:-1 >= 0
                  || driver_items[1,0,0]:-1 >= 0
                )
              { valid_driver_found = true;
              }
            }
          }
        }
      }
      // Nothing was found above.
      // Fall back to show all drivers:
      if( ! valid_driver_found )
      { // Provide visible feeback what is going on:
        UI::ReplaceWidget( `id(`driver_filter_input_replace_point),
                           `InputField
                           ( `id(`driver_filter_input),
                             `opt(`hstretch),
                             // No InputField header because there is the "Caption for a printer driver selection":
                             "",
                             any_model_driver_filter_input_text
                           )
                         );
        driver_items = Printer::DriverItems( "", true );
      }
      UI::ReplaceWidget( `id(`driver_selection_replace_point),
                         `SelectionBox
                         ( `id(`driver_selection),
                           // By default there is no UserInput()
                           // if only something was selected in the SelectionBox
                           // (without clicking additionally a button)
                           // but the notify option forces UserInput() in this case:
                           `opt(`notify),
                           "",
                           driver_items
                         )
                       );
      continue;
    }
    if( `run_hpsetup == user_input )
    { // Run hp-setup and wait until it is finished, then go back directly to the Overview dialog.
      // Printer::RunHpsetup() returns false only if hp-setup cannot be run.
      // It returns true in any other case because there is no usable exit code of hp-setup
      // (always zero even in case of error).
      // The hp-setup exit code does not matter because the printer autodetection in the Overview dialog
      // will show an appropriate result (e.g. no new print queue if hp-setup failed):
      if( ! Printer::RunHpsetup() )
      { Popup::Error( // Message of a Popup::Error.
                      // Only a simple message because before the RunHpsetup function was called
                      // and this function would have shown more specific messages.
                      // Do not change or translate "hp-setup", it is a program name:
                      _("Failed to run hp-setup.")
                    );
        continue;
      }
      // Exit this dialog and run go back to the Overview dialog via the sequencer in wizards.ycp
      // to show the new printer autodetection results:
      break;
    }
    y2milestone( "Ignoring unexpected returncode in BasicAddDialog: %1", user_input );
    continue;
  }
  y2milestone( "leaving BasicAddDialog" );
  return user_input;
}

/* EOF */
}
