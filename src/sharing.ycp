/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:        include/printer/sharing.ycp
 * Package:     Configuration of printer
 * Summary:     Print queue sharing and publishing dialog definition
 * Authors:     Johannes Meixner <jsmeix@suse.de>
 *
 * $Id: dialogs.ycp 27914 2006-02-13 14:32:08Z locilka $
 */

{

textdomain "printer";

import "Label";
import "Wizard";
import "Printer";
import "Printerlib";
import "Popup";

include "printer/helps.ycp";

boolean share_printers_dialog_is_useless = false;
list< term > interface_table_items = [];
list< term > ip_table_items = [];
list< string > available_interfaces = [];
boolean sharing_has_changed = false;

term widgetSharing = `VBox
                     ( `VSpacing( 1 ),
                       `RadioButtonGroup
                       ( `id(`deny_or_allow_remote_access),
                         `VBox
                         ( `Left
                           ( `RadioButton
                             ( `id(`deny_remote_access_radio_button),
                               `opt(`notify),
                               // A RadioButton label to deny remote access to local print queues:
                               _("&Deny remote access"),
                               true
                             )
                           ),
                           `VSpacing( 2 ),
                           `Left
                           ( `RadioButton
                             ( `id(`allow_remote_access_radio_button),
                               `opt(`notify),
                               // A RadioButton label to allow remote access to local print queues:
                               _("&Allow remote access"),
                               false
                             )
                           )
                         )
                       ),
                       `VSpacing( 1 ),
                       `HBox
                       ( `HSpacing( 3 ),
                         `VBox
                         ( `Left
                           ( `CheckBox
                             ( `id(`allow_local_network_access_check_box),
                               // A CheckBox label to allow remote access to local print queues
                               // for computers within the local network:
                               _("For computers within the &local network"),
                               false
                             )
                           ),
                           `Left
                           ( `HBox
                             ( `HSpacing( 2 ),
                               `CheckBox
                               ( `id(`publish_to_local_network_check_box),
                                 // A CheckBox label to publish local print queues by default within the local network:
                                 _("&Publish printers by default within the local network"),
                                 false
                               )
                             )
                           ),
                           `VSpacing( 1 ),
                           `Left
                           ( `Label
                             ( `id(`interface_table_label),
                               // A caption for a table to allow remote access to local print queues
                               // via network interfaces specified in the table below:
                               _("Via network interfaces specified below")
                             )
                           ),
                           `Table
                           ( `id(`interface_table),
                             `header
                             ( // A table column header where the column lists network interfaces:
                               _("Interface"),
                               // A table column header where the column shows whether or not
                               // local print queues are published by default
                               // via the network interface in the other table column:
                               _("Publish printers by default via this interface")
                             ),
                             interface_table_items
                             //[ `item( `id(0), "eth0", "no" ),
                             //  `item( `id(1), "eth1", "yes" )
                             //]
                           ),
                           `Left
                           ( `HBox
                             ( `PushButton
                               ( `id(`add_interface),
                                 // A PushButton label to add a network interface to the table which shows
                                 // the network interfaces to allow remote access to local print queues:
                                 _("&Add")
                               ),
                               `PushButton
                               ( `id(`edit_interface),
                                 // A PushButton label to change a network interface in the table which shows
                                 // the network interfaces to allow remote access to local print queues:
                                 _("&Edit")
                               ),
                               `PushButton
                               ( `id(`delete_interface),
                                 // A PushButton label to delete a network interface from the table which shows
                                 // the network interfaces to allow remote access to local print queues:
                                 _("&Delete")
                               )
                             )
                           ),
                           `VSpacing( 1 ),
                           `Left
                           ( `Label
                             ( `id(`ip_table_label),
                               // A caption for a table to allow remote access to local print queues
                               // for hosts and/or networks specified in the table below:
                               _("For hosts / networks specified below")
                             )
                           ),
                           `Table
                           ( `id(`ip_table),
                             `header
                             ( // A table column header where the column lists IP addresses:
                               _("IP address"),
                               // A table column header where the column shows whether or not
                               // local print queues are published by default
                               // via the IP address in the other table column:
                               _("Publish printers by default for this address")
                             ),
                             ip_table_items
                             //[ `item( `id(0), "192.168.100.1", "yes" ),
                             //  `item( `id(1), "192.168.100.2", "no" ),
                             //  `item( `id(2), "192.168.200.0/24", "no" ),
                             //  `item( `id(3), "192.168.300.0/255.255.255.0", "yes" )
                             //]
                           ),
                           `Left
                           ( `HBox
                             ( `PushButton
                               ( `id(`add_ip),
                                 // A PushButton label to add an IP address to the table which shows
                                 // the IP addresses to allow remote access to local print queues:
                                 _("A&dd")
                               ),
                               `PushButton
                               ( `id(`edit_ip),
                                 // A PushButton label to change an IP address in the table which shows
                                 // the IP addresses to allow remote access to local print queues:
                                 _("Ed&it")
                               ),
                               `PushButton
                               ( `id(`delete_ip),
                                 // A PushButton label to delete an IP address from the table which shows
                                 // the IP addresses to allow remote access to local print queues:
                                 _("De&lete")
                               )
                             )
                           )
                         )
                       ),
                       `VSpacing( 1 )
                     );

map< string, string > showInterfacePopup( string interface_name, boolean is_published )
{ map< string, string > interface_map = $[];
  UI::OpenDialog
  ( `VBox
    ( `CheckBox
      ( `id(`publish_check_box),
        // A CheckBox label to publish local print queues by default
        // via a partivular network interface which is shown below.
        _("&Publish printers by default via the network interface below."),
        is_published
      ),
      `ComboBox
      ( `id(`interfaces_combo_box),
        `opt( `editable ),
        // A header for a ComboBox which lists network interfaces:
        _("Available Network &Interfaces:"),
        available_interfaces
      ),
      `VSpacing(),
      `HBox
      ( `PushButton( `id(`ok), Label::OKButton() ),
        `PushButton( `id(`cancel), Label::CancelButton() )
      )
    )
  );
  if( "" != interface_name )
  { UI::ChangeWidget( `interfaces_combo_box, `Value, interface_name );
  }
  while( true )
  { any ret = UI::UserInput();
    if( `cancel == ret )
    { interface_map = nil;
      break;
    }
    if( `ok == ret )
    { interface_name = (string)UI::QueryWidget( `interfaces_combo_box, `Value );
      is_published = (boolean)UI::QueryWidget( `publish_check_box, `Value );
      interface_map["interface_name"] = interface_name;
      interface_map["is_published"] = is_published ? "yes" : "no";
      break;
    }
  }
  UI::CloseDialog();
  return interface_map;
}

map showIPPopup(string device, boolean publish){
 map result = $[];
         UI::OpenDialog( `VBox(
            `CheckBox(`id(`publish), _("&Publish printers by default via "), publish),
            // translators: input field label for list of configured IPs
            `InputField( `id(`device), _("Network &Address:"), device ),
            `VSpacing(),
            `HBox(
                `PushButton( `id(`ok), Label::OKButton() ),
                `PushButton( `id(`cancel), Label::CancelButton() )
             )
        ));
 if(device!="") UI::ChangeWidget(`device, `Value, device);
 while(true){
  any ret = UI::UserInput();
  if (ret==`cancel){
   result=nil;
   break;
  }
  if (ret==`ok){
   publish = (boolean)UI::QueryWidget(`publish, `Value);
   device = (string)UI::QueryWidget(`device, `Value);
   result["device"]=device;
   result["publish"]=publish ? "yes" : "no";
   break;
  }
 }
 UI::CloseDialog();
 return result;
}

boolean ApplySharingSettings()
{ sharing_has_changed = false;
  // Exit successfully by default and as fallback:
  return true;
}

void initSharing( string key )
{ y2milestone( "entering initSharing with key '%1'", key );
  share_printers_dialog_is_useless = false;
  sharing_has_changed = false;
  // Show a user information because the current implementation provides
  // only the dialog but does not read from the system or write to the system:
  Popup::AnyMessage( // Header of a Popup::AnyMessage because of a work-in-progress dialog:
                     _("Under Connstruction"),
                     // Body of a Popup::AnyMessage because of a work-in-progress dialog:
                     _("Currently only the dialog shows up but it does\nneither read from the system nor write to the system.\n")
                   );
  // Determine whether or not it is currently a real client-only config
  // (i.e. a ServerName != "localhost/127.0.0.1" in /etc/cups/client.conf)
  // and ignore when it fails (i.e. use the fallback value silently):
  Printerlib::DetermineClientOnly();
  if( Printerlib::client_only )
  { if( ! Popup::YesNoHeadline( // PopupYesNoHeadline headline
                                // where %1 will be replaced by the server name:
                                sformat( _("Disable remote CUPS server '%1'"), Printerlib::client_conf_server_name ),
                                // PopupYesNoHeadline body:
                                _("A remote CUPS server setting conflicts with sharing local printer configurations.")
                              )
      )
    { share_printers_dialog_is_useless = true;
      y2milestone( "share_printers_dialog_is_useless because user decided not to disable client-only CUPS server '%1'",
                   Printerlib::client_conf_server_name
                 );
    }
    else
    { // Remove the 'ServerName' entry in /etc/cups/client.conf:
      if( ! Printerlib::ExecuteBashCommand( Printerlib::yast_bin_dir + "cups_client_only none" ) )
      { Popup::ErrorDetails( // Popup::ErrorDetails message:
                             _("Failed to remove the 'ServerName' entry in /etc/cups/client.conf"),
                             Printerlib::result["stderr"]:"" + "\n" + Printerlib::result["stdout"]:""
                           );
        share_printers_dialog_is_useless = true;
        y2milestone( "share_printers_dialog_is_useless because it failed to disable client-only CUPS server '%1'",
                     Printerlib::client_conf_server_name
                   );
      }
    }
  }
  // Determine whether or not a local cupsd is accessible:
  if( ! Printerlib::GetAndSetCupsdStatus( "" ) )
  { // Printerlib::GetAndSetCupsdStatus already shows a confirmation popup:
    if( ! Printerlib::GetAndSetCupsdStatus( "start" ) )
    { share_printers_dialog_is_useless = true;
      y2milestone( "share_printers_dialog_is_useless because 'rccups start' failed." );
    }
  }
  // Note that the "Share Printers" dialog is not useless when there is no local queue.
  // For example the user may like to configure "Share Printers" (e.g. allow remote access)
  // before he set up the first local queue or he may like to delete all local queues
  // and then change the "Share Printers" stuff accordingly (e.g. deny remote access).
  if( share_printers_dialog_is_useless )
  { // The "Share Printers" dialog is (almost) useless.
    // Therefore disable all widgets except the deny_remote_access_radio_button
    // because the user may like to set deny remote access in /etc/cups/cupsd.conf
    // to be on the safe side before he changes a client-only config into a config
    // with a local running cupsd (e.g. before he set up the first local queue:
    // Also the basic buttons "Help", "Cancel", "OK" are enabled.
    UI::ChangeWidget( `allow_remote_access_radio_button, `Enabled, false );
    UI::ChangeWidget( `allow_local_network_access_check_box, `Enabled, false );
    UI::ChangeWidget( `publish_to_local_network_check_box, `Enabled, false );
    UI::ChangeWidget( `interface_table_label, `Enabled, false );
    UI::ChangeWidget( `interface_table, `Enabled, false );
    UI::ChangeWidget( `add_interface, `Enabled, false );
    UI::ChangeWidget( `edit_interface, `Enabled, false );
    UI::ChangeWidget( `delete_interface, `Enabled, false );
    UI::ChangeWidget( `ip_table_label, `Enabled, false );
    UI::ChangeWidget( `ip_table, `Enabled, false );
    UI::ChangeWidget( `add_ip, `Enabled, false );
    UI::ChangeWidget( `edit_ip, `Enabled, false );
    UI::ChangeWidget( `delete_ip, `Enabled, false );
  }
  // Regardless whether or not the "Share Printers" dialog is useless,
  // fill in the values of the current settings in the system:
  interface_table_items = [];
  ip_table_items = [];
  // Determine the 'Allow' values for the root location '<Location />' in /etc/cups/cupsd.conf:
  // By default there is only 'Allow 127.0.0.2' but this value is suppressed in the output
  // of 'modify_cupsd_conf Allow' so that the empty sting is the right fallback value here:
  list< string > allow_values = [ "" ];
  if( Printerlib::ExecuteBashCommand( Printerlib::yast_bin_dir + "modify_cupsd_conf Allow" ) )
  { // The command outputs a line where multiple Allow values are separated by space
    // but possible duplicate Allow values are not removed in the command output:
    allow_values = toset( splitstring( Printerlib::result["stdout"]:"", " " ) );
  }
  else
  { // Use fallback value when the command above failed:
    allow_values = [ "" ];
  }
  y2milestone( "Initial allow_values: %1", allow_values );
  // Determine the 'BrowseAddress' values in /etc/cups/cupsd.conf:
  // By default there is no BrowseAddress value so that the empty sting is the right fallback:
  list< string > browse_address_values = [ "" ];
  if( Printerlib::ExecuteBashCommand( Printerlib::yast_bin_dir + "modify_cupsd_conf BrowseAddress" ) )
  { // The command outputs a line where multiple BrowseAddress values are separated by space
    // but possible duplicate BrowseAddress values are not removed in the command output:
    browse_address_values = toset( splitstring( Printerlib::result["stdout"]:"", " " ) );
  }
  else
  { // Use fallback value when the command above failed:
    browse_address_values = [ "" ];
  }
  y2milestone( "Initial browse_address_values: %1", browse_address_values );
  // Split the allow_values list together with the browse_address_values list
  // into the different values for the different widgets in the dialog.
  // By default no remote access is allowed (see the defaults in widgetSharing)
  // but if there is at least one none-empty allow_value, remote access should be allowed:
  foreach( string allow_value,
           allow_values,
           { if( "" != allow_value )
             { UI::ChangeWidget( `deny_remote_access_radio_button, `Value, false );
               UI::ChangeWidget( `allow_remote_access_radio_button, `Value, true );
             }
             if( "@LOCAL" == allow_value )
             { UI::ChangeWidget( `allow_local_network_access_check_box, `Value, true );
               // Check if this value appears also in the browse_address_values:
               if( contains( browse_address_values, allow_value ) )
               { UI::ChangeWidget( `publish_to_local_network_check_box, `Value, true );
               }
             }
             if( issubstring( allow_value, "@IF" ) )
             { // The allow_value has the form '@IF(interface-name)' e.g. '@IF(eth1)'.
               // Check if this value appears also in the browse_address_values:
               string publish_via_this_interface = "no";
               if( contains( browse_address_values, allow_value ) )
               { publish_via_this_interface = "yes";
               }
               // Extract only the interface-name from the allow_value:
               integer start = findfirstof( allow_value, "(" );
               integer end = findfirstof( allow_value, ")" );
               if( ( nil != start ) && ( nil != end ) && ( end - start - 1 > 0 ) )
               { string interface_name = substring( allow_value, start + 1, end - start - 1 );
                 interface_table_items = add( interface_table_items, `item( `id( size( interface_table_items ) ),
                                                                            interface_name,
                                                                            publish_via_this_interface
                                                                          )
                                            );
               }
             }
           }
         );
  y2milestone( "Initial interface_table_items: %1", interface_table_items );
  UI::ChangeWidget( `interface_table, `Items, interface_table_items );
  UI::ChangeWidget( `interface_table, `CurrentItem, -1 );
  // Determine the currently available network interfaces in the system.
  // Omit the loopback interface.
  available_interfaces = [];
  if( Printerlib::ExecuteBashCommand( "ip -family inet -oneline link show | grep -v -i loopback | cut -s -d ':' -f 2 | tr -s '[:space:]' ' '" ) )
  { // The command outputs a line where multiple network interfaces are separated by space.
    // Remove empty or effectively empty entries (otherwise it would be something like ["", "eth0", "eth1"]):
    available_interfaces = filter( string interface_name,
                                   toset( splitstring( Printerlib::result["stdout"]:"", " " ) ),
                                   { return( "" !=  filterchars( interface_name, Printer::alnum_chars ) );
                                   }
                                 );
  }
  else
  { // Use fallback value when the command above failed:
    available_interfaces = [];
  }
  y2milestone( "available_interfaces: %1", available_interfaces );
  y2milestone( "leaving initSharing" );
}

symbol handleSharing( string key, map event )
{ if (event["EventReason"]:""=="Activated")
  { y2milestone( "button pressed %1", event );
    switch( event["WidgetID"]:`nil )
    { integer current_item = -1;
      map ret = nil;
      map< string, string > interface_map = nil;
      case `add_interface :
           interface_map = showInterfacePopup( "", false );
           if( interface_map != nil )
           { interface_table_items = (list<term>)UI::QueryWidget( `interface_table, `Items );
             interface_table_items = add( interface_table_items,
                                          `item( `id(size(interface_table_items)),
                                                 interface_map["interface_name"]:"",
                                                 interface_map["is_published"]:""
                                               )
                                        );
             UI::ChangeWidget( `interface_table, `Items, interface_table_items );
             UI::ChangeWidget( `interface_table, `CurrentItem, size(interface_table_items) - 1 );
           }
           break;
      case `edit_interface :
           current_item = (integer)UI::QueryWidget( `interface_table, `CurrentItem );
           term interface_item = (term)UI::QueryWidget( `interface_table, `Item( current_item ) );
           interface_map = showInterfacePopup( (string)interface_item[1]:"",
                                               (interface_item[2]:"no"=="yes")
                                             );
           if( interface_map != nil)
           { interface_table_items = [];
             foreach( term interface_table_item,
                      (list<term>)UI::QueryWidget( `interface_table, `Items),
                      { if( current_item != interface_table_item[0,0]:-1 )
                        { interface_table_items = add( interface_table_items,
                                                       `item( `id(size(interface_table_items)),
                                                              interface_table_item[1]:"",
                                                              interface_table_item[2]:""
                                                            )
                                                     );
                        }
                        else
                        { y2milestone( "Changing interface_table_item %1", interface_table_item );
                          interface_table_items = add( interface_table_items,
                                                       `item( `id(size(interface_table_items)),
                                                              interface_map["interface_name"]:"",
                                                              interface_map["is_published"]:""
                                                            )
                                                     );
                        }
                      }
                    );
             UI::ChangeWidget( `interface_table, `Items, interface_table_items );
             UI::ChangeWidget( `interface_table, `CurrentItem, current_item );
           }
           break;
      case `delete_interface :
           current_item = (integer)UI::QueryWidget( `interface_table, `CurrentItem );
           if( current_item != nil && current_item > -1 )
           { interface_table_items = [];
             foreach( term interface_table_item,
                      (list<term>)UI::QueryWidget(`interface_table, `Items),
                      { if( current_item != interface_table_item[0,0]:-1 )
                        { interface_table_items = add( interface_table_items,
                                                      `item( `id(size(interface_table_items)),
                                                              interface_table_item[1]:"",
                                                              interface_table_item[2]:""
                                                            )
                                                     );
                        }
                        else
                        { y2milestone("Deleting interface_table_item %1", interface_table_item );
                        }
                      }
                    );
             UI::ChangeWidget( `interface_table, `Items, interface_table_items);
           }
           else
           { y2error("Unproper index for current interface table item: %1", current_item);
           }
           break;
   case `add_ip   :
                        ret = showIPPopup("", false);
                        if (ret!=nil){
                         list items = (list)UI::QueryWidget(`ip_table, `Items);
                         items=add(items, `item(`id(size(items)), ret["device"]:"", ret["publish"]:""));
                         UI::ChangeWidget(`ip_table, `Items, items);
                         UI::ChangeWidget(`ip_table, `CurrentItem, current_item);
                        }
                        break;

   case `edit_ip          :
                        current_item = (integer)UI::QueryWidget(`ip_table, `CurrentItem);
                        term this2 = (term)UI::QueryWidget(`ip_table, `Item(current_item));
                        ret = showIPPopup((string)this2[1]:"", (this2[2]:"no"=="yes"));
                        if (ret!=nil){
                         list items = [];
                         foreach(term oneItem, (list<term>)UI::QueryWidget(`ip_table, `Items), {
                          if (current_item != oneItem[0, 0]:-1){
                           items = add(items, `item(`id(size(items)), oneItem[1]:"", oneItem[2]:""));
                          } else {
                                y2milestone("Changing item %1", oneItem);
                                items = add(items, `item(`id(size(items)), ret["device"]:"", ret["publish"]:""));
                          }
                         });
                        UI::ChangeWidget(`ip_table, `Items, items);
                        UI::ChangeWidget(`ip_table, `CurrentItem, current_item);
                        }
                        break;
   case `delete_ip :
                        current_item = (integer)UI::QueryWidget(`ip_table, `CurrentItem);
                        if (current_item!=nil && current_item>-1){
                         list items = [];
                         foreach(term oneItem, (list<term>)UI::QueryWidget(`ip_table, `Items), {
                          if (current_item != oneItem[0, 0]:-1){
                           items = add(items, `item(`id(size(items)), oneItem[1]:"", oneItem[2]:""));
                          } else y2milestone("Deleting item %1", oneItem);

                         });
                        UI::ChangeWidget(`ip_table, `Items, items);
                        } else y2error("Unproper index for current item: %1", current_item);
                        break;
  }
 }
 if( ! share_printers_dialog_is_useless )
 { boolean share = (UI::QueryWidget(`deny_or_allow_remote_access, `CurrentButton)==`allow_remote_access_radio_button);
   UI::ChangeWidget(`allow_local_network_access_check_box, `Enabled, share);
   UI::ChangeWidget(`publish_to_local_network_check_box, `Enabled, share);
   UI::ChangeWidget(`interface_table, `Enabled, share);
   UI::ChangeWidget(`add_interface, `Enabled, share);
   UI::ChangeWidget(`edit_interface, `Enabled, share);
   UI::ChangeWidget(`delete_interface, `Enabled, share);
   UI::ChangeWidget(`ip_table, `Enabled, share);
   UI::ChangeWidget(`add_ip, `Enabled, share);
   UI::ChangeWidget(`edit_ip, `Enabled, share);
   UI::ChangeWidget(`delete_ip, `Enabled, share);
   if(share)
   { boolean interface_buttons=true;
     boolean ip_buttons=true;
     if (size((list)UI::QueryWidget(`interface_table, `Items))==0) interface_buttons=false;
     UI::ChangeWidget(`edit_interface, `Enabled, interface_buttons);
     UI::ChangeWidget(`delete_interface, `Enabled, interface_buttons);
     if (size((list)UI::QueryWidget(`ip_table, `Items))==0) ip_buttons=false;
     UI::ChangeWidget(`edit_ip, `Enabled, ip_buttons);
     UI::ChangeWidget(`delete_ip, `Enabled, ip_buttons);
   }
 }
 return nil;
}

void storeSharing( string key, map event )
{ y2milestone( "entering storeSharing with key '%1'\nand event '%2'", key, event );
  if( ! ApplySharingSettings() )
  { Popup::Error( // Popup::Error message:
                      _("Failed to apply the settings to the system.")
                    );
  }
  if( ! sharing_has_changed )
  { y2milestone( "Nothing changed in 'Share Printers' dialog." );
    Popup::ShowFeedback( // No title for such a simple feedback message:
                         "",
                         // Message of a Popup::ShowFeedback when nothing was changed:
                         _("Nothing changed.")
                       );
    sleep( 1000 );
    Popup::ClearFeedback();
  }
  y2milestone( "leaving storeSharing" );
  return nil;
}

/* EOF */
}
