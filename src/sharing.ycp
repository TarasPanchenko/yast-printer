/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:        include/printer/sharing.ycp
 * Package:     Configuration of printer
 * Summary:     Print queue sharing and publishing dialog definition
 * Authors:     Johannes Meixner <jsmeix@suse.de>
 *
 * $Id: dialogs.ycp 27914 2006-02-13 14:32:08Z locilka $
 */

{

textdomain "printer";

import "Label";
import "Wizard";
import "Printer";
import "Printerlib";
import "Popup";

include "printer/helps.ycp";

boolean share_printers_dialog_is_useless = false;
list< term > interface_table_items = [];
list< term > ip_table_items = [];
list< string > available_interfaces = [];
boolean sharing_has_changed = false;
boolean initial_deny_remote_access = true;
boolean initial_allow_remote_access = false;
boolean initial_allow_local_network_access = false;
boolean initial_publish_to_local_network = false;
list< term > initial_interface_table_items = [];

term widgetSharing = `VBox
                     ( `VSpacing( 1 ),
                       `RadioButtonGroup
                       ( `id(`deny_or_allow_remote_access),
                         `VBox
                         ( `Left
                           ( `RadioButton
                             ( `id(`deny_remote_access_radio_button),
                               `opt(`notify, `immediate),
                               // A RadioButton label to deny remote access to local print queues:
                               _("&Deny remote access"),
                               initial_deny_remote_access
                             )
                           ),
                           `VSpacing( 2 ),
                           `Left
                           ( `RadioButton
                             ( `id(`allow_remote_access_radio_button),
                               `opt(`notify, `immediate),
                               // A RadioButton label to allow remote access to local print queues:
                               _("&Allow remote access"),
                               initial_allow_remote_access
                             )
                           )
                         )
                       ),
                       `VSpacing( 1 ),
                       `HBox
                       ( `HSpacing( 3 ),
                         `VBox
                         ( `Left
                           ( `CheckBox
                             ( `id(`allow_local_network_access_check_box),
                               `opt(`notify),
                               // A CheckBox label to allow remote access to local print queues
                               // for computers within the local network:
                               _("For computers within the &local network"),
                               initial_allow_local_network_access
                             )
                           ),
                           `Left
                           ( `HBox
                             ( `HSpacing( 2 ),
                               `CheckBox
                               ( `id(`publish_to_local_network_check_box),
                                 `opt(`notify),
                                 // A CheckBox label to publish local print queues by default within the local network:
                                 _("&Publish printers by default within the local network"),
                                 initial_publish_to_local_network
                               )
                             )
                           ),
                           `VSpacing( 1 ),
                           `Left
                           ( `Label
                             ( `id(`interface_table_label),
                               // A caption for a table to allow remote access to local print queues
                               // via network interfaces specified in the table below:
                               _("Via network interfaces specified below")
                             )
                           ),
                           `Table
                           ( `id(`interface_table),
                             `header
                             ( // A table column header where the column lists network interfaces:
                               _("Interface"),
                               // A table column header where the column shows whether or not
                               // local print queues are published by default
                               // via the network interface in the other table column:
                               _("Publish printers by default via this interface")
                             ),
                             initial_interface_table_items
                           ),
                           `Left
                           ( `HBox
                             ( `PushButton
                               ( `id(`add_interface),
                                 // A PushButton label to add a network interface to the table which shows
                                 // the network interfaces to allow remote access to local print queues:
                                 _("&Add")
                               ),
                               `PushButton
                               ( `id(`edit_interface),
                                 // A PushButton label to change a network interface in the table which shows
                                 // the network interfaces to allow remote access to local print queues:
                                 _("&Edit")
                               ),
                               `PushButton
                               ( `id(`delete_interface),
                                 // A PushButton label to delete a network interface from the table which shows
                                 // the network interfaces to allow remote access to local print queues:
                                 _("&Delete")
                               )
                             )
                           ),
                           `VSpacing( 1 ),

                           // Have the IP table disabled until its functionality is implemented:
                           `Frame
                           ( "This functionality is not yet implemented:",
                           `VBox
                           (

                           `Left
                           ( `Label
                             ( `id(`ip_table_label),
                               // A caption for a table to allow remote access to local print queues
                               // for hosts and/or networks specified in the table below:
                               _("For hosts / networks specified below")
                             )
                           ),
                           `Table
                           ( `id(`ip_table),
                             `header
                             ( // A table column header where the column lists IP addresses:
                               _("IP address"),
                               // A table column header where the column shows whether or not
                               // local print queues are published by default
                               // via the IP address in the other table column:
                               _("Publish printers by default for this address")
                             ),
                             ip_table_items
                           ),
                           `Left
                           ( `HBox
                             ( `PushButton
                               ( `id(`add_ip),
                                 // A PushButton label to add an IP address to the table which shows
                                 // the IP addresses to allow remote access to local print queues:
                                 _("A&dd")
                               ),
                               `PushButton
                               ( `id(`edit_ip),
                                 // A PushButton label to change an IP address in the table which shows
                                 // the IP addresses to allow remote access to local print queues:
                                 _("Ed&it")
                               ),
                               `PushButton
                               ( `id(`delete_ip),
                                 // A PushButton label to delete an IP address from the table which shows
                                 // the IP addresses to allow remote access to local print queues:
                                 _("De&lete")
                               )
                             )
                           )

                           )
                           )

                         )
                       ),
                       `VSpacing( 1 )
                     );

map< string, string > showInterfacePopup( string interface_name, boolean is_published )
{ map< string, string > interface_map = $[];
  UI::OpenDialog
  ( `VBox
    ( `CheckBox
      ( `id(`publish_check_box),
        // A CheckBox label to publish local print queues by default
        // via a partivular network interface which is shown below.
        _("&Publish printers by default via the network interface below."),
        is_published
      ),
      `ComboBox
      ( `id(`interfaces_combo_box),
        `opt( `editable ),
        // A header for a ComboBox which lists network interfaces:
        _("Available Network &Interfaces:"),
        available_interfaces
      ),
      `VSpacing(),
      `HBox
      ( `PushButton( `id(`ok), Label::OKButton() ),
        `PushButton( `id(`cancel), Label::CancelButton() )
      )
    )
  );
  if( "" != interface_name )
  { UI::ChangeWidget( `interfaces_combo_box, `Value, interface_name );
  }
  while( true )
  { any ret = UI::UserInput();
    if( `cancel == ret )
    { interface_map = nil;
      break;
    }
    if( `ok == ret )
    { interface_name = (string)UI::QueryWidget( `interfaces_combo_box, `Value );
      is_published = (boolean)UI::QueryWidget( `publish_check_box, `Value );
      interface_map["interface_name"] = interface_name;
      interface_map["is_published"] = is_published ? "yes" : "no";
      break;
    }
  }
  UI::CloseDialog();
  return interface_map;
}

map showIPPopup(string device, boolean publish){
 map result = $[];
         UI::OpenDialog( `VBox(
            `CheckBox(`id(`publish), _("&Publish printers by default via "), publish),
            // translators: input field label for list of configured IPs
            `InputField( `id(`device), _("Network &Address:"), device ),
            `VSpacing(),
            `HBox(
                `PushButton( `id(`ok), Label::OKButton() ),
                `PushButton( `id(`cancel), Label::CancelButton() )
             )
        ));
 if(device!="") UI::ChangeWidget(`device, `Value, device);
 while(true){
  any ret = UI::UserInput();
  if (ret==`cancel){
   result=nil;
   break;
  }
  if (ret==`ok){
   publish = (boolean)UI::QueryWidget(`publish, `Value);
   device = (string)UI::QueryWidget(`device, `Value);
   result["device"]=device;
   result["publish"]=publish ? "yes" : "no";
   break;
  }
 }
 UI::CloseDialog();
 return result;
}

boolean ApplySharingSettings()
{ sharing_has_changed = false;
  // Get the actual settings and values from the dialog.
  // It does not work well to query the RadioButtonGroup with something like
  // UI::QueryWidget(`deny_or_allow_remote_access,`CurrentButton))
  // Reason: At least with openSUSE 11.0 and Qt
  // it is possible to un-check all buttons in a RadioButtonGroup
  // by clicking on the currently checked button which un-checks it
  // so that there might be no CurrentButton which leads to unexpected results.
  // Therefore the individual buttons are tested directly to be on the safe side:
  boolean deny_remote_access = (boolean)UI::QueryWidget( `deny_remote_access_radio_button, `Value );
  y2milestone( "deny_remote_access_radio_button value: '%1'", deny_remote_access );
  boolean allow_remote_access = (boolean)UI::QueryWidget( `allow_remote_access_radio_button, `Value );
  y2milestone( "allow_remote_access_radio_button value: '%1'", allow_remote_access );
  boolean allow_local_network_access = (boolean)UI::QueryWidget( `allow_local_network_access_check_box, `Value );
  y2milestone( "allow_local_network_access_check_box value: '%1'", allow_local_network_access );
  boolean publish_to_local_network = (boolean)UI::QueryWidget( `publish_to_local_network_check_box, `Value );
  y2milestone( "publish_to_local_network_check_box value: '%1'", publish_to_local_network );
  interface_table_items = (list<term>)UI::QueryWidget( `interface_table, `Items );
  y2milestone( "interface_table_items: %1", interface_table_items );
  string allow_values = "";
  string browse_address_values = "";
  foreach( term interface_table_item,
           interface_table_items,
           { string interface_name = interface_table_item[1]:"";
             string is_published = interface_table_item[2]:"";
             if( "" != interface_name )
             { allow_values = "@IF(" + interface_name + ") " + allow_values;
               // Add the inferface nameto browse_address_values
               // only if remote access is allowed for this interface:
               if( "yes" == is_published )
               { browse_address_values = "@IF(" + interface_name + ") " + browse_address_values ;
               }
             }
           }
         );
  if( allow_local_network_access )
  { allow_values = "@LOCAL " + allow_values;
    // Add "@LOCAL" to browse_address_values
    // only if remote access is allowed for "@LOCAL":
    if( publish_to_local_network )
    { browse_address_values = "@LOCAL " + browse_address_values;
    }
  }
  y2milestone( "allow_values: %1", allow_values );
  y2milestone( "browse_address_values: %1", browse_address_values );
  // Any kind of deny_remote_access:
  // Ignore if other settings may have been changed too
  // because whatever Allow and BrowseAddress stuff is meaningless
  // if remote access is denied at all:
  // When both the deny_remote_access_radio_button and the allow_remote_access_radio_button
  // are un-checked, assume the user wants deny_remote_access (via '! allow_remote_access')
  // because this is the safe setting (even when allow_values is not empty):
  if( deny_remote_access
      || ! allow_remote_access
      || "" == allow_values
    )
  { if( initial_deny_remote_access )
    { // Nothing has changed:
      return true;
    }
    sharing_has_changed = true;
    // It leads to inconsistencies if only Only set 'Listen localhost' would be set
    // but Allow and BrowseAddress enties would be kept because when there are
    // BrowseAddress enties, it must listen on matching remote interfaces
    // and then also matching Allow enties should be there.
    if( ! Printerlib::ExecuteBashCommand( Printerlib::yast_bin_dir + "modify_cupsd_conf Listen localhost" ) )
    { Popup::ErrorDetails( // Popup::ErrorDetails message.
                           // Do not change or translate "Listen localhost", it is a system settings name.
                           _("Failed to set only 'Listen localhost' in /etc/cups/cupsd.conf"),
                           Printerlib::result["stderr"]:""
                         );
      return false;
    }
    if( ! Printerlib::ExecuteBashCommand( Printerlib::yast_bin_dir + "modify_cupsd_conf Allow none" ) )
    { Popup::ErrorDetails( // Popup::ErrorDetails message.
                           // Do not change or translate "Allow", it is a system settings name.
                           _("Failed to remove 'Allow' entries from /etc/cups/cupsd.conf"),
                           Printerlib::result["stderr"]:""
                         );
      return false;
    }
    // Do not change the global "Browsing On/Off" entry in cupsd.conf
    // because "Browsing Off" disables also receiving
    // of remote queue information from remote CUPS servers
    // which might be needed by the "Print Via Network" dialog.
    // Instead remove only the "BrowseAddress" entries in cupsd.conf:
    if( ! Printerlib::ExecuteBashCommand( Printerlib::yast_bin_dir + "modify_cupsd_conf BrowseAddress none" ) )
    { Popup::ErrorDetails( // Popup::ErrorDetails message.
                           // Do not change or translate "BrowseAddress", it is a system settings name.
                           _("Failed to remove 'BrowseAddress' entries from /etc/cups/cupsd.conf"),
                           Printerlib::result["stderr"]:""
                         );
      return false;
    }
    // If a local cupsd is accessible, restart it,
    // otherwise do nothing (i.e. do not start it now):
    if( Printerlib::GetAndSetCupsdStatus( "" ) )
    { if( ! Printerlib::GetAndSetCupsdStatus( "restart" ) )
      { return false;
      }
    }
    return true;
  }
  // Any kind of allow_remote_access:
  // Check if there are real changes:
  if( allow_local_network_access != initial_allow_local_network_access
      || publish_to_local_network != initial_publish_to_local_network
    )
  { sharing_has_changed = true;
  }
  // Check if there are real changes in the table of interfaces.
  // Ignore ordering and ignore duplicates (toset)
  // but do not ignore case because network interface names are case sensitive:
  list< string > initial_interface_table_entries = [];
  foreach( term initial_interface_table_item,
           initial_interface_table_items,
           { initial_interface_table_entries = add( initial_interface_table_entries,
                                                    initial_interface_table_item[1]:""
                                                    + initial_interface_table_item[2]:""
                                                  );
           }
         );
  initial_interface_table_entries = toset( initial_interface_table_entries );
  list< string > interface_table_entries = [];
  foreach( term interface_table_item,
           interface_table_items,
           { interface_table_entries = add( interface_table_entries,
                                            interface_table_item[1]:""
                                            + interface_table_item[2]:""
                                          );
           }
         );
  interface_table_entries = toset( interface_table_entries );
  if( mergestring( interface_table_entries, "" ) != mergestring( initial_interface_table_entries, "" ) )
  { sharing_has_changed = true;
  }
  if( ! sharing_has_changed )
  { // Nothing has changed:
    return true;
  }
  // When allow_values is empty, it is a deny_remote_access case, see above.
  // Therefore allow_values is non-empty here:
  if( ! Printerlib::ExecuteBashCommand( Printerlib::yast_bin_dir
                                        + "modify_cupsd_conf Allow '"
                                        + allow_values
                                        + "'"
                                       )
    )
  { Popup::ErrorDetails( sformat( // Popup::ErrorDetails message
                                  // where %1 will be replaced by one or more system settings values.
                                  // Do not change or translate "Allow", it is a system settings name.
                                  _("Failed to set 'Allow' entries '%1' in /etc/cups/cupsd.conf"),
                                  allow_values
                                  ),
                         Printerlib::result["stderr"]:""
                       );
    return false;
  }
  if( "" != browse_address_values )
  { if( ! Printerlib::ExecuteBashCommand( Printerlib::yast_bin_dir
                                          + "modify_cupsd_conf BrowseAddress '"
                                          + browse_address_values
                                          + "'"
                                        )
      )
    { Popup::ErrorDetails( sformat( // Popup::ErrorDetails message
                                    // where %1 will be replaced by one or more system settings values.
                                    // Do not change or translate "BrowseAddress", it is a system settings name.
                                    _("Failed to set 'BrowseAddress' entries '%1' in /etc/cups/cupsd.conf"),
                                    browse_address_values
                                  ),
                           Printerlib::result["stderr"]:""
                         );
      return false;
    }
    // Having "BrowseAddress" entries requires "Browsing On",
    // otherwise browsing information would not be sent at all:
    if( ! Printerlib::ExecuteBashCommand( Printerlib::yast_bin_dir + "modify_cupsd_conf Browsing On" ) )
    { Popup::ErrorDetails( // Popup::ErrorDetails message:
                           _("Failed to set 'Browsing On' in /etc/cups/cupsd.conf"),
                           Printerlib::result["stderr"]:""
                         );
      return false;
    }
  }
  // Only if all the above was successfully set, Listen is set too:
  // Currently 'Listen *:631' is simply set for any kind of remote access
  // because the Listen directive supports only network addresses as value.
  // Neither 'Listen @LOCAL' nor 'Listen @IF(name)' is supported.
  // TODO: Determine the matching network address for @LOCAL and @IF(name)
  //       and use the matching network address for the Listen directive.
  if( ! Printerlib::ExecuteBashCommand( Printerlib::yast_bin_dir + "modify_cupsd_conf Listen all" ) )
  { Popup::ErrorDetails( // Popup::ErrorDetails message.
                         // Do not change or translate "Listen *:631", it is a system settings name.
                         _("Failed to set 'Listen *:631' in /etc/cups/cupsd.conf"),
                         Printerlib::result["stderr"]:""
                       );
    return false;
  }
  // If a local cupsd is accessible, restart it,
  // otherwise do nothing (i.e. do not start it now):
  if( Printerlib::GetAndSetCupsdStatus( "" ) )
  { if( ! Printerlib::GetAndSetCupsdStatus( "restart" ) )
    { return false;
    }
  }
  // Exit successfully by default and as fallback:
  return true;
}

void initSharing( string key )
{ y2milestone( "entering initSharing with key '%1'", key );
  share_printers_dialog_is_useless = false;
  sharing_has_changed = false;
  // Determine whether or not it is currently a real client-only config
  // (i.e. a ServerName != "localhost/127.0.0.1" in /etc/cups/client.conf)
  // and ignore when it fails (i.e. use the fallback value silently):
  Printerlib::DetermineClientOnly();
  if( Printerlib::client_only )
  { if( ! Popup::YesNoHeadline( sformat( // PopupYesNoHeadline headline
                                         // where %1 will be replaced by the server name:
                                         _("Disable remote CUPS server '%1'"),
                                         Printerlib::client_conf_server_name
                                       ),
                                // PopupYesNoHeadline body:
                                _("A remote CUPS server setting conflicts with sharing local printer configurations.")
                              )
      )
    { share_printers_dialog_is_useless = true;
      y2milestone( "share_printers_dialog_is_useless because user decided not to disable client-only CUPS server '%1'",
                   Printerlib::client_conf_server_name
                 );
    }
    else
    { // Remove the 'ServerName' entry in /etc/cups/client.conf:
      if( ! Printerlib::ExecuteBashCommand( Printerlib::yast_bin_dir + "cups_client_only none" ) )
      { Popup::ErrorDetails( // Popup::ErrorDetails message:
                             _("Failed to remove the 'ServerName' entry in /etc/cups/client.conf"),
                             Printerlib::result["stderr"]:"" + "\n" + Printerlib::result["stdout"]:""
                           );
        share_printers_dialog_is_useless = true;
        y2milestone( "share_printers_dialog_is_useless because it failed to disable client-only CUPS server '%1'",
                     Printerlib::client_conf_server_name
                   );
      }
    }
  }
  // Determine whether or not a local cupsd is accessible:
  if( ! Printerlib::GetAndSetCupsdStatus( "" ) )
  { // Printerlib::GetAndSetCupsdStatus already shows a confirmation popup:
    if( ! Printerlib::GetAndSetCupsdStatus( "start" ) )
    { share_printers_dialog_is_useless = true;
      y2milestone( "share_printers_dialog_is_useless because 'rccups start' failed." );
    }
  }
  // Note that the "Share Printers" dialog is not useless when there is no local queue.
  // For example the user may like to configure "Share Printers" (e.g. allow remote access)
  // before he set up the first local queue or he may like to delete all local queues
  // and then change the "Share Printers" stuff accordingly (e.g. deny remote access).
  if( share_printers_dialog_is_useless )
  { // The "Share Printers" dialog is (almost) useless.
    // Therefore disable all widgets except the deny_remote_access_radio_button
    // because the user may like to set deny remote access in /etc/cups/cupsd.conf
    // to be on the safe side before he changes a client-only config into a config
    // with a local running cupsd (e.g. before he set up the first local queue:
    // Also the basic buttons "Help", "Cancel", "OK" are enabled.
    UI::ChangeWidget( `allow_remote_access_radio_button, `Enabled, false );
    UI::ChangeWidget( `allow_local_network_access_check_box, `Enabled, false );
    UI::ChangeWidget( `publish_to_local_network_check_box, `Enabled, false );
    UI::ChangeWidget( `interface_table_label, `Enabled, false );
    UI::ChangeWidget( `interface_table, `Enabled, false );
    UI::ChangeWidget( `add_interface, `Enabled, false );
    UI::ChangeWidget( `edit_interface, `Enabled, false );
    UI::ChangeWidget( `delete_interface, `Enabled, false );
    UI::ChangeWidget( `ip_table_label, `Enabled, false );
    UI::ChangeWidget( `ip_table, `Enabled, false );
    UI::ChangeWidget( `add_ip, `Enabled, false );
    UI::ChangeWidget( `edit_ip, `Enabled, false );
    UI::ChangeWidget( `delete_ip, `Enabled, false );
  }
  // Regardless whether or not the "Share Printers" dialog is useless,
  // fill in the values of the current settings in the system:
  interface_table_items = [];
  ip_table_items = [];
  // Determine the 'Listen' values in /etc/cups/cupsd.conf:
  // By default there is 'Listen localhost:631' and 'Listen /var/run/cups/cups.sock'.
  // 'Listen localhost' is mandatory (i.e. it is a broken config when it is missing).
  // '/var/run/cups/cups.sock' is only an optional default (i.e. not really of interest).
  // Therefore "modify_cupsd_conf Listen" reports 'localhost' but ignores '/var/run/cups/cups.sock'
  // so that ["localhost"] is the right fallback value here:
  list< string > listen_values = [ "" ];
  if( Printerlib::ExecuteBashCommand( Printerlib::yast_bin_dir + "modify_cupsd_conf Listen" ) )
  { // The command outputs a line where multiple Listen values are separated by space
    // but possible duplicate Listen values are not removed in the command output:
    listen_values = toset( splitstring( Printerlib::result["stdout"]:"", " " ) );
  }
  else
  { // Use fallback value when the command above failed:
    listen_values = [ "localhost" ];
  }
  y2milestone( "Initial listen_values: %1", listen_values );
  // Determine if it listens at least to "localhost" and/or only to "localhost":
  boolean listen_local = false;
  boolean listen_remote = false;
  foreach( string listen_value,
           listen_values,
           { if( "" != listen_value )
             { if( "localhost" == listen_value )
               { listen_local = true;
               }
               else
               { listen_remote = true;
               }
             }
           }
         );
  if( ! listen_local )
  { // 'Listen localhost' is mandatory (i.e. it is a broken config when it is missing).
    // Try to do a simple fix for the broken config but ignore possible failures.
    // Set only 'Listen localhost:631' in /etc/cups/cupsd.conf which means
    // that all possibly existing non-'localhost' Listen entries are removed.
    // but this should be no big problem because appropriate Listen values
    // (depending on the settings in this dialog) would be added when this dialog finishes.
    // Only while this dialog is open, the non-'localhost' Listen entries are removed
    // which means that there is no remote access while this dialog is open
    // which is no big issue for a broken config without any local access ;-)
    Printerlib::ExecuteBashCommand( Printerlib::yast_bin_dir + "modify_cupsd_conf Listen localhost" );
    Printerlib::GetAndSetCupsdStatus( "restart" );
  }
  // Determine the 'Allow' values for the root location '<Location />' in /etc/cups/cupsd.conf:
  // By default there is only 'Allow 127.0.0.2' but this value is suppressed in the output
  // of 'modify_cupsd_conf Allow' so that the empty sting is the right fallback value here:
  list< string > allow_values = [ "" ];
  if( Printerlib::ExecuteBashCommand( Printerlib::yast_bin_dir + "modify_cupsd_conf Allow" ) )
  { // The command outputs a line where multiple Allow values are separated by space
    // but possible duplicate Allow values are not removed in the command output:
    allow_values = toset( splitstring( Printerlib::result["stdout"]:"", " " ) );
  }
  else
  { // Use fallback value when the command above failed:
    allow_values = [ "" ];
  }
  y2milestone( "Initial allow_values: %1", allow_values );
  // Determine the 'BrowseAddress' values in /etc/cups/cupsd.conf:
  // By default there is no BrowseAddress value so that the empty sting is the right fallback:
  list< string > browse_address_values = [ "" ];
  if( Printerlib::ExecuteBashCommand( Printerlib::yast_bin_dir + "modify_cupsd_conf BrowseAddress" ) )
  { // The command outputs a line where multiple BrowseAddress values are separated by space
    // but possible duplicate BrowseAddress values are not removed in the command output:
    browse_address_values = toset( splitstring( Printerlib::result["stdout"]:"", " " ) );
  }
  else
  { // Use fallback value when the command above failed:
    browse_address_values = [ "" ];
  }
  y2milestone( "Initial browse_address_values: %1", browse_address_values );
  // Reset the different values for the different widgets in the dialog to defaults:
  initial_deny_remote_access = true;
  UI::ChangeWidget( `deny_remote_access_radio_button, `Value, true );
  initial_allow_remote_access = false;
  UI::ChangeWidget( `allow_remote_access_radio_button, `Value, false );
  initial_allow_local_network_access = false;
  UI::ChangeWidget( `allow_local_network_access_check_box, `Value, false );
  initial_publish_to_local_network = false;
  UI::ChangeWidget( `publish_to_local_network_check_box, `Value, false );
  initial_interface_table_items = [];
  // Split the allow_values list together with the browse_address_values list
  // into the different values for the different widgets in the dialog.
  // By default no remote access is allowed (see the defaults in widgetSharing)
  // but if there is at least one none-empty allow_value, remote access should be allowed
  // except when there is no remote Listen entry:
  foreach( string allow_value,
           allow_values,
           { if( "" != allow_value && listen_remote )
             { UI::ChangeWidget( `deny_remote_access_radio_button, `Value, false );
               initial_deny_remote_access = false;
               UI::ChangeWidget( `allow_remote_access_radio_button, `Value, true );
               initial_allow_remote_access = true;
             }
             if( "@LOCAL" == allow_value )
             { UI::ChangeWidget( `allow_local_network_access_check_box, `Value, true );
               initial_allow_local_network_access = true;
               // Check if this value appears also in the browse_address_values:
               if( contains( browse_address_values, allow_value ) )
               { UI::ChangeWidget( `publish_to_local_network_check_box, `Value, true );
                 initial_publish_to_local_network = true;
               }
             }
             if( issubstring( allow_value, "@IF" ) )
             { // The allow_value has the form '@IF(interface-name)' e.g. '@IF(eth1)'.
               // Check if this value appears also in the browse_address_values:
               string publish_via_this_interface = "no";
               if( contains( browse_address_values, allow_value ) )
               { publish_via_this_interface = "yes";
               }
               // Extract only the interface-name from the allow_value:
               integer start = findfirstof( allow_value, "(" );
               integer end = findfirstof( allow_value, ")" );
               if( ( nil != start ) && ( nil != end ) && ( end - start - 1 > 0 ) )
               { string interface_name = substring( allow_value, start + 1, end - start - 1 );
                 interface_table_items = add( interface_table_items, `item( `id( size( interface_table_items ) ),
                                                                            interface_name,
                                                                            publish_via_this_interface
                                                                          )
                                            );
               }
             }
           }
         );
  y2milestone( "Initial interface_table_items: %1", interface_table_items );
  UI::ChangeWidget( `interface_table, `Items, interface_table_items );
  initial_interface_table_items = interface_table_items;
  UI::ChangeWidget( `interface_table, `CurrentItem, -1 );
  // Determine the currently available IPv4 (-family inet) network interfaces in the system.
  // Omit loopback interfaces.
  available_interfaces = [];
  if( Printerlib::ExecuteBashCommand( "ip -family inet -oneline link show | grep -v -i loopback | cut -s -d ':' -f 2 | tr -s '[:space:]' ' '" ) )
  { // The command outputs a line where multiple network interfaces are separated by space.
    // Remove empty or effectively empty entries (otherwise it would be something like ["", "eth0", "eth1"]):
    available_interfaces = filter( string interface_name,
                                   toset( splitstring( Printerlib::result["stdout"]:"", " " ) ),
                                   { return( "" !=  filterchars( interface_name, Printer::alnum_chars ) );
                                   }
                                 );
  }
  else
  { // Use fallback value when the command above failed:
    available_interfaces = [];
  }
  y2milestone( "available_interfaces: %1", available_interfaces );

  // Have the IP table disabled until its functionality is implemented:
  UI::ChangeWidget( `ip_table_label, `Enabled, false );
  UI::ChangeWidget( `ip_table, `Enabled, false );
  UI::ChangeWidget( `add_ip, `Enabled, false );
  UI::ChangeWidget( `edit_ip, `Enabled, false );
  UI::ChangeWidget( `delete_ip, `Enabled, false );

  y2milestone( "leaving initSharing" );
}

symbol handleSharing( string key, map event )
{ y2milestone( "entering handleSharing with key '%1'\nand event '%2'", key, event );
  if( "ValueChanged" == event["EventReason"]:"" )
  { switch( event["WidgetID"]:`nil )
    { case `allow_local_network_access_check_box :
           if( ! (boolean)UI::QueryWidget( `allow_local_network_access_check_box, `Value ) )
           { // Set the publish_to_local_network_check_box to false
             // if the allow_local_network_access_check_box is set to false
             // because it makes no sense to publish to the local network
             // but not to allow access from the local network:
             UI::ChangeWidget( `publish_to_local_network_check_box, `Value, false );
           }
           break;
      case `publish_to_local_network_check_box :
           if( (boolean)UI::QueryWidget( `publish_to_local_network_check_box, `Value ) )
           { // Set the allow_local_network_access_check_box to true
             // if the publish_to_local_network_check_box is set to true
             // because it makes no sense to publish to the local network
             // but not to allow access from the local network:
             UI::ChangeWidget( `allow_local_network_access_check_box, `Value, true );
           }
           break;
    }
  }
  if( "Activated" == event["EventReason"]:"" )
  { switch( event["WidgetID"]:`nil )
    { integer current_item = -1;
      map ret = nil;
      map< string, string > interface_map = nil;
      case `add_interface :
           current_item = (integer)UI::QueryWidget( `interface_table, `CurrentItem );
           interface_map = showInterfacePopup( "", false );
           boolean is_in_table = false;
           if( interface_map != nil)
           { interface_table_items = [];
             foreach( term interface_table_item,
                      (list<term>)UI::QueryWidget( `interface_table, `Items),
                      { if( interface_map["interface_name"]:"new" != interface_table_item[1]:"old" )
                        { interface_table_items = add( interface_table_items,
                                                       `item( `id(size(interface_table_items)),
                                                              interface_table_item[1]:"",
                                                              interface_table_item[2]:""
                                                            )
                                                     );
                        }
                        else
                        { is_in_table = true;
                          y2milestone( "Changing interface_table_item %1 with interface_map %2", interface_table_item, interface_map );
                          interface_table_items = add( interface_table_items,
                                                       `item( `id(size(interface_table_items)),
                                                              interface_map["interface_name"]:"",
                                                              interface_map["is_published"]:""
                                                            )
                                                     );
                        }
                      }
                    );
             if( ! is_in_table )
             { y2milestone( "Adding interface_map %1", interface_map );
               interface_table_items = add( interface_table_items,
                                            `item( `id(size(interface_table_items)),
                                                   interface_map["interface_name"]:"",
                                                   interface_map["is_published"]:""
                                                 )
                                          );
               current_item = size(interface_table_items) - 1;
             }
             UI::ChangeWidget( `interface_table, `Items, interface_table_items );
             UI::ChangeWidget( `interface_table, `CurrentItem, current_item );
           }
           break;
      case `edit_interface :
           current_item = (integer)UI::QueryWidget( `interface_table, `CurrentItem );
           term interface_item = (term)UI::QueryWidget( `interface_table, `Item( current_item ) );
           interface_map = showInterfacePopup( (string)interface_item[1]:"",
                                               (interface_item[2]:"no"=="yes")
                                             );
           if( interface_map != nil)
           { interface_table_items = [];
             foreach( term interface_table_item,
                      (list<term>)UI::QueryWidget( `interface_table, `Items),
                      { if( current_item != interface_table_item[0,0]:-1 )
                        { interface_table_items = add( interface_table_items,
                                                       `item( `id(size(interface_table_items)),
                                                              interface_table_item[1]:"",
                                                              interface_table_item[2]:""
                                                            )
                                                     );
                        }
                        else
                        { y2milestone( "Changing interface_table_item %1 with interface_map %2", interface_table_item, interface_map );
                          interface_table_items = add( interface_table_items,
                                                       `item( `id(size(interface_table_items)),
                                                              interface_map["interface_name"]:"",
                                                              interface_map["is_published"]:""
                                                            )
                                                     );
                        }
                      }
                    );
             UI::ChangeWidget( `interface_table, `Items, interface_table_items );
             UI::ChangeWidget( `interface_table, `CurrentItem, current_item );
           }
           break;
      case `delete_interface :
           current_item = (integer)UI::QueryWidget( `interface_table, `CurrentItem );
           if( current_item != nil && current_item > -1 )
           { interface_table_items = [];
             foreach( term interface_table_item,
                      (list<term>)UI::QueryWidget(`interface_table, `Items),
                      { if( current_item != interface_table_item[0,0]:-1 )
                        { interface_table_items = add( interface_table_items,
                                                      `item( `id(size(interface_table_items)),
                                                              interface_table_item[1]:"",
                                                              interface_table_item[2]:""
                                                            )
                                                     );
                        }
                        else
                        { y2milestone("Deleting interface_table_item %1", interface_table_item );
                        }
                      }
                    );
             UI::ChangeWidget( `interface_table, `Items, interface_table_items);
           }
           else
           { y2error("Unproper index for current interface table item: %1", current_item);
           }
           break;
   case `add_ip   :
                        ret = showIPPopup("", false);
                        if (ret!=nil){
                         list items = (list)UI::QueryWidget(`ip_table, `Items);
                         items=add(items, `item(`id(size(items)), ret["device"]:"", ret["publish"]:""));
                         UI::ChangeWidget(`ip_table, `Items, items);
                         UI::ChangeWidget(`ip_table, `CurrentItem, current_item);
                        }
                        break;

   case `edit_ip          :
                        current_item = (integer)UI::QueryWidget(`ip_table, `CurrentItem);
                        term this2 = (term)UI::QueryWidget(`ip_table, `Item(current_item));
                        ret = showIPPopup((string)this2[1]:"", (this2[2]:"no"=="yes"));
                        if (ret!=nil){
                         list items = [];
                         foreach(term oneItem, (list<term>)UI::QueryWidget(`ip_table, `Items), {
                          if (current_item != oneItem[0, 0]:-1){
                           items = add(items, `item(`id(size(items)), oneItem[1]:"", oneItem[2]:""));
                          } else {
                                y2milestone("Changing item %1", oneItem);
                                items = add(items, `item(`id(size(items)), ret["device"]:"", ret["publish"]:""));
                          }
                         });
                        UI::ChangeWidget(`ip_table, `Items, items);
                        UI::ChangeWidget(`ip_table, `CurrentItem, current_item);
                        }
                        break;
   case `delete_ip :
                        current_item = (integer)UI::QueryWidget(`ip_table, `CurrentItem);
                        if (current_item!=nil && current_item>-1){
                         list items = [];
                         foreach(term oneItem, (list<term>)UI::QueryWidget(`ip_table, `Items), {
                          if (current_item != oneItem[0, 0]:-1){
                           items = add(items, `item(`id(size(items)), oneItem[1]:"", oneItem[2]:""));
                          } else y2milestone("Deleting item %1", oneItem);

                         });
                        UI::ChangeWidget(`ip_table, `Items, items);
                        } else y2error("Unproper index for current item: %1", current_item);
                        break;
    }
  }
  if( ! share_printers_dialog_is_useless )
  { // This does not work in any case:
    // boolean remote_access=(`allow_remote_access_radio_button==UI::QueryWidget(`deny_or_allow_remote_access,`CurrentButton));
    // Reason: At least with openSUSE 11.0 and Qt
    // it is possible to un-check all buttons in a RadioButtonGroup
    // by clicking on the currently checked button which un-checks it
    // so that there might be no CurrentButton which leads to unexpected results.
    // Therefore the actual button is tested directly to be on the safe side.
    // But even this does not work really well.
    // The reason is that un-checking the currently checked button
    // does not trigger any event even not with "`opt(`notify, `immediate)"
    // so that this special action is unnoticed.
    boolean remote_access = (boolean)UI::QueryWidget( `allow_remote_access_radio_button, `Value );
    UI::ChangeWidget(`allow_local_network_access_check_box, `Enabled, remote_access);
    UI::ChangeWidget(`publish_to_local_network_check_box, `Enabled, remote_access);
    UI::ChangeWidget(`interface_table_label, `Enabled, remote_access);
    UI::ChangeWidget(`interface_table, `Enabled, remote_access);
    UI::ChangeWidget(`add_interface, `Enabled, remote_access);
    UI::ChangeWidget(`edit_interface, `Enabled, remote_access);
    UI::ChangeWidget(`delete_interface, `Enabled, remote_access);
    UI::ChangeWidget(`ip_table_label, `Enabled, remote_access);
    UI::ChangeWidget(`ip_table, `Enabled, remote_access);
    UI::ChangeWidget(`add_ip, `Enabled, remote_access);
    UI::ChangeWidget(`edit_ip, `Enabled, remote_access);
    UI::ChangeWidget(`delete_ip, `Enabled, remote_access);
    if( remote_access )
    { boolean interface_modify_buttons = true;
      if( 0 == size((list)UI::QueryWidget(`interface_table, `Items)) ) interface_modify_buttons = false;
      UI::ChangeWidget(`edit_interface, `Enabled, interface_modify_buttons);
      UI::ChangeWidget(`delete_interface, `Enabled, interface_modify_buttons);
      boolean ip_modify_buttons = true;
      if( 0 == size((list)UI::QueryWidget(`ip_table, `Items)) ) ip_modify_buttons = false;
      UI::ChangeWidget(`edit_ip, `Enabled, ip_modify_buttons);
      UI::ChangeWidget(`delete_ip, `Enabled, ip_modify_buttons);
    }
  }

  // Have the IP table disabled until its functionality is implemented:
  UI::ChangeWidget( `ip_table_label, `Enabled, false );
  UI::ChangeWidget( `ip_table, `Enabled, false );
  UI::ChangeWidget( `add_ip, `Enabled, false );
  UI::ChangeWidget( `edit_ip, `Enabled, false );
  UI::ChangeWidget( `delete_ip, `Enabled, false );

  return nil;
}

void storeSharing( string key, map event )
{ y2milestone( "entering storeSharing with key '%1'\nand event '%2'", key, event );
  if( ! ApplySharingSettings() )
  { Popup::Error( // Popup::Error message:
                  _("Failed to apply the settings to the system.")
                );
  }
  if( ! sharing_has_changed )
  { y2milestone( "Nothing changed in 'Share Printers' dialog." );
    Popup::ShowFeedback( // No title for such a simple feedback message:
                         "",
                         // Message of a Popup::ShowFeedback when nothing was changed:
                         _("Nothing changed.")
                       );
    sleep( 1000 );
    Popup::ClearFeedback();
  }
  y2milestone( "leaving storeSharing" );
  return nil;
}

/* EOF */
}
