/**
 * File:
 *  printer.ycp
 *
 * Module:
 *  Printer configurator
 *
 * Summary:
 *  Main file of printer.
 *
 * Authors:
 *  Jan Holesovsky <kendy@suse.cz>, 2000
 *  Petr Blahos <pblahos@suse.cz>, 2001
 *  Jiri Srain <jsrain@suse.cz>, 2002, 2003
 *
 * $Id$
 *
 * Main file of printer package. Calls all other modules.
 */

{
    /***
     * <H3>YaST2 Printers configuration</H3>
     * Configurator of printers that works with packages <tt>cups</tt> and <tt>LPRng</tt>
     * as printing daemons and <tt>apsfilter</tt> or Foomatoc as magic filter.<BR>
     * For printer documentation index, click <a href="../index.html">here</a>.
     */

    textdomain "printer";

    import "CommandLine";
    import "Crash";
    import "Label";
    import "Mode";
    import "RichText";
    import "Printer";

    include "commandline/commandline.ycp";
    include "printer/wizards.ycp";

// --------------------------------------------------------------------------
// --------------------------------- cmd-line handlers

    /**
      * CommandLine handler for running GUI
      * @return boolean true if settings were saved
      */
    define boolean GuiHandler () ``{
	symbol ret = nil;
	if (Mode::test)
	    testDialogs ();
	else
	    ret = PrinterSequence ();

	if (ret == `abort || ret == `back || ret == `nil)
	    return false;
	return true;
    }

    /**
     * Print summary of basic options
     * @param options a list of parameters passed as args
     * @return boolean false
     */
    define boolean PrinterSummaryHandler (map options ) ``{
	CommandLine::Print (RichText::Rich2Plain(
	    "<br>"+Printer::Summary ([`nonew])));
	return false; // do not call Write...
    }

    /**
     * Delete a specified queue
     * @param options a list of parameters passed as args
     * @return boolean true on success
     */
    define boolean PrinterDeleteHandler (map options) ``{
	Printer::selectPrinterByName (options["queue"]:"");
	if (Printer::printer == $[])
	{
	    CommandLine::Print (sformat (_("Queue %1 does not exist."),
		options["queue"]:""));
	    return false;
	}
	Printer::deletePrinter ();
	return true;
    }

    /**
     * Modify a selected queue
     * @param options a list of parameters passed as args
     * @return boolean true on success
     */
    define boolean ModifyPrinter (map options) ``{
	boolean recreate_ppd = false;
	string manufacturer = "";
	string model = "";
	string nick = "";

// URI handling
	if (options["uri"]:"" != "" && options["detected_index"]:nil != nil)
	{
	    CommandLine::Print (_("Cannot specify URI and detected printer in one command."));
	    return false;
	}
	if (Printer::printer["uri"]:"" == "" && options["uri"]:"" == ""
	    && options["detected_index"]:nil == nil)
	{
	    CommandLine::Print (sformat (_("URI for queue %1 not specified."),
		options["new_name"]:Printer::printer["name"]:""));
	    return false;
	}
	if (options["uri"]:"" != "")
	    Printer::printer["uri"] = options["uri"]:"";
// detected queue handing
	if (options["detected_index"]:nil != nil)
	{
	    string s_index = options["detected_index"]:"0";
	    integer index = tointeger (s_index);
	    if (0 >= index || size (Printer::autodetected) < index)
	    {
		CommandLine::Print (sformat (_("Printer %1 was not detected."),
		    index));
		return false;
	    }
	    index = index - 1;
	    Printer::editDetected (Printer::autodetected[index]:$[]);
	}
// queue name handling
	if (Printer::printer["name"]:"" == "" && options["new_name"]:"" == "")
	{
	    CommandLine::Print (_("Queue name not specified."));
	    return false;
	}
	if (options["new_name"]:"" != Printer::printer["name"]:""
	    && contains (Printer::getForbiddenNames(), options["new_name"]:""))
	{
	    CommandLine::Print (sformat (
		_("Specified queue name %1 is already used."),
		options["new_name"]:""));
	    return false;
	}
	if (options["new_name"]:"" != ""
	    && Printer::printer["name"]:"" != options["new_name"]:"")
	{
	    if (Printer::printer["name"]:"" != "")
	    {
		Printer::addToDeleted (
                    Printer::printer["name"]:"",
		    Printer::printer["uri"]:"" == "class"
			? "class"
			: "printer"
		);
	    }
	    Printer::printer["name"] = options["new_name"]:"";
	}
// raw queue handling
	if (haskey (options, "raw"))
	{
	    Printer::printer["raw"] = true;
	}
	else if (haskey (options, "manufacturer") || haskey (options, "model")
	    || haskey (options, "nick"))
	{
	    Printer::printer["raw"] = false;
	}
// manufacturer handling
	if (haskey (options, "manufacturer") && ! haskey (options, "model"))
	{
	    CommandLine::Print (sformat (_("Model not specified for queue %1."),
		Printer::printer["name"]:""));
	    return false;
	}
	if (haskey (options, "manufacturer"))
	{
	    Printerdb::loadFoomaticIfNeeded ();
	    manufacturer = (string)SCR::Read (.ppd.db.vendorname,
		options["manufacturer"]:"");
	    if (! haskey (Printerdb::foomatic, manufacturer))
	    {
		CommandLine::Print (sformat (_("Unknown Manufacturer: %1"),
		    options["manufacturer"]:""));
		return false;
	    }
	    recreate_ppd = true;
	}
	else
	{
	    manufacturer = Printer::printer["ppd_info", "manufacturer"]:"";
	}
// model handling
	if (haskey (options, "model"))
	{
	    Printerdb::loadFoomaticIfNeeded ();
	    model = (string)SCR::Read (.ppd.db.modelname,
		[manufacturer, options["model"]:""]);
	    if (! haskey (Printerdb::foomatic[manufacturer]:$[], model))
	    {
		CommandLine::Print (sformat (_("Unknown Model: %1"),
		    options["model"]:""));
		return false;
	    }
	    recreate_ppd = true;
	}
	else
	{
	    model = Printer::printer["ppd_info", "model"]:"";
	}
// nickname handling
	if (haskey (options, "nick"))
	{
	    Printerdb::loadFoomaticIfNeeded ();
	    nick = options["nick"]:"";
	    if (! haskey (Printerdb::foomatic[manufacturer, model]:$[], nick))
	    {
		CommandLine::Print (sformat (_("Unknown PPD File Nickname: %1"),
		    options["nick"]:""));
		return false;
	    }
	    recreate_ppd = true;
	}
	else
	{
	    nick = Printerdb::getAutoPpdFile (manufacturer, model, nil);
	}
// create new PPD file if relevant information changed
	if (recreate_ppd)
	{
	    string filename = Printerdb::foomatic[manufacturer, model, nick,
		"filename"]:"";
	    string ppd_file = (string)SCR::Read (.ppd.file.open,
		[filename, SCR::Read (.target.tmpdir)]);

            Printer::printer = (map<string,any>)union (Printer::printer, $[
                "ppd" : ppd_file,
                "ppd_info" : Printer::ppdInfo (ppd_file),
            ]);
	}
// ff (form feed) handling
	if (haskey (options, "ff"))
	    Printer::printer["ff"] = options["ff"]:false;
// info handling
// location handling
// banners handling
	list just_copy = ["info", "location", "bannerstart", "bannerend"];
	foreach (string key, just_copy, ``{
	    if (haskey (options, key))
		Printer::printer[key] = options[key]:"";
	});
// allow and deny users
	if (haskey (options, "allowusers") && haskey (options, "denyusers"))
	{
	    CommandLine::Print (_("Only one of 'allowusers' and 'denyusers' can be specified."));
	    return false;
	}
	list string2list = ["allowusers", "denyusers"];
	Printer::printer["allowusers"] = [];
	Printer::printer["denyusers"] = [];
	foreach (string key, string2list, ``{
	    if (haskey (options, key))
	    {
		list<string> split = splitstring (options[key]:"", ", ");
		split = filter (string s, split, ``(s != ""));
		Printer::printer[key] = split;
	    }
	});

// default queue handling
	if (haskey (options, "default"))
	    Printer::default = Printer::printer["name"]:"";

	Printer::storePrinter ();
	return true;
    }

    /**
     * Add a mew queue
     * @param options a list of parameters passed as args
     * @return boolean true on success
     */
    define boolean PrinterAddHandler (map options) ``{
	Printer::selectPrinter (-1);
	options["new_name"] = options["queue"]:"";
	return ModifyPrinter (options);
    }

    /**
     * Edit a specified queue
     * @param options a list of parameters passed as args
     * @return boolean true on success
     */
    define boolean PrinterEditHandler (map options) ``{
	Printer::selectPrinterByName (options["queue"]:"");
	if (Printer::printer == $[])
	    return false;
	return ModifyPrinter (options);
    }

    /**
     * List configured or detected queues
     * @param options a list of parameters passed as args
     * @return boolean always false
     */
    define boolean PrinterListHandler (map options) ``{
	if (! haskey (options, "configured"))
	{  // list detected
	    CommandLine::Print (_("Detected Printers:"));
	    integer index = 0;
	    foreach (map p, Printer::autodetected, ``{
		index = index + 1;
		CommandLine::Print (sformat ("%1: %2 %3: %4",
		    index,
		    p["vendor"]:"",
		    p["device"]:"",
		    Printerlib::getUriNiceName (p["uri"]:"")));
	    });
	    CommandLine::Print ("");
	}
	if (! haskey (options, "detected"))
	{  // list configured
	    CommandLine::Print (_("Configured Queues:"));
	    foreach (map p, Printer::printcap, ``{
		CommandLine::Print (sformat ("%1: %2",
		    p["name"]:"",
		    Printerlib::getUriNiceName (p["uri"]:"")));
	    });
	    CommandLine::Print ("");
	}
	return false;
    }

    /**
     * Edit specified options of a queue
     * @param options a list of parameters passed as args
     * @param type string type of options to change
     * @return always true
     */
    define boolean PrinterOptionsHandler (map options, string type) ``{
	Printer::printer[type] = union (
	    Printer::printer[type]:$[], options
	);
	return true;
    }

    /**
     * Edit options located in /etc/cups/lpoptions of a queue
     * @param options a list of parameters passed as args
     * @return always true
     */
    define boolean PrinterLPOptionsHandler (map options) ``{
	return PrinterOptionsHandler (options, "options");
    }

    /**
     * Edit options located in PPF file of a queue
     * @param options a list of parameters passed as args
     * @return always true
     */
    define boolean PrinterPPDOptionsHandler (map options) ``{
	return PrinterOptionsHandler (options, "ppd_options");
    }

    /**
     * Change the currently used spooler (or basic attributes)
     * @param options a list of parameters passed as args
     * @return boolean true if saving is to be performed
     */
    define boolean PrinterSpoolerhandler (map options) ``{
	integer found = 0;
	foreach (string s, ["cups", "lprng", "cups_client"], ``{
	    if (haskey (options, s))
		found = found + 1;
	});
	if (0 == found)
	{
	    CommandLine::Print (_("No spooler specified."));
	    return false;
	}
	if (1 < found)
	{
	    CommandLine::Print (_("More than spooler specified"));
	    return false;
	}
	if (haskey (options, "cups"))
	{
	    Spooler::switchTo ("cups");
	    Printer::Read ();
	}
	else if (haskey (options, "lprng"))
	{
	    Spooler::switchTo ("lprng");
	    Printer::Read ();
	}
	else if (haskey (options, "cups_client"))
	{
	    if (options["server"]:"" == "")
	    {
		CommandLine::Print (_("CUPS server not specified."));
		return false;
	    }
	    Spooler::switchTo ("cups_client");
	    CUPS::server_hostname = options["server"]:"";
	    Printer::default = options["default_queue"]:"";
	    CUPS::server_default = Printer::default == "";
	}
	else
	    return false;
	return true;
    }

    /**
     * Test a queue
     * @param options a list of parameters passed as args
     * @return boolean true if saving is to be performed
     */
    define boolean PrinterTestHandler (map options) ``{
	string queue_name = options["queue"]:"";
	Printer::selectPrinterByName (queue_name);
	if (Printer::printer == $[])
	{
	    CommandLine::Print (sformat (_("Queue %1 does not exist."),
		queue_name));
	    return false;
	}
	map tp_types = $[
	    "ascii" : `ascii,
	    "photo" : `photo,
	];
	symbol tp_type = tp_types[options["testpage_type"]:""]:`postscript;
	PrinterTest::testPrinter(Printer::printer, tp_type);
	return false;
    }

    /**
     * Print manufacturers in the database
     * @param options a list of parameters passed as args
     * @return boolean true if saving is to be performed
     */
    define boolean PrinterManufacturersHandler (map options) ``{
	Printerdb::loadFoomaticIfNeeded ();
	CommandLine::Print (_("Known Manfacturers:"));
	foreach (string k, map v, Printerdb::foomatic, ``{
	    CommandLine::Print (v[`label]:k);
	});
	return false;
    }

    /**
     * Print models in the database of the specified manufacturer
     * @param options a list of parameters passed as args
     * @return boolean true if saving is to be performed
     */
    define boolean PrinterModelsHandler (map options) ``{
	Printerdb::loadFoomaticIfNeeded ();
	if (! haskey (options, "manufacturer"))
	{
	    CommandLine::Print (_("Manufacturer not specified."));
	    return false;
	}
	string manufacturer = (string)SCR::Read (.ppd.db.vendorname,
	    options["manufacturer"]:"");
	CommandLine::Print (_("Known Models"));
	foreach (string k, map v,
	    filter (any k, any v, Printerdb::foomatic[manufacturer]:$[],
	    ``(
		is (k, string)
	    )),
	``{
	    CommandLine::Print (v[`label]:k);
	});
	return false;
    }

    /**
     * Print nicknames in the database of specified manuf/model
     * @param options a list of parameters passed as args
     * @return boolean true if saving is to be performed
     */
    define boolean PrinterNicknamesHandler (map options) ``{
	Printerdb::loadFoomaticIfNeeded ();
	if (! haskey (options, "manufacturer"))
	{
	    CommandLine::Print (_("Manufacturer not specified."));
	    return false;
	}
	string manufacturer = (string)SCR::Read (.ppd.db.vendorname,
	    options["manufacturer"]:"");
	if (!haskey (options, "model"))
	{
	    CommandLine::Print (_("Model not specified."));
	    return false;
	}
	string model = (string)SCR::Read (.ppd.db.modelname,
	    [manufacturer, options["model"]:""]);
	CommandLine::Print (_("Known Nick Names"));
	foreach (string k, map v,
	    filter (any k, any v,
		Printerdb::foomatic[manufacturer, model]:$[],
	    ``(
		is (k, string)
	    )),
	``{
	    CommandLine::Print (v[`label]:k);
	});
	return false;
    }

    /**
     * Print PPD options of the specified queue
     * @param options a list of parameters passed as args
     * @return boolean true if saving is to be performed
     */
    define boolean PrinterListPpdOptionsHandler (map options) ``{
	// TODO implement
	return false;
    }

    /* the command line description map */
    map cmdline = $[
	"id"		: "printer",
	// command line help text for Printer module
	"help"		: _("Printer configuration module."),
	"guihandler"	: GuiHandler,
	"initialize"	: Printer::Read,
	"finish"	: Printer::Write,
	"actions"	: $[
	    "summary"	: $[
		"handler"	: PrinterSummaryHandler,
		// command line help text for summary action
		"help"		: _("Configuration summary of printers")
	    ],
	    "delete"	: $[
		"handler"	: PrinterDeleteHandler,
		// command line help text for delete action
		"help"		: _("Delete a configured queue")
	    ],
	    "add"	: $[
		"handler"	: PrinterAddHandler,
		// command line help text for delete action
		"help"		: _("Add new queue")
	    ],
	    "edit"	: $[
		"handler"	: PrinterEditHandler,
		// command line help text for delete action
		"help"		: _("Edit a configured queue")
	    ],
	    "list"	: $[
		"handler"	: PrinterListHandler,
		// command line help text for the list action
		"help"		: _("List detected or configured printers"),
	    ],
	    "ppdoptions": $[
		"handler"	: PrinterPPDOptionsHandler,
		// command line help text for the ppdoptions action
		"help"		: _("Set options that will be writted directoy to PPD file. Options that are not mentioned stay untouched."),
	    ],
	    "lpoptions" : $[
		"handler"	: PrinterLPOptionsHandler,
		// command line help text for the lpoptions action
		"help"		: _("Set options that will be written to /etc/cups/lpoptions. Options that are not mentioned stay untouched."),
	    ],
	    "spooler"	: $[
		"handler"	: PrinterSpoolerhandler,
		// command line help text for the spooler action
		"help"		: _("Switch the currently used spooler")
	    ],
	    "test"	: $[
		"handler"	: PrinterTestHandler,
		// command line help text for the test action
		"help"		: _("Print test page"),
	    ],
	    "list_manufacturers": $[
		"handler"	: PrinterManufacturersHandler,
		// command line help text for the test action
		"help"		: _("List known manufacturers"),
	    ],
	    "list_models"	: $[
		"handler"	: PrinterModelsHandler,
		// command line help text for the test action
		"help"		: _("List known models of specified manufacturer"),
	    ],
	    "list_nicknames": $[
		"handler"	: PrinterNicknamesHandler,
		// command line help text for the test action
		"help"		: _("List known nicknames for specified model of specified manufacturers"),
	    ],
	    "list_ppdoptions": $[
		"handler"	: PrinterListPpdOptionsHandler,
		// command line help text for the test action
		"help"		: _("List options of PPD file of specified queue"),
	    ],
	],
	"options"	: $[
	    "detected_index"	: $[
		"help"		: _("Configure detected printer with this index"),
		"type"		: "string",
	    ],
	    "queue"	: $[
		// command line help text for the queue name option
		"help"		: _("Queue Name"),
		"type"		: "string",
	    ],
	    "new_name"	: $[
		// command line help text for the queue name option
		"help"		: _("New queue name (for changing it)"),
		"type"		: "string",
	    ],
	    "uri"	: $[
		// command line help text for the printer URI option
		"help"		: _("Printer URI"),
		"type"		: "string",
	    ],
	    "raw"	: $[
		"help"		: _("Queue will not be filtering."),
	    ],
	    "manufacturer" : $[
		"help"		: _("Printer manufacturer"),
		"type"		: "string",
	    ],
	    "model"	: $[
		"help"		: _("Printer model"),
		"type"		: "string",
	    ],
	    "nick"	: $[
		"help"		: _("Nick name of the PPD file"),
		"type"		: "string",
	    ],
	    "info"	: $[
		"help"		: _("Information about the queue"),
		"type"		: "string",
	    ],
	    "location"	: $[
		"help"		: _("Location of the printer"),
		"type"		: "string",
	    ],
	    "ff"	: $[
		"help"		: _("Print form feed after evbery job (LPRng only)"),
		"type"		: "boolean",
	    ],
	    "bannerstart":$[
		"help"		: _("Banner to be printed before every job"),
		"type"		: "enum",
		"typespec"	: CUPS::getBannerList (),
	    ],
	    "bannerend"	: $[
		"help"		: _("Banner to be printed after every job"),
		"type"		: "enum",
		"typespec"	: CUPS::getBannerList (),
	    ],
	    "accepting" : $[
		"help"		: _("Set if the queue accepts jobs"),
		"type"		: "enum",
		"typespec"	: ["Yes", "No"],
	    ],
	    "state"	: $[
		"help"		: _("Set the state of the queue"),
		"type"		: "enum",
		"typespec"	: ["Stopped", "Idle"],
	    ],
	    "allowusers": $[
		"help"		: _("Set users that are allowed to print using this queue"),
		"type"		: "string",
	    ],
	    "denyusers"	: $[
		"help"		: _("Set users that are not allowed to print using this queue"),
		"type"		: "string",
	    ],
	    "default"	: $[
		"help"		: _("Set the queue to default"),
	    ],
	    "detected"	: $[
		"help"		: _("List only detected printers"),
	    ],
	    "configured"	: $[
		"help"		: _("List only configured queues"),
	    ],
	    "cups"	: $[
		"help"		: _("Switch top CUPS server"),
	    ],
	    "lprng"	: $[
		"help"		: _("Switch to LPRng server"),
	    ],
	    "cups_client":$[
		"help"		: _("Switch to CUPS client"),
	    ],
	    "server":$[
		"help"		: _("Specify the remote CUPS server"),
		"type"		: "string",
	    ],
	    "default_queue":$[
		"help"		: _("Specify the default queue, if not set, default queue of the server will be used"),
		"type"		: "string"
	    ],
	    "testpage_type":$[
		"help"		: _("Type of the test page, one of ascii, graphic, photo"),
		"type"		: "string",
	    ],
	],
	"mappings"	: $[
	    "summary"		: [],
	    "list"		: [ "detected", "configured" ],
	    "delete"		: [ "queue" ],
	    "add"		: [
					"queue", "detected_index",
					"uri", "raw", "manufacturer",
					"model", "nick", "info", "location",
					"ff", "bannerstart", "bannerend",
					"accepting", "state", "allowusers",
					"denyusers", "default"
				  ],
	    "edit"		: [
					"queue", "new_name",
					"uri", "raw", "manufacturer",
					"model", "nick", "info", "location",
					"ff", "bannerstart", "bannerend",
					"accepting", "state", "allowusers",
					"denyusers", "default"
				  ],
	    "ppdoptions"	: [ "queue"],
	    "lpoptions"		: [ "queue"],
	    "spooler"		: [
					"cups", "lprng", "cups_client",
					"server", "default_queue"
				  ],
	    "test"		: [ "queue", "testpage_type" ],
	    "list_manufacturers": [],
	    "list_models"	: [ "manufacturer" ],
	    "list_nicknames"	: [ "manufacturer", "model" ],
	    "list_ppdoptions"   : [ "queue" ],
	]
    ];



// --------------------------------------------------------------------------

    Crash::Run ("printer.ycp");

    boolean ret = nil;

    // ===== arguments ================================================

    integer i = 0;
/*    while (i < size (WFM::Args()))
    {
	if (.test == WFM::Args (i))
	{
	    Mode::test = true;
	    Printer::skip_autodetection = true;
	}
	else if (.nodetection == WFM::Args (i)
	    || ".nodetection" == WFM::Args (i))
	{
	    Printer::skip_autodetection = true;
	}
	i = i + 1;
    }*/

    boolean cups_running = 0 == SCR::Execute (.target.bash,
	"test -f /etc/init.d/cups && /etc/init.d/cups status");
    boolean lprng_running = 0 == SCR::Execute (.target.bash,
	"test -f /etc/init.d/lpd && /etc/init.d/lpd status");

    ret = CommandLineRun (cmdline);
# // FIXME remove following line
#    ret = GuiHandler ();

    if (! ret)
    {
	if (! cups_running)
	{
	    SCR::Execute (.target.bash,
		"test -f /etc/init.d/cups && /etc/init.d/cups stop");
	}
	if (! lprng_running)
	{
	    SCR::Execute (.target.bash,
		"test -f /etc/init.d/lpd && /etc/init.d/lpd stop");
	}
    }

    Crash::Finish ("printer.ycp");
    return ret;
}


