/**
 * File:
 *  misc.ycp
 *
 * Module:
 *  Printer configurator
 *
 * Summary:
 *  Miscelaneous defines.
 *
 * Authors:
 *  Petr Blahos <pblahos@suse.cz>
 *  Jiri Srain <jsrain@suse.cz>   2002
 *
 * $Id$
 *
 * Miscelaneous defines.
 */

{
    textdomain "printer";

    import "Encoding";
    import "CUPS";
    import "Label";
    import "Mode";
    import "Popup";
    import "Printer";
    import "Printerdb";
    import "Printerlib";
    import "Require";
    import "Spooler";
    import "Wizard";

    /**
      * Get auto queues for printer when using foomatic database
      * @param vendor string vendor db key
      * @param model string model db key
      * @param config string choosen ppd file, nil = auto
      * @return list of PPD files
      */
     define list getFoomaticAutoQueues (string vendor, string model,
        string config)
    ``{
        list forbidden_names = Printer::getForbiddenNames ();
        y2debug ("Getting auto queues for >>%1<< >>%2<<", vendor, model);
        Printerdb::loadFoomaticIfNeeded ();
        list new_queues = [];
        map ppds = Printerdb::getPpdFiles (vendor, model);
        string ppdfile_orig = "";
        if (vendor == "__spec_ppd__")
            ppdfile_orig = model;
        else if (config == nil || config == "")
            ppdfile_orig = Printerdb::getAutoPpdFile (vendor, model, nil);
        else
            ppdfile_orig = Printerdb::foomatic[vendor, model, config, "filename"]:"";
        y2debug ("Choosen PPD file: %1", ppdfile_orig);
        string config = ppds[ppdfile_orig]:"";
        string ppdfile = (string)SCR::Read (.ppd.file.open,
            [ppdfile_orig, SCR::Read (.target.tmpdir)]);
	Printer::printer["ppd"] = ppdfile;
	Printer::printer["ppd_info"] = Printer::ppdInfo (ppdfile);
        map options = (map)SCR::Read (.ppd.file.options, [ppdfile, ""]);
        list opts = options["data"]:[];
            integer ind = -1;
            boolean found = true;
            find (map i, opts, ``{
                ind = ind + 1;
                found = i["name"]:"" == "PrintoutMode";
                return found;
            });
            map composite = $[];
            if (found)
                composite = opts[ind]:$[];
		string pagesize = Printerlib::getDefaultPaperSize () == `a4
		    ? "A4"
		    : "Letter";
            if (composite != $[])
            {
                string optname = composite["name"]:"";
                foreach (string v, composite["valorder"]:[], ``{
                    map new_options = $[
                        optname : v,
                        "PageSize" : pagesize,
                        "PageRegion" : pagesize,
                        "ImageableArea" : pagesize,
                        "PaperDimension" : pagesize,
                    ];
                    new_queues = add (new_queues, $[
                        "name" : mergestring (splitstring
                            (tolower (v), "."), "_"),
                        "info" : composite["values", v]:v,
                        "ppd_options" : new_options,
                    ]);

                });
            }
            else
            {
                new_queues = [ $[
                    "name" : "lp",
                        // table cell
                    "info" : _("default configuration"),
		    "ppd_options" : $[
                        "PageSize" : pagesize,
                        "PageRegion" : pagesize,
                        "ImageableArea" : pagesize,
                        "PaperDimension" : pagesize,
		    ],
                ]];
            }
            string suffix = Printer::getQueueSuffix (new_queues);

            new_queues = maplist (map v, new_queues, ``{
                v = add (v, "name", Printer::adjustQueueName (lookup (v, "name", "lp") + suffix, forbidden_names));
                forbidden_names = add (forbidden_names, lookup (v, "name", ""));
                return union (Printer::printer, v);
        });
        y2debug ("Proposing queues %1", maplist (map q, new_queues, ``(
	    q["name"]:"")));
        y2debug ("Proposed queues: %1", new_queues);
        return new_queues;
    }


    /**
      * Sort items according to locale
      * @param items map items (item key -> item label)
      * @return list of items to be used for selectionbox
      */
    define list sortitems (map items) ``{
	string enc = Encoding::console;
	items = mapmap (string k, string v, items, ``(
	    $[k: (string)UI::Recode ("UTF-8", enc, v)]));
	list l = (list)SCR::Read (.ppd.sort_items, items);
	l = maplist (term i, l, ``{
	    string label = select (i, 1, "");
	    label = (string)UI::Recode (enc, "UTF-8", label);
	    i = remove (i, 2);
	    i = add (i, label);
	    return i;
	});
	return l;
    }

    /**
      * Check if paper size is set and if not, then set the defaul
      * Don't change if already set
      * @param p map of printer to adjust paper size
      * @return map of printer with adjusted paper size
      */
    define map adjustPaperSize (map p) ``{
	map options = p["ppd_options"]:$[];
	if (haskey (options, "PageSize"))
	    return p;
	string pagesize = Printerlib::getDefaultPaperSize () == `a4 ? "A4" : "Letter";
	options["PageSize"] = pagesize;
	options["PageRegion"] = pagesize;
	options["ImageableArea"] = pagesize;
	options["PaperDimension"] = pagesize;
	p["ppd_options"] = options;
	return p;
    }


    /**
      * replaces all occurences of 'from' to 'to' in src
      * @param src input string
      * @param from string to be replaced
      * @param to string to be replaced by
      * @return string modified string
      */
    define string replaceAll(string src, string from, string to) ``{
        if (from == "")
        {
            return src;
        }

        list<string> tokens = [];

        integer p = find(src, from);
        while(p >= 0)
        {
            tokens = add(tokens, substring(src, 0, p));
            src = substring(src, p + size(from), size(src) - (p+size(from)));
            p = find(src, from);
        }
        tokens = add(tokens, src);
        return mergestring(tokens, to);
    }

    /**
      * Get printers (physical devices), which are configured
      * @return a list of printers maps (one queue of each printer)
      */
    define list<map> getConfiguredPrinters () ``{
        list<string> ukeys = [];
        list<string> uris = [];
	list<string> models = [];
	list<map> printers = [];

        foreach (map p, Printer::printcap, ``{
            string ukey = p["unique_key"]:"";
            string uri = p["uri"]:"";
	    map ppd_info = p["ppd_info"]:$[];
	    string model = ppd_info["manufacturer"]:"" + ppd_info["model"]:"";
	    if (model == "")
	    {
		model = ppd_info["manufacturer_db"]:""
		    + ppd_info["model_db"]:"";
	    }
            if ((! contains (ukeys, ukey)
		    && (! contains (uris, uri))
			|| ! contains (models, model)
		    )
		&& (model != "" && uri != ""))
            {
                uris = add (uris, uri);
                if (ukey != "")
                    ukeys = add (ukeys, ukey);
		models = add (models, model);
                printers = add (printers, p);
            }
        });

	return printers;
    }

    /**
      * Has a printer (physical) been already configured (contains at least
      * one queue?
      * @param manuf string manufacturer of the printer
      * @param model string model of the printer
      * @param uri string URI of the printer
      * @param unique_key string unique_key of the printer
      * @return boolean true if already configured
      */
    define boolean isPrinterConfigured (string manuf, string model,
	string uri, string unique_key)
    ``{
	string manuf_db = (string)SCR::Read (.ppd.db.vendorname, manuf);
	string model_db = (string)SCR::Read (.ppd.db.modelname,
	    [manuf_db, model]);
	boolean exists = false;

	foreach (map p, Printer::printcap, ``{
	    if ((p["unique_key"]:"" == unique_key && unique_key != "")
		|| (p["uri"]:"" == uri && uri != ""
		    && ((p["ppd_info", "manufacturer_db"]:".." == manuf_db
			    && p["ppd_info", "model_db"]:".." == model_db)
			|| (p["ppd_info", "manufacturer"]:".." == manuf
			    && p["ppd_info", "model"]:".." == model))
		   ))
	    {
		exists = true;
	    }
	});
	return exists;
    }


    /**
     * Reinstall all printing related packages using package-manager
     * @return boolean true if success
     */
    define boolean reinstallAll () ``{
	if (Mode::config)
	{
	    Printerlib::DisplayUnavailableAIPopup ();
	    return true;
	}
	import "PackageCallbacksInit";
	PackageCallbacksInit::InitPackageCallbacks ();
	Printer::printcap = [];
	Printer::default = "";

	Spooler::StopServices();
	list to_delete = ["plp", "lprold", "lprng", "cups", "cups-client", "cups-drivers", "cups-drivers-cs", "cups-drivers-de", "cups-drivers-stp",
	    "cups-libs", "cups-devel", "lpdfilter", "filters", "ghostscript-fonts-other", "ghostscript-x11", "ghostscript-fonts-std", "ghostscript-library",
	    "ghostscript-fonts-kanji", "ghostscript-serv", "ghostscript-fonts-rus", "ghostscript-library", "a2ps", "foomatic-filters"];
	to_delete = filter (string e, to_delete,
	    ``(Pkg::IsProvided (e) == true));

	list to_install = ["ghostscript-library", "ghostscript-x11", "ghostscript-fonts-std", "ghostscript-fonts-other", "a2ps", "cups-libs"];

	y2milestone("deleting: %1", to_delete);
	foreach (string e, to_delete, ``{Pkg::PkgDelete (e);});
	Pkg::PkgCommit (0);
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/cups/");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/lpdfilter/");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/printcap");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/printcap.rpm*");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/printcap-2*");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/printcap.y2*");
	SCR::Execute (.target.bash, "/bin/rm -rf /var/spool/lpd/");
	SCR::Execute (.target.bash, "/bin/rm -rf /var/spool/cups/");
	SCR::Execute (.target.bash, "/bin/rm -rf /var/lib/YaST2/printers");

	foreach (string e, to_install, ``{Pkg::PkgInstall (e);});

	y2milestone("installing: %1", to_install);
	Pkg::PkgSolve (false);
	Pkg::PkgCommit (0);
	Require::RunSuSEconfig ();
	return true;

    }
    /**
     * Get hosts available on local network. Reads from .net.hostnames. Shows popup window: Wait please.
     * @param type "ipp", "samba", "lpd" or ""
     * @return list Sorted list of hosts.
     */
    define list getHostnames (string type) ``{
        UI::OpenDialog (`opt (`decorated),
                         // text in dialog box
                         `Label (_("Scanning for hosts on this LAN...")));
        list hosts = [];
        if ("samba" == type)
            hosts = (list)SCR::Read (.net.hostnames.samba);
        else if ("ipp" == type)
	{
            hosts = (list)SCR::Read (.net.hostnames, 631);
	    hosts = filter (`h, hosts, ``{
		list queues = (list)SCR::Read (.cups.remote, h);
		return size (queues) > 0;
	    });
	}
        else if ("lpd" == type)
            hosts = (list)SCR::Read (.net.hostnames, 515);
        else if ("socket" == type)
            hosts = (list)SCR::Read (.net.hostnames, 9100);
        else if ("" != type)
	    hosts = (list)SCR::Read (.net.hostnames, tointeger (type));
	else
            hosts = (list)SCR::Read (.net.hostnames);
        if (nil == hosts)
            hosts = [];
        UI::CloseDialog ();
        return sort (hosts);
    }

    /**
     * Return list without item.
     * @param source source list
     * @param item item to delete
     * @return list List without item. If item was not present in list, list is unchanged.
     */
    define list DeleteItem (list source, any item) ``{
        return filter (`i, source, ``{
            return i != item;
        });
    }
    /**
     * Displays message when baud rate is 0.
     * @param brate Baud rate.
     * @return boolean Is baud rate ok?
     */
    define boolean testBaudRate (integer brate) ``{
	if (brate == 0)
	    {
		// message box
		Popup::Message (_("The baud rate should not be 0!"));
		return false;
	    }
	return true;
    }
    /**
     * Is the hostname correct? Check it for allowed characters. Display message if bad hostname.
     * @param name Hostname to check
     * @return boolean true if hostname is correct.
     */
    define boolean checkHostName (string name) ``{
	if (size (name) > 0 &&
	    /*size (name) < 50 &&*/
	    "" == filterchars (name,
				":/@"))
	    {
		return true;
	    }
	else
	    {
		// message box
		// the ',' character isn't separator,
		//  but one of a list of characters
		Popup::Message (_("Invalid host name. It must be
shorter than fifty characters and cannot contain
:, / or @.
"));
	    }
	return false;
    };

   /**
     * Is the username correct? Check it for allowed characters. Display message if bad username.
     * @param name Username to check
     * @return boolean true if username is correct.
     */
    define boolean checkUserName (string name) ``{
        if (/*size (name) > 0 &&
            size (name) < 50 &&*/
            "" == filterchars (name,
                                ":/@"))
            {
                return true;
            }
        else
            {
                // message box
                // the ',' character isn't separator,
                //  but one of a list of characters
                Popup::Message (_("Invalid user name. It cannot 
contain the characters : , / @.
"));
            }
        return false;
    };

   /**
     * Is the password correct? Check it for allowed characters. Display message if bad password.
     * @param name password to check
     * @return boolean true if hostname is correct.
     */
    define boolean checkPassword (string name) ``{
        if (/*size (name) > 0 &&
            size (name) < 50 &&*/
            "" == filterchars (name,
                                ":/@"))
            {
                return true;
            }
        else
            {
                // message box
                // the ',' character isn't separator,
                //  but one of a list of characters
                Popup::Message (_("Invalid password. It cannot 
contain the characters : , / @.
"));
            }
        return false;
    };



    /**
     * Check if remote_printer is not nil. Display message otherwise.
     * @param remote_printer Printer name to check
     * @return boolean true if name is OK
     */
    define boolean checkRemotePrinter (string remote_printer) ``{
	if ("" != remote_printer)
	    {
		return true;
	    }
	// message box
	Popup::Message ( _("Please choose which forwarding
queue you want to use."));
	return false;
    };

    /**
      * generate class name
      * @param forbidden_names list of forbidden names
      * @return new class name
      */
    define string generateClassName (list forbidden_names) ``{
	string name = "class1";
	integer i = 2;
	while (contains (forbidden_names, name))
	{
	    name = sformat ("class%1", i);
	    i = i + 1;
	}
	return name;
    }

    /**
     * Ask if really abort. Uses boolean Printer::dirty. Sets boolean do_abort_now.
     * @return boolean true if user really wants to abort
     */
    define boolean reallyAbort ()``{
	boolean abort_now = false;
	if (abort_now || !Printer::dirty)
	    {
		return true;
	    }
	abort_now = Popup::ReallyAbort (true);
	return abort_now;
    }

    /**
     * Ask if really exit. Uses boolean Printer::dirty. Sets boolean do_abort_now.
     * @return boolean true if user really wants to abort
     */
    define boolean reallyExit ()``{
        if (!Printer::dirty)
            {
                return true;
            }
	return Popup::AnyQuestion( Popup::NoHeadline(),
// question popup
_("Really leave printer configuration without saving?
All changes will be lost.
"),
                                      Label::YesButton(),
                                      Label::NoButton(),
                                      `focus_no );

    }

    /**
     * Get list of available devices in nice-names.
     * @param devices list of devices to show
     * @param device device that should be selected. If "" then first device will be selected.
     * @return list Items for selection box. One of the items is selected.
     */
    define list getDevicesItems (list devices, string device) ``{
	list device_val = [];
	boolean default_selected = false;
	foreach (string dev, devices, ``{
	    boolean this_is_selected = (("" != device && dev == device)
					 || ("" == device && (
					    dev == "/dev/lp0"
					    || dev == "/dev/usblp0"
					    || dev == "/dev/usb/lp0"
					    || dev == "/dev/ttyS0")));
	    if (this_is_selected)
		default_selected = true;
	    device_val = add (device_val, `item (`id (dev), Printerlib::getDeviceNiceName (dev, false), this_is_selected));
	});
	if (!default_selected)
	    device_val = add (device_val, `item (`id (device), device, true));
	return device_val;
    }
    /**
     * Create the content of table of all entries in the printcap.
     * @return List of items. Item id is index of printer in printcap.
     */
    define list printcapTable () ``{
	integer count = 0;
	Printer::sortPrinters ();
	return maplist (map ent, Printer::printcap, ``{
		string name = lookup (ent, "name", "???");
		term ret =
		    `item (
			`id (count),
			name == Printer::default ? UI::Glyph (`BulletArrowRight) : " ",
			lookup (ent, "name", ""));

		if ("yast2" == lookup (ent, "type", "yast2"))
		{
		    string description = Printerlib::getUriNiceName (lookup (ent, "uri", ""));
		    if (! ent["valid"]:true)
			// table item. SHORT!
			description = _("- invalid for selected spooler -");
		    ret = add (ret, description);
		}
		else
		    // This printer was not configured using YaST2. Item in table. SHORT!
		    ret = add (ret, _("- not YaST2 -"));
		if (Spooler::Get () == "cups" || Spooler::Get () == "lprng")
		{
		    if ("yast2" == lookup (ent, "type", "yast2"))
			// table item. SHORT
			ret = add (ret, ! ent["changed"]:false ? _("OK") : "");
		    else
			// table item. SHORT
			ret = add (ret, _("unknown"));
		}
		count = count+1;
		return ret;
	});
    }

    /**
      * Is the name of local queue correct? If not, display message.
      * @param name string queue name
      * @param forbidden_names list of forbidden names
      * @return boolean true if correct
      */
    define boolean checkLocalQueueName (string name, list forbidden_names) ``{
	if (size (name) > 0 && size (name) < 32 &&
	    size (filterchars (substring (name, 0, 1),
		"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")) > 0 &&
	    name == filterchars (name,
		"_0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
	    && ! contains (forbidden_names, name))
	    {
		if (contains (Spooler::getSystemForbiddenNames (), name))
		{
		    // message box
		   Popup::Message (_("Invalid queue name. The name must not be used
for any file in directory /etc/lpdfilter"));
		   return false;
		}
		return true;
	    }
	    else
	    {
		// popup
		 Popup::Message (_("Invalid queue name. It must be
shorter than 32 characters, start with a letter,
and only contain 0...9, A...Z, a...z, and _."));
		return false;
	    }
    }

    /**
     * Is the name of the remote printer correct? If not, display message.
     * @param name Hostname to check
     * @return boolean true if hostname is correct.
     */
    define boolean checkQueueName (string name) ``{
	if (size (name) > 0 && /*size (name) < 30 &&
	    size (filterchars (substring (name, 0, 1),
		    "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")) > 0 &&*/
	    "" == filterchars (name,
				"@:"))
	    {
		return true;
	    }
	else
	    {
		// message box
		Popup::Message (_("Invalid remote queue name. 
It cannot contain the characters @ and :.
"));
	    }
	return false;
    }

    /**
      * Creates UI widgets from values.
      * @param option_type string type of the option
      *  (pick_one, pick_many, boolean)
      * @param values list values
      * @return UI representation of vals
      */
    define term getWidgetForOption (string option_type, list values) ``{
	if (option_type == "Boolean")
	{
	    list vals = (list) values;
	    if (size (vals) != 2)
	    {
		y2error (
		    "Incorrect size of possible values for boolean option: %1",
		    vals);
	    }
	    list r_buttons = maplist (list entry, vals, ``(
		`Left (`RadioButton (`id (entry[0]:""), entry[1]:""))
	    ));
	    term ret = `VBox (`VSpacing (1));
	    foreach (term button, r_buttons, ``{
		ret = add (ret, button);
	    });
	    ret = add (ret, `VSpacing (1));
	    ret = `HBox (
		`HSpacing (3),
		`RadioButtonGroup (`id (`vals), `opt (`notify,`immediate), ret),
		`HSpacing (3)
	    );
	    // frame
	    ret = `Frame (_("Value:"), ret);
	    ret = `HBox (
		`HStretch (),
		`VBox (
		    `VStretch (),
		    ret,
		    `VStretch ()
		),
		`HStretch ()
	    );
	    return ret;
	}
	if (option_type == "PickMany")
	{
	    list vals = (list) values;
	    // multiselectionbox label
	    return `MultiSelectionBox(`id (`vals), `opt (`notify, `immediate),
		_("Val&ues"),
		maplist (list entry, vals, ``(
		    `item (`id (entry[0]:""), entry[1]:"")
		))
	    );
	}
	list vals = (list) values;
	y2debug ("value: %1", values);
	// selectionbox label
	return `SelectionBox (`id (`vals), `opt (`notify, `immediate),
	    _("Val&ues"),
	    maplist (list entry, vals, ``(
		`item (`id (entry[0]:""), entry[1]:"")
	    ))
	);
    }

    /**
     * Remove characters that are not allowed by ieee1284.
     * @param id string to check
     * @return string updated string
     */
    define string filter1284 (string id) ``{
	return filterchars (tolower (id), "abcdefghijklmnopqrstuvwxyz0123456789_+/");
    }

    /**
     * Compare saved gs_upp file with the generated one.
     * @param file1 contents of one upp file
     * @param file2 contents of the other upp file
     * @return boolean true if files are the same
     */
    define boolean diffUppFiles (string file1, string file2) ``{
	// save files
	string tmpdir = (string)SCR::Read (.target.tmpdir);
	SCR::Write (.target.string, tmpdir + "/options1.upp", file1);
	SCR::Write (.target.string, tmpdir + "/options2.upp", file2);
	// diff files
	boolean changed = (0 == SCR::Execute (.target.bash, sformat ("/usr/bin/diff -w -B %1/options1.upp %1/options2.upp", tmpdir)));
	// delete files
	SCR::Execute (.target.bash, sformat ("/bin/rm %1/options1.upp %1/options2.upp", tmpdir));
	return changed;
    }
    /**
     * Looks if selected options contain paper size.
     * @param selected currently selected options
     * @return true if they contain paper size
     */
    define boolean havePaperSize (map selected) ``{
	boolean found = false;
	foreach (string k, any v, selected, ``{
	    if (substring (k, 0, 10) == "papersize-")
		found = true;
	});
	return found;
    }









}
