/**
 * File:
 *  misc.ycp
 *
 * Module:
 *  Printer configurator
 *
 * Summary:
 *  Miscelaneous defines.
 *
 * Authors:
 *  Petr Blahos <pblahos@suse.cz>
 *  Jiri Srain <jsrain@suse.cz>   2002
 *
 * $Id$
 *
 * Miscelaneous defines.
 */

{
    textdomain "printer";

    import "Console";
    import "CUPS";
    import "Label";
    import "Mode";
    import "Popup";
    import "Printer";
    import "Printerdb";
    import "Printerlib";
    import "Spooler";
    import "Wizard";

    /**
      * Get auto queues for printer when using foomatic database
      * @param vendor string vendor db key
      * @param model string model db key
      * @param config string choosen ppd file, nil = auto
      * @return list of PPD files
      */
    global define list getFoomaticAutoQueues (string vendor, string model,
        string config)
    ``{
        list forbidden_names = Printer::getForbiddenNames ();
        y2debug ("Getting auto queues for >>%1<< >>%2<<", vendor, model);
        Printerdb::loadFoomaticIfNeeded ();
        list new_queues = [];
        map ppds = Printerdb::getPpdFiles (vendor, model);
        string ppdfile_orig = "";
        if (vendor == "__ownppd__")
            ppdfile_orig = model;
        else if (config == nil || config == "")
            ppdfile_orig = Printerdb::getAutoPpdFile (ppds, vendor, model);
        else
            ppdfile_orig = Printerdb::foomatic[vendor, model, config, "filename"]:"";
        y2debug ("Choosen PPD file: %1", ppdfile_orig);
        string config = ppds[ppdfile_orig]:"";
        string ppdfile = SCR::Read (.ppd.file.open,
            [ppdfile_orig, SCR::Read (.target.tmpdir)]);
        map options = SCR::Read (.ppd.file.options, [ppdfile, ""]);
        list opts = options["data"]:[];
            integer ind = -1;
            boolean found = true;
            find (`i, opts, ``{
                ind = ind + 1;
                found = i["name"]:"" == "PrintoutMode";
                return found;
            });
            map composite = $[];
            if (found)
                composite = opts[ind]:$[];
            if (composite != $[])
            {
                foreach (`v, composite["valorder"]:[], ``{
                    string optname = composite["name"]:"";
                    string pagesize = Printerlib::getDefaultPaperSize () == `a4 ? "A4" : "Letter";
                    map new_options = $[
                        optname : v,
                        "PageSize" : pagesize,
                        "PageRegion" : pagesize,
                        "ImageableArea" : pagesize,
                        "PaperDimension" : pagesize,
                    ];
                    new_queues = add (new_queues, $[
                        "config" : config,
                        "name" : mergestring (splitstring
                            (tolower (v), "."), "_"),
                        "info" : composite["values", v]:v,
                        "options" : new_options,
                        "composite" : composite["name"]:"",
                    ]);

                });
            }
            else
            {
                new_queues = [ $[
                    "config" : config,
                    "name" : "lp",
                        // table cell
                    "info" : _("default configuration"),
// TODO FIXME: page size
                ]];
            }
            string suffix = Printer::getQueueSuffix (new_queues);

            new_queues = maplist (`v, new_queues, ``{
                v = add (v, "name", Printer::adjustQueueName (lookup (v, "name", "lp") + suffix, forbidden_names));
                if (nil == first_queue)
                {
                    first_queue = lookup (v, "name", "");
                }
                forbidden_names = add (forbidden_names, lookup (v, "name", ""));
                return union (Printer::printer, v);
        });
        y2debug ("Proposing queues %1", maplist (`q, new_queues, ``(q["name"]:"")));
        y2debug ("Proposed queues: %1", new_queues);
        return new_queues;
    }


    /**
      * Sort items according to locale
      * @param items map items (item key -> item label)
      * @return list of items to be used for selectionbox
      */
    global define list sortitems (map items) ``{
	string enc = Console::encoding;
	items = mapmap (`k, `v, items, ``(
	    [k, UI::Recode ("UTF-8", enc, v)]));
	list l = SCR::Read (.ppd.sort_items, items);
	l = maplist (`i, l, ``{
	    string label = select (i, 1, "");
	    label = UI::Recode (enc, "UTF-8", label);
	    i = remove (i, 2);
	    i = add (i, label);
	    return i;
	});
	return l;
    }

    /**
      * Check if paper size is set and if not, then set the defaul
      * Don't change if already set
      * @param p map of printer to adjust paper size
      * @return map of printer with adjusted paper size
      */
    global define map adjustPaperSize (map p) ``{
	map options = p["options"]:$[];
	if (haskey (options, "PageSize"))
	    return p;
	string pagesize = Printerlib::getDefaultPaperSize () == `a4 ? "A4" : "Letter";
	options["PageSize"] = pagesize;
	options["PageRegion"] = pagesize;
	options["ImageableArea"] = pagesize;
	options["PaperDimension"] = pagesize;
	p["options"] = options;
	return p;
    }


    /**
      * replaces all occurences of 'from' to 'to' in src
      * @param src input string
      * @param from string to be replaced
      * @param to string to be replaced by
      * @return string modified string
      */
    global define string replaceAll(string src, string from, string to) ``{
        if (from == "")
        {
            return src;
        }

        list tokens = [];

        integer p = find(src, from);
        while(p >= 0)
        {
            tokens = add(tokens, substring(src, 0, p));
            src = substring(src, p + size(from), size(src) - (p+size(from)));
            p = find(src, from);
        }
        tokens = add(tokens, src);
        return mergestring(tokens, to);
    }

    /**
      * Get printers (physical devices), which are configured
      * @return a list of printers maps (one queue of each printer)
      */
    global define list(map) getConfiguredPrinters () ``{
        list(string) ukeys = [];
        list(string) uris = [];
	list(string) models = [];
	list(map) printers = [];

        foreach (`p, Printer::printcap, ``{
            string ukey = p["unique_key"]:"";
            string uri = p["uri"]:"";
	    string model = p["ownppd"]:"";
	    if (model == "")
		model = p["vendor_ieee"]:"" + p["device_ieee"]:"";
	    if (model == "")
		model = p["vendor_db"]:"" + p["device_db"]:"";
            if ((! contains (ukeys, ukey)
		    && (! contains (uris, uri))
			|| ! contains (models, model)
		    )
		&& (model != "" && uri != ""))
            {
                uris = add (uris, uri);
                if (ukey != "")
                    ukeys = add (ukeys, ukey);
		models = add (models, model);
                printers = add (printers, p);
            }
        });

	return printers;
    }

    /**
      * List all queues of specified printer
      * @param uri of printer
      * @param vendor string printer vendor name
      * @param device string printer model name
      * @return a list of maps of queues
      */
    global define list(map) getQueuesOfPrinter (string uri, string vendor,
	string device)
    ``{
	list(map) queues = filter (`p, Printer::printcap, ``(
	    p["uri"]:"" == uri &&
		((p["vendor_db"]:"" == vendor && p["device_db"]:"" == device)
		||(p["vendor_ieee"]:"" == vendor && p["device_ieee"]:"" == device))
	    ));
	return queues;
    }

    /**
      * Has a printer (physical) been already configured (contains at least
      * one queue?
      * @param printer map containing at least vendor, device and
      *   unique_key keys for comparsionprinter vendor
      * @return boolean true if already configured
      */
    global define boolean isPrinterConfigured (map printer) ``{
	string vendor_db = printer["vendor_db"]:"";
	string device_db = printer["device_db"]:"";
	string vendor_ieee = printer["vendor_ieee"]:"";
	string device_ieee = printer["device_ieee"]:"";
	string ukey = printer["unique_key"]:"";
	string uri = printer["uri"]:"";
	if (uri == "")
	    uri = printer["bus"]:"parallel" + ":" + printer["dev_name"]:"";
	boolean exists = false;

	foreach (`p, Printer::printcap, ``{
	    if ((p["unique_key"]:"" == ukey && ukey != "")
		|| (p["uri"]:"" == uri && uri != ""
		    && ((p["vendor_db"]:".." == vendor_db
			    && p["device_db"]:".." == device_db)
			|| (p["vendor_ieee"]:".." == vendor_ieee
			    && p["device_ieee"]:".." == device_ieee))
		   ))
	    {
		exists = true;
	    }
	});
	return exists;
    }


    /**
     * Reinstall all printing related packages using package-manager
     * @return boolean true if success
     */
    global define boolean reinstallAll () ``{
	if (Mode::config)
	{
	    Printerlib::DisplayUnavailableAIPopup ();
	    return true;
	}
	import "PackageCallbacks";
	Printer::printcap = [];
	Printer::default = "";
	Spooler::save_all = false;

	Spooler::StopServices();
	list to_delete = ["plp", "lprold", "lprng", "cups", "cups-client", "cups-drivers", "cups-drivers-cs", "cups-drivers-de", "cups-drivers-stp",
	    "cups-libs", "cups-devel", "lpdfilter", "filters", "ghostscript-fonts-other", "ghostscript-x11", "ghostscript-fonts-std", "ghostscript-library",
	    "ghostscript-fonts-kanji", "ghostscript-serv", "ghostscript-fonts-rus", "ghostscript-library", "a2ps", "foomatic-filters"];
	to_delete = filter (`e, to_delete, ``(Pkg::IsProvided (e) == true));

	list to_install = ["ghostscript-library", "ghostscript-x11", "ghostscript-fonts-std", "ghostscript-fonts-other", "a2ps", "cups-libs"];

	y2milestone("deleting: %1", to_delete);
	foreach (`e, to_delete, ``{Pkg::PkgDelete (e);});
	Pkg::PkgCommit (0);
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/cups/");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/lpdfilter/");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/printcap");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/printcap.rpm*");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/printcap-2*");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/printcap.y2*");
	SCR::Execute (.target.bash, "/bin/rm -rf /var/spool/lpd/");
	SCR::Execute (.target.bash, "/bin/rm -rf /var/spool/cups/");
	SCR::Execute (.target.bash, "/bin/rm -rf /var/lib/YaST2/printers");

	foreach (`e, to_install, ``{Pkg::PkgInstall (e);});

	y2milestone("installing: %1", to_install);
	Pkg::PkgSolve ();
	Pkg::PkgCommit (0);
	Wizard::CreateDialog ();
	WFM::CallModule("inst_suseconfig", []);
	Wizard::CloseDialog ();

	return true;

    }
    /**
     * Get hosts available on local network. Reads from .net.hostnames. Shows popup window: Wait please.
     * @param type "ipp", "samba", "lpd" or ""
     * @return list Sorted list of hosts.
     */
    global define list getHostnames (string type) ``{
        UI::OpenDialog (`opt (`decorated),
                         // text in dialog box
                         `Label (_("Scanning for hosts on this LAN...")));
        list hosts = [];
        if ("samba" == type)
            hosts = SCR::Read (.net.hostnames.samba);
        else if ("ipp" == type)
	{
            hosts = SCR::Read (.net.hostnames, 631);
	    hosts = filter (`h, hosts, ``{
		list queues = SCR::Read (.cups.remote, h);
		return size (queues) > 0;
	    });
	}
        else if ("lpd" == type)
            hosts = SCR::Read (.net.hostnames, 515);
        else if ("socket" == type)
            hosts = SCR::Read (.net.hostnames, 9100);
        else if ("" != type)
	    hosts = SCR::Read (.net.hostnames, tointeger (type));
	else
            hosts = SCR::Read (.net.hostnames);
        if (nil == hosts)
            hosts = [];
        UI::CloseDialog ();
        return sort (hosts);
    }

    /**
      * Get hosts available on local network via listening to IPP broadcasts
      * @return list Sorted list of hosts
      */
    global define list listenCupsServers () ``{
	integer status = SCR::Execute (.target.bash, "/etc/init.d/cups status");
	if (0 == status)
	    SCR::Execute (.target.bash, "/etc/init.d/cups stop");

	SCR::Execute(.target.bash_background,
	    "/usr/lib/YaST2/bin/listen_remote_ipp 30");
	sleep (1000);
	string pid = nil;
	if (SCR::Read (.target.size, "/var/run/listen_remote_ipp.pid") > 0)
	{
	    pid = SCR::Read (.target.string, "/var/run/listen_remote_ipp.pid");
	}
	boolean abort_server = false;
	if (pid != nil)
	{
	    y2milestone ("Scanning for CUPS server in progress");
	    SCR::Execute (.target.bash, sformat ("kill -1 %1", pid));
	    boolean runs = true;
	    boolean displayed = false;
	    integer counter = 0;
	    while (runs)
	    {
		if (counter == 10)
		{
		    displayed = true;
		    UI::OpenDialog (`VBox (`Label (
			// label
			_("Detecting CUPS network server...")),
			`PushButton (`id (`abort), `opt (`key_F9),
			    Label::AbortButton ())));

		}
		sleep (100);
		runs = SCR::Read (.target.size,
		    "/var/run/listen_remote_ipp.pid") > 0;
		counter = counter + 1;
		if (displayed)
		{
		    any ui = UI::PollInput ();
		    if (ui == `abort)
		    {
			SCR::Execute (.target.bash,
			    sformat ("kill -15 %1", pid));
			runs = false;
			abort_server = true;
		    }
		}
	    }
	    if (displayed)
		UI::CloseDialog ();
	}

	Printer::cups_servers = [];
	if (SCR::Read (.target.size,
	    "/var/lib/YaST2/cups_network_server_name") != -1)
	{
	    y2milestone ("File with CUPS servers found");
	    if (! abort_server)
	    {
		string tmp = SCR::Read (.target.string,
		    "/var/lib/YaST2/cups_network_server_name");
		Printer::cups_servers = splitstring (tmp, "\n");
		Printer::cups_servers = toset (Printer::cups_servers);
		Printer::cups_servers = filter (`s, Printer::cups_servers, ``(
		    s != "" && s != nil));
	     }
	}
	if (0 == status)
	    SCR::Execute (.target.bash_background, "/etc/init.d/cups start");
	return Printer::cups_servers;
    }


    /**
     * Return list without item.
     * @param source source list
     * @param item item to delete
     * @return list List without item. If item was not present in list, list is unchanged.
     */
    global define list DeleteItem (list source, any item) ``{
        return filter (`i, source, ``{
            return i != item;
        });
    }
    /**
     * Displays message when baud rate is 0.
     * @param brate Baud rate.
     * @return boolean Is baud rate ok?
     */
    global define boolean testBaudRate (integer brate) ``{
	if (brate == 0)
	    {
		// message box
		Popup::Message (_("The baud rate should not be 0!"));
		return false;
	    }
	return true;
    }
    /**
     * Is the hostname correct? Check it for allowed characters. Display message if bad hostname.
     * @param name Hostname to check
     * @return boolean true if hostname is correct.
     */
    global define boolean checkHostName (string name) ``{
	if (size (name) > 0 &&
	    /*size (name) < 50 &&*/
	    "" == filterchars (name,
				":/@"))
	    {
		return true;
	    }
	else
	    {
		// message box
		// the ',' character isn't separator,
		//  but one of a list of characters
		Popup::Message (_("Invalid host name. It must be
shorter than fifty characters and cannot contain
:, / or @.
"));
	    }
	return false;
    };

   /**
     * Is the username correct? Check it for allowed characters. Display message if bad username.
     * @param name Username to check
     * @return boolean true if username is correct.
     */
    global define boolean checkUserName (string name) ``{
        if (/*size (name) > 0 &&
            size (name) < 50 &&*/
            "" == filterchars (name,
                                ":/@"))
            {
                return true;
            }
        else
            {
                // message box
                // the ',' character isn't separator,
                //  but one of a list of characters
                Popup::Message (_("Invalid user name. It cannot 
contain the characters : , / @.
"));
            }
        return false;
    };

   /**
     * Is the password correct? Check it for allowed characters. Display message if bad password.
     * @param name password to check
     * @return boolean true if hostname is correct.
     */
    global define boolean checkPassword (string name) ``{
        if (/*size (name) > 0 &&
            size (name) < 50 &&*/
            "" == filterchars (name,
                                ":/@"))
            {
                return true;
            }
        else
            {
                // message box
                // the ',' character isn't separator,
                //  but one of a list of characters
                Popup::Message (_("Invalid password. It cannot 
contain the characters : , / @.
"));
            }
        return false;
    };



    /**
     * Check if remote_printer is not nil. Display message otherwise.
     * @param remote_printer Printer name to check
     * @return boolean true if name is OK
     */
    global define boolean checkRemotePrinter (string remote_printer) ``{
	if ("" != remote_printer)
	    {
		return true;
	    }
	// message box
	Popup::Message ( _("Please choose which forwarding
queue you want to use."));
	return false;
    };

    /**
      * generate class name
      * @param forbidden_names list of forbidden names
      * @return new class name
      */
    global define string generateClassName (list forbidden_names) ``{
	string name = "class1";
	integer i = 2;
	while (contains (forbidden_names, name))
	{
	    name = sformat ("class%1", i);
	    i = i + 1;
	}
	return name;
    }

    /**
     * Ask if really abort. Uses boolean Printer::dirty. Sets boolean do_abort_now.
     * @return boolean true if user really wants to abort
     */
    global define boolean reallyAbort ()``{
	boolean abort_now = false;
	if (abort_now || !Printer::dirty)
	    {
		return true;
	    }
	abort_now = Popup::ReallyAbort (true);
	return abort_now;
    }

    /**
     * Ask if really exit. Uses boolean Printer::dirty. Sets boolean do_abort_now.
     * @return boolean true if user really wants to abort
     */
    global define boolean reallyExit ()``{
        if (!Printer::dirty)
            {
                return true;
            }
	return Popup::AnyQuestion( Popup::NoHeadline(),
// question popup
_("Really leave printer configuration without saving?
All changes will be lost.
"),
                                      Label::YesButton(),
                                      Label::NoButton(),
                                      `focus_no );

    }

    /**
     * Get list of available devices in nice-names.
     * @param dev list of devices to show
     * @param device device that should be selected. If "" then first device will be selected.
     * @return list Items for selection box. One of the items is selected.
     */
    global define list getDevicesItems (list dev, string device) ``{
	list device_val = [];
	boolean default_selected = false;
	foreach (`dev, devices, ``{
	    boolean this_is_selected = (("" != device && dev == device) ||
					("" == device && (dev == "/dev/lp0" ||
							  dev == "/dev/usblp0" ||
							  dev == "/dev/usb/lp0" ||
							  dev == "/dev/ttyS0")));
	    if (this_is_selected)
		default_selected = true;
	    device_val = add (device_val, `item (`id (dev), Printerlib::getDeviceNiceName (dev, false), this_is_selected));
	});
	if (!default_selected)
	    device_val = add (device_val, `item (`id (device), device, true));
	return device_val;
    }
    /**
     * Create the content of table of all entries in the printcap.
     * @return List of items. Item id is index of printer in printcap.
     */
    global define list printcapTable () ``{
	integer count = 0;
	Printer::sortPrinters ();
	return maplist (`ent, Printer::printcap, ``{
		string name = lookup (ent, "name", "???");
		term ret =
		    `item (
			`id (count),
			name == Printer::default ? UI::Glyph (`BulletArrowRight) : " ",
			lookup (ent, "name", ""));

		if ("yast2" == lookup (ent, "type", "yast2"))
		{
		    string description = Printerlib::getUriNiceName (lookup (ent, "uri", ""));
		    if ("void" == Printer::getPrinterState (ent, Spooler::Get ()))
			// table item. SHORT!
			description = _("- invalid for selected spooler -");
		    ret = add (ret, description);
		}
		else
		    // This printer was not configured using YaST2. Item in table. SHORT!
		    ret = add (ret, _("- not YaST2 -"));
		if (Spooler::Get () == "cups" || Printer::spooler == "lprng")
		{
		    if ("yast2" == lookup (ent, "type", "yast2"))
			// table item. SHORT
			ret = add (ret, "commited" == Printer::getPrinterState (ent, Spooler::Get ()) ? _("OK") : "");
		    else
			// table item. SHORT
			ret = add (ret, _("unknown"));
		}
		else
		{
			// table item. SHORT
		    ret = add (ret, "void" != Printer::getPrinterState (ent, "cups") ? _("OK") : "");
			// table item. SHORT
		    ret = add (ret, "void" != Printer::getPrinterState (ent, "lprng") ? _("OK") : "");
		}
		count = count+1;
		return ret;
	});
    }

    /**
      * Is the name of local queue correct? If not, display message.
      * @param name string queue name
      * @param forbidden_names list of forbidden names
      * @return boolean true if correct
      */
    global define boolean checkLocalQueueName (string name, list forbidden_names) ``{
	if (size (name) > 0 && size (name) < 32 &&
	    size (filterchars (substring (name, 0, 1),
		"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")) > 0 &&
	    name == filterchars (name,
		"_0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
	    && ! contains (forbidden_names, name))
	    {
		if (contains (Spooler::getSystemForbiddenNames (), name))
		{
		    // message box
		   Popup::Message (_("Invalid queue name. The name must not be used
for any file in directory /etc/lpdfilter"));
		   return false;
		}
		return true;
	    }
	    else
	    {
		// popup
		 Popup::Message (_("Invalid queue name. It must be
shorter than 32 characters, start with a letter,
and only contain 0...9, A...Z, a...z, and _."));
		return false;
	    }
    }

    /**
     * Is the name of the remote printer correct? If not, display message.
     * @param name Hostname to check
     * @return boolean true if hostname is correct.
     */
    global define boolean checkQueueName (string name) ``{
	if (size (name) > 0 && /*size (name) < 30 &&
	    size (filterchars (substring (name, 0, 1),
		    "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")) > 0 &&*/
	    "" == filterchars (name,
				"@:"))
	    {
		return true;
	    }
	else
	    {
		// message box
		Popup::Message (_("Invalid remote queue name. 
It cannot contain the characters @ and :.
"));
	    }
	return false;
    }

    /**
     * Get value from UI
     * @param vals values
     * @return selected value
     */
    global define any grabValueUI (any vals) ``{
	if (is (vals, list))
	{
	    return UI::QueryWidget (`id (`vals), `CurrentItem);
	}
	if (is (vals, term))
	{
	    if (`text == symbolof (vals))
	    {
		string c = UI::QueryWidget (`id (`vals), `Value);
		return regexpsub (c, "(" + select (vals, 0, ".*") + ")", "\\1");
	    }
	    if (true == UI::QueryWidget (`id (`vals2), `Value))
	    {
		UI::ChangeWidget (`id (`vals), `Enabled, false);
		return nil;
	    }
	    UI::ChangeWidget (`id (`vals), `Enabled, true);
	    if (`int == symbolof (vals))
	    {
		integer i = UI::QueryWidget (`id (`vals), `Value);
		if (0 != select (vals, 2, 0))
		{
		    i = i - select (vals, 0, 0);
		    i = i / select (vals, 2, 1);
		    i = i * select (vals, 2, 1);
		    i = i + select (vals, 0, 0);
		    if (i < select (vals, 0, 0))
			i = select (vals, 0, 0);
		    if (i > select (vals, 1, select (vals, 0, 0) + 1))
			i = select (vals, 1, select (vals, 0, 0) + 1);
		}
		return i;
	    }
	    if (`float == symbolof (vals))
	    {
		float i = tofloat (UI::QueryWidget (`id (`vals), `Value));
		if (0 != select (vals, 2, 0))
		{
		    i = i - select (vals, 0, 0);
		    i = i / select (vals, 2, 1);
		    i = i * select (vals, 2, 1);
		    i = i + select (vals, 0, 0);
		    if (i < select (vals, 0, 0))
			i = select (vals, 0, 0);
		    if (i > select (vals, 1, select (vals, 0, 0) + 1))
			i = select (vals, 1, select (vals, 0, 0) + 1);
		}
		return i;
	    }
	}
	return nil;
    }
    /**
     * Creates UI widgets from values.
     * @param vals values
     * @return UI representation of vals
     */
    global define term getValuesUI (any vals) ``{
	if (is (vals,list))
	{
	    // selectionbox label
	    return `SelectionBox (`id (`vals), `opt (`notify), _("Val&ues"), vals);
	}
	if (!is (vals, term))
	    return `VStretch ();
	if (`text == symbolof (vals))
	{
	    // textentry label
	    term out = `TextEntry (`id (`vals), `opt (`notify), _("&Value:"), select (vals, 1, ""));
	    return `VBox (
		    `VStretch (),
		    out,
		    // label
		    `Right (`Label (sformat (_("Allowed characters: %1"), select (vals, 0, "")))),
		    `VStretch ());
	}
	if (`int == symbolof (vals))
	{
	    boolean not_used = (nil == select (vals, 4, nil) && nil == select (vals, 3, nil));
	    integer initial = select (vals, 4, nil);
	    if (nil == initial)
	    {
		initial = select (vals, 3, nil);
	    }
	    if (nil == initial)
	    {
		initial = select (vals, 0, nil);
	    }
	    term out = UI::HasSpecialWidget (`Slider) ?
		// slider
		`Slider (`id (`vals), not_used ? `opt (`notify, `disabled) : `opt (`notify), _("&Values")) :
		// int field
		`IntField (`id (`vals), not_used ? `opt (`hstretch, `notify, `disabled) : `opt (`notify), _("&Values"));
	    out = add (out, select (vals, 0, 0));
	    out = add (out, select (vals, 1, 0));
	    out = add (out, initial);
	    if (nil == select (vals, 3, nil))
	    {
		out = `VBox (
			`VStretch (),
			// check box
			`CheckBox (`id (`vals2), `opt (`hstretch, `notify), _("Not &set (use the driver default)"), not_used),
			out,
			// label
			`Label (`opt (`hstretch), sformat (_("Minimal value: %1\nMaximal value: %2\nStep: %3"),
				select (vals, 0, 0), select (vals, 1, 0), select (vals, 2, 0))),
			`VStretch ()
			);
	    }
	    else
	    {
		out = `VBox (
			`VStretch (),
			out,
			// label
			`Label (`opt (`hstretch), sformat (_("Minimal value: %1\nMaximal value: %2\nStep: %3"),
				select (vals, 0, 0), select (vals, 1, 0), select (vals, 2, 0))),
			`VStretch ()
			);
	    }
	    return out;
	}
	if (`float == symbolof (vals))
	{
	    boolean not_used = (nil == select (vals, 4, nil) && nil == select (vals, 3, nil));
	    float initial = select (vals, 4, nil);
	    if (nil == initial)
	    {
		initial = select (vals, 3, nil);
	    }
	    if (nil == initial)
	    {
		initial = select (vals, 0, nil);
	    }
	    term out = `TextEntry (`id (`vals),
		    not_used ? `opt (`disabled, `hstretch, `notify) :
			// textentry label
		    `opt (`hstretch, `notify), _("&Values"), sformat ("%1", initial));
	    if (nil == select (vals, 3, nil))
	    {
		out = `VBox (
			`VStretch (),
			// checkbox
			`CheckBox (`id (`vals2), `opt (`hstretch, `notify), _("Not &set (use the driver default)"), not_used),
			out,
			// label
			`Label (`opt (`hstretch), sformat (_("Minimal value: %1\nMaximal value: %2\nStep: %3"),
				select (vals, 0, 0), select (vals, 1, 0), select (vals, 2, 0))),
			`VStretch ()
			);
	    }
	    else
	    {
		out = `VBox (
			`VStretch (),
			out,
			// label
			`Label (`opt (`hstretch), sformat (_("Minimal value: %1\nMaximal value: %2\nStep: %3"),
				select (vals, 0, 0), select (vals, 1, 0), select (vals, 2, 0))),
			`VStretch ()
			);
	    }
	    return out;
	}
	return `VStretch ();
    }
    /**
     * Remove characters that are not allowed by ieee1284.
     * @param id string to check
     * @return string updated string
     */
    global define string filter1284 (string id) ``{
	return filterchars (tolower (id), "abcdefghijklmnopqrstuvwxyz0123456789_+/");
    }

    /**
     * Compare saved gs_upp file with the generated one.
     * @param file1 contents of one upp file
     * @param file2 contents of the other upp file
     * @return boolean true if files are the same
     */
    global define boolean diffUppFiles (string file1, string file2) ``{
	// save files
	string tmpdir = SCR::Read (.target.tmpdir);
	SCR::Write (.target.string, tmpdir + "/options1.upp", file1);
	SCR::Write (.target.string, tmpdir + "/options2.upp", file2);
	// diff files
	boolean changed = (0 == SCR::Execute (.target.bash, sformat ("/usr/bin/diff -w -B %1/options1.upp %1/options2.upp", tmpdir)));
	// delete files
	SCR::Execute (.target.bash, sformat ("/bin/rm %1/options1.upp %1/options2.upp", tmpdir));
	return changed;
    }
    /**
     * Looks if selected options contain paper size.
     * @param selected currently selected options
     * @return true if they contain paper size
     */
    global define boolean havePaperSize (map selected) ``{
	boolean found = false;
	foreach (`k, `v, selected, ``{
	    if (substring (k, 0, 10) == "papersize-")
		found = true;
	});
	return found;
    }
    /**
      * get RadioButtonGroup for spooler selection
      * @param spooler string currently used spooler (cups, cups-client, lprng or current)
      * @param none boolean show leaving current status
      * @return term RadioButtonGroup widget
      */
    global define term getSpoolerItems (string spooler, boolean none) ``{
	return `RadioButtonGroup (
	    `id (`spooler),
	    `HBox (`HSpacing (1), `VBox (
		`VSpacing (1),
		`RadioButton (`id (`cups_server),
		    `opt (`hstretch, `notify),
		    // radiobutton
		    _("CUPS full &server installation"),
		    spooler == "cups"),
		`VSpacing (0.5),
		`RadioButton (`id (`cups_client),
		    `opt (`hstretch, `notify),
		    // radiobutton
		    _("CUPS &client-only installation"),
		    spooler == "cups-client"),
		`VSpacing (0.5),
		`RadioButton (`id (`lprng),
		    `opt (`hstretch, `notify),
		    // radiobutton
		    _("&LPRng"),
		    spooler == "lprng"),
		none ? `VSpacing (0.5) : `VSpacing (0),
		none ? `RadioButton (`id (`none),
		    `opt (`hstretch, `notify),
		    // radiobutton
		    _("L&eave current status"),
		    spooler == "current")
		    : `VSpacing (0),
		`VSpacing (1)
	     ), `HSpacing (1)
	));
    }

    /**
      * Shows a question to a user whether he wants the LPRng or CUPS spooler.
      * @param msg string to be displayed
      * @param abort_msg label of abort button
      * @return symbol specifying users selecion (lprng, cups, exit)
      */
    global define symbol chooseSpooler(string msg, string abort_msg)
    ``{
	symbol ret = `none_symbol;
	UI::OpenDialog (
            `VBox (
		`Label (msg),
		getSpoolerItems ("current", true),
		`HBox (
		    `HWeight (1, `PushButton (`id (`ok), `opt (`key_F10), Label::OKButton ())),
		    `HWeight (1, `PushButton (`id (`cancel), `opt (`key_F9), abort_msg))))
	);
	while (true)
	{
	    ret = UI::UserInput ();
	    if (ret == `ok || ret == `cancel)
		break;
	}
	if (`ok == ret)
	{
	    ret = UI::QueryWidget (`id (`spooler), `CurrentButton);
	}
	UI::CloseDialog();
	return ret;
    }










}
