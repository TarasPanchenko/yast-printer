/**
 * File:
 *  misc.ycp
 *
 * Module:
 *  Printer configurator
 *
 * Summary:
 *  Miscelaneous defines.
 *
 * Authors:
 *  Petr Blahos <pblahos@suse.cz>
 *  Jiri Srain <jsrain@suse.cz>   2002
 *
 * $Id$
 *
 * Miscelaneous defines.
 */

{
    textdomain "printer";

    import "Console";
    import "CUPS";
    import "Label";
    import "Mode";
    import "Popup";
    import "Printer";
    import "Printerdb";
    import "Printerlib";
    import "Spooler";
    import "Wizard";

    /**
      * Get auto queues for printer when using foomatic database
      * @param vendor string vendor db key
      * @param model string model db key
      * @param config string choosen ppd file, nil = auto
      * @return list of PPD files
      */
    global define list getFoomaticAutoQueues (string vendor, string model,
        string config)
    ``{
        list forbidden_names = Printer::getForbiddenNames ();
        y2debug ("Getting auto queues for >>%1<< >>%2<<", vendor, model);
        Printerdb::loadFoomaticIfNeeded ();
        list new_queues = [];
        map ppds = Printerdb::getPpdFiles (vendor, model);
        string ppdfile_orig = "";
        if (vendor == "__spec_ppd__")
            ppdfile_orig = model;
        else if (config == nil || config == "")
            ppdfile_orig = Printerdb::getAutoPpdFile (ppds, vendor, model);
        else
            ppdfile_orig = Printerdb::foomatic[vendor, model, config, "filename"]:"";
        y2debug ("Choosen PPD file: %1", ppdfile_orig);
        string config = ppds[ppdfile_orig]:"";
        string ppdfile = SCR::Read (.ppd.file.open,
            [ppdfile_orig, SCR::Read (.target.tmpdir)]);
	Printer::printer["ppd"] = ppdfile;
	Printer::printer["ppd_info"] = Printer::ppdInfo (ppdfile);
        map options = SCR::Read (.ppd.file.options, [ppdfile, ""]);
        list opts = options["data"]:[];
            integer ind = -1;
            boolean found = true;
            find (`i, opts, ``{
                ind = ind + 1;
                found = i["name"]:"" == "PrintoutMode";
                return found;
            });
            map composite = $[];
            if (found)
                composite = opts[ind]:$[];
		string pagesize = Printerlib::getDefaultPaperSize () == `a4
		    ? "A4"
		    : "Letter";
            if (composite != $[])
            {
                string optname = composite["name"]:"";
                foreach (`v, composite["valorder"]:[], ``{
                    map new_options = $[
                        optname : v,
                        "PageSize" : pagesize,
                        "PageRegion" : pagesize,
                        "ImageableArea" : pagesize,
                        "PaperDimension" : pagesize,
                    ];
                    new_queues = add (new_queues, $[
                        "name" : mergestring (splitstring
                            (tolower (v), "."), "_"),
                        "info" : composite["values", v]:v,
                        "ppd_options" : new_options,
                    ]);

                });
            }
            else
            {
                new_queues = [ $[
                    "name" : "lp",
                        // table cell
                    "info" : _("default configuration"),
		    "ppd_options" : $[
                        "PageSize" : pagesize,
                        "PageRegion" : pagesize,
                        "ImageableArea" : pagesize,
                        "PaperDimension" : pagesize,
		    ],
                ]];
            }
            string suffix = Printer::getQueueSuffix (new_queues);

            new_queues = maplist (`v, new_queues, ``{
                v = add (v, "name", Printer::adjustQueueName (lookup (v, "name", "lp") + suffix, forbidden_names));
                if (nil == first_queue)
                {
                    first_queue = lookup (v, "name", "");
                }
                forbidden_names = add (forbidden_names, lookup (v, "name", ""));
                return union (Printer::printer, v);
        });
        y2debug ("Proposing queues %1", maplist (`q, new_queues, ``(q["name"]:"")));
        y2debug ("Proposed queues: %1", new_queues);
        return new_queues;
    }


    /**
      * Sort items according to locale
      * @param items map items (item key -> item label)
      * @return list of items to be used for selectionbox
      */
    global define list sortitems (map items) ``{
	string enc = Console::encoding;
	items = mapmap (`k, `v, items, ``(
	    [k, UI::Recode ("UTF-8", enc, v)]));
	list l = SCR::Read (.ppd.sort_items, items);
	l = maplist (`i, l, ``{
	    string label = select (i, 1, "");
	    label = UI::Recode (enc, "UTF-8", label);
	    i = remove (i, 2);
	    i = add (i, label);
	    return i;
	});
	return l;
    }

    /**
      * Check if paper size is set and if not, then set the defaul
      * Don't change if already set
      * @param p map of printer to adjust paper size
      * @return map of printer with adjusted paper size
      */
    global define map adjustPaperSize (map p) ``{
	map options = p["options"]:$[];
	if (haskey (options, "PageSize"))
	    return p;
	string pagesize = Printerlib::getDefaultPaperSize () == `a4 ? "A4" : "Letter";
	options["PageSize"] = pagesize;
	options["PageRegion"] = pagesize;
	options["ImageableArea"] = pagesize;
	options["PaperDimension"] = pagesize;
	p["options"] = options;
	return p;
    }


    /**
      * replaces all occurences of 'from' to 'to' in src
      * @param src input string
      * @param from string to be replaced
      * @param to string to be replaced by
      * @return string modified string
      */
    global define string replaceAll(string src, string from, string to) ``{
        if (from == "")
        {
            return src;
        }

        list tokens = [];

        integer p = find(src, from);
        while(p >= 0)
        {
            tokens = add(tokens, substring(src, 0, p));
            src = substring(src, p + size(from), size(src) - (p+size(from)));
            p = find(src, from);
        }
        tokens = add(tokens, src);
        return mergestring(tokens, to);
    }

    /**
      * Get printers (physical devices), which are configured
      * @return a list of printers maps (one queue of each printer)
      */
    global define list(map) getConfiguredPrinters () ``{
        list(string) ukeys = [];
        list(string) uris = [];
	list(string) models = [];
	list(map) printers = [];

        foreach (`p, Printer::printcap, ``{
            string ukey = p["unique_key"]:"";
            string uri = p["uri"]:"";
	    string ppd_file = p["ppd"]:"";
	    map ppd_info = Printer::ppdInfo (ppd_file);
	    string model = ppd_info["manufacturer"]:"" + ppd_info["model"]:"";
	    if (model == "")
	    {
		model = ppd_info["manufacturer_db"]:""
		    + ppd_info["model_db"]:"";
	    }
            if ((! contains (ukeys, ukey)
		    && (! contains (uris, uri))
			|| ! contains (models, model)
		    )
		&& (model != "" && uri != ""))
            {
                uris = add (uris, uri);
                if (ukey != "")
                    ukeys = add (ukeys, ukey);
		models = add (models, model);
                printers = add (printers, p);
            }
        });

	return printers;
    }

    /**
      * Has a printer (physical) been already configured (contains at least
      * one queue?
      * @param manuf string manufacturer of the printer
      * @param model string model of the printer
      * @param uri string URI of the printer
      * @param unique_key string unique_key of the printer
      * @return boolean true if already configured
      */
    global define boolean isPrinterConfigured (string manuf, string model,
	string uri, string unique_key)
    ``{
	string manuf_db = SCR::Read (.ppd.db.vendorname, manuf);
	string model_db = SCR::Read (.ppd.db.modelname, [manuf_db, model]);
	boolean exists = false;

	foreach (`p, Printer::printcap, ``{
	    if ((p["unique_key"]:"" == unique_key && unique_key != "")
		|| (p["uri"]:"" == uri && uri != ""
		    && ((p["ppd_info", "manufacturer_db"]:".." == manuf_db
			    && p["ppd_info", "model_db"]:".." == model_db)
			|| (p["ppd_info", "manufacturer"]:".." == manuf
			    && p["ppd_info", "model"]:".." == model))
		   ))
	    {
		exists = true;
	    }
	});
	return exists;
    }


    /**
     * Reinstall all printing related packages using package-manager
     * @return boolean true if success
     */
    global define boolean reinstallAll () ``{
	if (Mode::config)
	{
	    Printerlib::DisplayUnavailableAIPopup ();
	    return true;
	}
	import "PackageCallbacks";
	Printer::printcap = [];
	Printer::default = "";
	Spooler::save_all = false;

	Spooler::StopServices();
	list to_delete = ["plp", "lprold", "lprng", "cups", "cups-client", "cups-drivers", "cups-drivers-cs", "cups-drivers-de", "cups-drivers-stp",
	    "cups-libs", "cups-devel", "lpdfilter", "filters", "ghostscript-fonts-other", "ghostscript-x11", "ghostscript-fonts-std", "ghostscript-library",
	    "ghostscript-fonts-kanji", "ghostscript-serv", "ghostscript-fonts-rus", "ghostscript-library", "a2ps", "foomatic-filters"];
	to_delete = filter (`e, to_delete, ``(Pkg::IsProvided (e) == true));

	list to_install = ["ghostscript-library", "ghostscript-x11", "ghostscript-fonts-std", "ghostscript-fonts-other", "a2ps", "cups-libs"];

	y2milestone("deleting: %1", to_delete);
	foreach (`e, to_delete, ``{Pkg::PkgDelete (e);});
	Pkg::PkgCommit (0);
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/cups/");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/lpdfilter/");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/printcap");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/printcap.rpm*");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/printcap-2*");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/printcap.y2*");
	SCR::Execute (.target.bash, "/bin/rm -rf /var/spool/lpd/");
	SCR::Execute (.target.bash, "/bin/rm -rf /var/spool/cups/");
	SCR::Execute (.target.bash, "/bin/rm -rf /var/lib/YaST2/printers");

	foreach (`e, to_install, ``{Pkg::PkgInstall (e);});

	y2milestone("installing: %1", to_install);
	Pkg::PkgSolve ();
	Pkg::PkgCommit (0);
	Wizard::CreateDialog ();
	WFM::CallModule("inst_suseconfig", []);
	Wizard::CloseDialog ();

	return true;

    }
    /**
     * Get hosts available on local network. Reads from .net.hostnames. Shows popup window: Wait please.
     * @param type "ipp", "samba", "lpd" or ""
     * @return list Sorted list of hosts.
     */
    global define list getHostnames (string type) ``{
        UI::OpenDialog (`opt (`decorated),
                         // text in dialog box
                         `Label (_("Scanning for hosts on this LAN...")));
        list hosts = [];
        if ("samba" == type)
            hosts = SCR::Read (.net.hostnames.samba);
        else if ("ipp" == type)
	{
            hosts = SCR::Read (.net.hostnames, 631);
	    hosts = filter (`h, hosts, ``{
		list queues = SCR::Read (.cups.remote, h);
		return size (queues) > 0;
	    });
	}
        else if ("lpd" == type)
            hosts = SCR::Read (.net.hostnames, 515);
        else if ("socket" == type)
            hosts = SCR::Read (.net.hostnames, 9100);
        else if ("" != type)
	    hosts = SCR::Read (.net.hostnames, tointeger (type));
	else
            hosts = SCR::Read (.net.hostnames);
        if (nil == hosts)
            hosts = [];
        UI::CloseDialog ();
        return sort (hosts);
    }

    /**
      * Get hosts available on local network via listening to IPP broadcasts
      * @return list Sorted list of hosts
      */
    global define list listenCupsServers () ``{
	integer status = SCR::Execute (.target.bash, "/etc/init.d/cups status");
	if (0 == status)
	    SCR::Execute (.target.bash, "/etc/init.d/cups stop");

	SCR::Execute(.target.bash_background,
	    "/usr/lib/YaST2/bin/listen_remote_ipp 30");
	sleep (1000);
	string pid = nil;
	if (SCR::Read (.target.size, "/var/run/listen_remote_ipp.pid") > 0)
	{
	    pid = SCR::Read (.target.string, "/var/run/listen_remote_ipp.pid");
	}
	boolean abort_server = false;
	if (pid != nil)
	{
	    y2milestone ("Scanning for CUPS server in progress");
	    SCR::Execute (.target.bash, sformat ("kill -1 %1", pid));
	    boolean runs = true;
	    boolean displayed = false;
	    integer counter = 0;
	    while (runs)
	    {
		if (counter == 10)
		{
		    displayed = true;
		    UI::OpenDialog (`VBox (`Label (
			// label
			_("Detecting CUPS network server...")),
			`PushButton (`id (`abort), `opt (`key_F9),
			    Label::AbortButton ())));

		}
		sleep (100);
		runs = SCR::Read (.target.size,
		    "/var/run/listen_remote_ipp.pid") > 0;
		counter = counter + 1;
		if (displayed)
		{
		    any ui = UI::PollInput ();
		    if (ui == `abort)
		    {
			SCR::Execute (.target.bash,
			    sformat ("kill -15 %1", pid));
			runs = false;
			abort_server = true;
		    }
		}
	    }
	    if (displayed)
		UI::CloseDialog ();
	}

	Printer::cups_servers = [];
	if (SCR::Read (.target.size,
	    "/var/lib/YaST2/cups_network_server_name") != -1)
	{
	    y2milestone ("File with CUPS servers found");
	    if (! abort_server)
	    {
		string tmp = SCR::Read (.target.string,
		    "/var/lib/YaST2/cups_network_server_name");
		Printer::cups_servers = splitstring (tmp, "\n");
		Printer::cups_servers = toset (Printer::cups_servers);
		Printer::cups_servers = filter (`s, Printer::cups_servers, ``(
		    s != "" && s != nil));
	     }
	}
	if (0 == status)
	    SCR::Execute (.target.bash_background, "/etc/init.d/cups start");
	return Printer::cups_servers;
    }


    /**
     * Return list without item.
     * @param source source list
     * @param item item to delete
     * @return list List without item. If item was not present in list, list is unchanged.
     */
    global define list DeleteItem (list source, any item) ``{
        return filter (`i, source, ``{
            return i != item;
        });
    }
    /**
     * Displays message when baud rate is 0.
     * @param brate Baud rate.
     * @return boolean Is baud rate ok?
     */
    global define boolean testBaudRate (integer brate) ``{
	if (brate == 0)
	    {
		// message box
		Popup::Message (_("The baud rate should not be 0!"));
		return false;
	    }
	return true;
    }
    /**
     * Is the hostname correct? Check it for allowed characters. Display message if bad hostname.
     * @param name Hostname to check
     * @return boolean true if hostname is correct.
     */
    global define boolean checkHostName (string name) ``{
	if (size (name) > 0 &&
	    /*size (name) < 50 &&*/
	    "" == filterchars (name,
				":/@"))
	    {
		return true;
	    }
	else
	    {
		// message box
		// the ',' character isn't separator,
		//  but one of a list of characters
		Popup::Message (_("Invalid host name. It must be
shorter than fifty characters and cannot contain
:, / or @.
"));
	    }
	return false;
    };

   /**
     * Is the username correct? Check it for allowed characters. Display message if bad username.
     * @param name Username to check
     * @return boolean true if username is correct.
     */
    global define boolean checkUserName (string name) ``{
        if (/*size (name) > 0 &&
            size (name) < 50 &&*/
            "" == filterchars (name,
                                ":/@"))
            {
                return true;
            }
        else
            {
                // message box
                // the ',' character isn't separator,
                //  but one of a list of characters
                Popup::Message (_("Invalid user name. It cannot 
contain the characters : , / @.
"));
            }
        return false;
    };

   /**
     * Is the password correct? Check it for allowed characters. Display message if bad password.
     * @param name password to check
     * @return boolean true if hostname is correct.
     */
    global define boolean checkPassword (string name) ``{
        if (/*size (name) > 0 &&
            size (name) < 50 &&*/
            "" == filterchars (name,
                                ":/@"))
            {
                return true;
            }
        else
            {
                // message box
                // the ',' character isn't separator,
                //  but one of a list of characters
                Popup::Message (_("Invalid password. It cannot 
contain the characters : , / @.
"));
            }
        return false;
    };



    /**
     * Check if remote_printer is not nil. Display message otherwise.
     * @param remote_printer Printer name to check
     * @return boolean true if name is OK
     */
    global define boolean checkRemotePrinter (string remote_printer) ``{
	if ("" != remote_printer)
	    {
		return true;
	    }
	// message box
	Popup::Message ( _("Please choose which forwarding
queue you want to use."));
	return false;
    };

    /**
      * generate class name
      * @param forbidden_names list of forbidden names
      * @return new class name
      */
    global define string generateClassName (list forbidden_names) ``{
	string name = "class1";
	integer i = 2;
	while (contains (forbidden_names, name))
	{
	    name = sformat ("class%1", i);
	    i = i + 1;
	}
	return name;
    }

    /**
     * Ask if really abort. Uses boolean Printer::dirty. Sets boolean do_abort_now.
     * @return boolean true if user really wants to abort
     */
    global define boolean reallyAbort ()``{
	boolean abort_now = false;
	if (abort_now || !Printer::dirty)
	    {
		return true;
	    }
	abort_now = Popup::ReallyAbort (true);
	return abort_now;
    }

    /**
     * Ask if really exit. Uses boolean Printer::dirty. Sets boolean do_abort_now.
     * @return boolean true if user really wants to abort
     */
    global define boolean reallyExit ()``{
        if (!Printer::dirty)
            {
                return true;
            }
	return Popup::AnyQuestion( Popup::NoHeadline(),
// question popup
_("Really leave printer configuration without saving?
All changes will be lost.
"),
                                      Label::YesButton(),
                                      Label::NoButton(),
                                      `focus_no );

    }

    /**
     * Get list of available devices in nice-names.
     * @param dev list of devices to show
     * @param device device that should be selected. If "" then first device will be selected.
     * @return list Items for selection box. One of the items is selected.
     */
    global define list getDevicesItems (list dev, string device) ``{
	list device_val = [];
	boolean default_selected = false;
	foreach (`dev, devices, ``{
	    boolean this_is_selected = (("" != device && dev == device) ||
					("" == device && (dev == "/dev/lp0" ||
							  dev == "/dev/usblp0" ||
							  dev == "/dev/usb/lp0" ||
							  dev == "/dev/ttyS0")));
	    if (this_is_selected)
		default_selected = true;
	    device_val = add (device_val, `item (`id (dev), Printerlib::getDeviceNiceName (dev, false), this_is_selected));
	});
	if (!default_selected)
	    device_val = add (device_val, `item (`id (device), device, true));
	return device_val;
    }
    /**
     * Create the content of table of all entries in the printcap.
     * @return List of items. Item id is index of printer in printcap.
     */
    global define list printcapTable () ``{
	integer count = 0;
	Printer::sortPrinters ();
	return maplist (`ent, Printer::printcap, ``{
		string name = lookup (ent, "name", "???");
		term ret =
		    `item (
			`id (count),
			name == Printer::default ? UI::Glyph (`BulletArrowRight) : " ",
			lookup (ent, "name", ""));

		if ("yast2" == lookup (ent, "type", "yast2"))
		{
		    string description = Printerlib::getUriNiceName (lookup (ent, "uri", ""));
		    if ("void" == Printer::getPrinterState (ent, Spooler::Get ()))
			// table item. SHORT!
			description = _("- invalid for selected spooler -");
		    ret = add (ret, description);
		}
		else
		    // This printer was not configured using YaST2. Item in table. SHORT!
		    ret = add (ret, _("- not YaST2 -"));
		if (Spooler::Get () == "cups" || Printer::spooler == "lprng")
		{
		    if ("yast2" == lookup (ent, "type", "yast2"))
			// table item. SHORT
			ret = add (ret, "commited" == Printer::getPrinterState (ent, Spooler::Get ()) ? _("OK") : "");
		    else
			// table item. SHORT
			ret = add (ret, _("unknown"));
		}
		else
		{
			// table item. SHORT
		    ret = add (ret, "void" != Printer::getPrinterState (ent, "cups") ? _("OK") : "");
			// table item. SHORT
		    ret = add (ret, "void" != Printer::getPrinterState (ent, "lprng") ? _("OK") : "");
		}
		count = count+1;
		return ret;
	});
    }

    /**
      * Is the name of local queue correct? If not, display message.
      * @param name string queue name
      * @param forbidden_names list of forbidden names
      * @return boolean true if correct
      */
    global define boolean checkLocalQueueName (string name, list forbidden_names) ``{
	if (size (name) > 0 && size (name) < 32 &&
	    size (filterchars (substring (name, 0, 1),
		"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")) > 0 &&
	    name == filterchars (name,
		"_0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
	    && ! contains (forbidden_names, name))
	    {
		if (contains (Spooler::getSystemForbiddenNames (), name))
		{
		    // message box
		   Popup::Message (_("Invalid queue name. The name must not be used
for any file in directory /etc/lpdfilter"));
		   return false;
		}
		return true;
	    }
	    else
	    {
		// popup
		 Popup::Message (_("Invalid queue name. It must be
shorter than 32 characters, start with a letter,
and only contain 0...9, A...Z, a...z, and _."));
		return false;
	    }
    }

    /**
     * Is the name of the remote printer correct? If not, display message.
     * @param name Hostname to check
     * @return boolean true if hostname is correct.
     */
    global define boolean checkQueueName (string name) ``{
	if (size (name) > 0 && /*size (name) < 30 &&
	    size (filterchars (substring (name, 0, 1),
		    "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")) > 0 &&*/
	    "" == filterchars (name,
				"@:"))
	    {
		return true;
	    }
	else
	    {
		// message box
		Popup::Message (_("Invalid remote queue name. 
It cannot contain the characters @ and :.
"));
	    }
	return false;
    }

    /**
      * Creates UI widgets from values.
      * @param option_type string type of the option
      *  (pick_one, pick_many, boolean)
      * @param vals any values, type depends on option type
      * @return UI representation of vals
      */
    global define term getWidgetForOption (string option_type, any values) ``{
	if (option_type == "Boolean")
	{
	    list vals = (list) values;
	    if (size (vals) != 2)
	    {
		y2error (
		    "Incorrect size of possible values for boolean option: %1",
		    vals);
	    }
	    list r_buttons = maplist (list entry, vals, ``(
		`Left (`RadioButton (`id (entry[0]:""), entry[1]:""))
	    ));
	    term ret = `VBox (`VSpacing (1));
	    foreach (term button, r_buttons, ``{
		ret = add (ret, button);
	    });
	    ret = add (ret, `VSpacing (1));
	    ret = `HBox (
		`HSpacing (3),
		`RadioButtonGroup (`id (`vals), `opt (`notify), ret),
		`HSpacing (3)
	    );
	    // frame
	    ret = `Frame (_("Value:"), ret);
	    ret = `HBox (
		`HStretch (),
		`VBox (
		    `VStretch (),
		    ret,
		    `VStretch ()
		),
		`HStretch ()
	    );
	    return ret;
	}
	if (option_type == "PickMany")
	{
	    list vals = (list) values;
	    // multiselectionbox label
	    return `MultiSelectionBox(`id (`vals), `opt (`notify), _("Val&ues"),
		maplist (list entry, vals, ``(
		    `item (`id (entry[0]:""), entry[1]:"")
		))
	    );
	}
	list vals = (list) values;
	y2debug ("value: %1", values);
	// selectionbox label
	return `SelectionBox (`id (`vals), `opt (`notify), _("Val&ues"),
	    maplist (list entry, vals, ``(
		`item (`id (entry[0]:""), entry[1]:"")
	    ))
	);
    }

    /**
     * Remove characters that are not allowed by ieee1284.
     * @param id string to check
     * @return string updated string
     */
    global define string filter1284 (string id) ``{
	return filterchars (tolower (id), "abcdefghijklmnopqrstuvwxyz0123456789_+/");
    }

    /**
     * Compare saved gs_upp file with the generated one.
     * @param file1 contents of one upp file
     * @param file2 contents of the other upp file
     * @return boolean true if files are the same
     */
    global define boolean diffUppFiles (string file1, string file2) ``{
	// save files
	string tmpdir = SCR::Read (.target.tmpdir);
	SCR::Write (.target.string, tmpdir + "/options1.upp", file1);
	SCR::Write (.target.string, tmpdir + "/options2.upp", file2);
	// diff files
	boolean changed = (0 == SCR::Execute (.target.bash, sformat ("/usr/bin/diff -w -B %1/options1.upp %1/options2.upp", tmpdir)));
	// delete files
	SCR::Execute (.target.bash, sformat ("/bin/rm %1/options1.upp %1/options2.upp", tmpdir));
	return changed;
    }
    /**
     * Looks if selected options contain paper size.
     * @param selected currently selected options
     * @return true if they contain paper size
     */
    global define boolean havePaperSize (map selected) ``{
	boolean found = false;
	foreach (`k, `v, selected, ``{
	    if (substring (k, 0, 10) == "papersize-")
		found = true;
	});
	return found;
    }
    /**
      * get RadioButtonGroup for spooler selection
      * @param spooler string currently used spooler (cups, cups-client, lprng or current)
      * @param none boolean show leaving current status
      * @return term RadioButtonGroup widget
      */
    global define term getSpoolerItems (string spooler, boolean none) ``{
	return `RadioButtonGroup (
	    `id (`spooler),
	    `HBox (`HSpacing (1), `VBox (
		`VSpacing (1),
		`RadioButton (`id (`cups_server),
		    `opt (`hstretch, `notify),
		    // radiobutton
		    _("CUPS full &server installation"),
		    spooler == "cups"),
		`VSpacing (0.5),
		`RadioButton (`id (`cups_client),
		    `opt (`hstretch, `notify),
		    // radiobutton
		    _("CUPS &client-only installation"),
		    spooler == "cups-client"),
		`VSpacing (0.5),
		`RadioButton (`id (`lprng),
		    `opt (`hstretch, `notify),
		    // radiobutton
		    _("&LPRng"),
		    spooler == "lprng"),
		none ? `VSpacing (0.5) : `VSpacing (0),
		none ? `RadioButton (`id (`none),
		    `opt (`hstretch, `notify),
		    // radiobutton
		    _("L&eave current status"),
		    spooler == "current")
		    : `VSpacing (0),
		`VSpacing (1)
	     ), `HSpacing (1)
	));
    }

    /**
      * Shows a question to a user whether he wants the LPRng or CUPS spooler.
      * @param msg string to be displayed
      * @param abort_msg label of abort button
      * @return symbol specifying users selecion (lprng, cups, exit)
      */
    global define symbol chooseSpooler(string msg, string abort_msg)
    ``{
	symbol ret = `none_symbol;
	UI::OpenDialog (
            `VBox (
		`Label (msg),
		getSpoolerItems ("current", true),
		`HBox (
		    `HWeight (1, `PushButton (`id (`ok), `opt (`key_F10), Label::OKButton ())),
		    `HWeight (1, `PushButton (`id (`cancel), `opt (`key_F9), abort_msg))))
	);
	while (true)
	{
	    ret = UI::UserInput ();
	    if (ret == `ok || ret == `cancel)
		break;
	}
	if (`ok == ret)
	{
	    ret = UI::QueryWidget (`id (`spooler), `CurrentButton);
	}
	UI::CloseDialog();
	return ret;
    }

    /**
      * Get the default encoding of the PPD file according to the language
      * @param language string language in the form it is present in PPD file
      * @return encoding in the form it is present in PPD file
      */
    global define string Language2Encoding (string language) ``{
	map mapping = $[
	    "English" : "ISOLatin1",
	    "Danish" : "ISOLatin1",
	    "Dutch" : "ISOLatin1",
	    "Finnish" : "ISOLatin1",
	    "French" : "ISOLatin1",
	    "German" : "ISOLatin1",
	    "Italian" : "ISOLatin1",
	    "Japanese" : "JIS83-RKSJ,",
	    "Norwegian" : "ISOLatin1",
	    "Portuguese" : "ISOLatin1",
	    "Spanish" : "ISOLatin1",
	    "Swedish" : "ISOLatin1",
	    "Czech" : "ISOLatin2",
	];
	return mapping[language]:"None";
    }

    /**
      * Get the characters encoding from the form in it is present in PPD file
      * to the form that can be passed to iconv
      * @param ppd_enc string encoding in the form for PPD file
      * @return string encoding in the form for iconv
      */
    global define string PPDenc2UIenc (string ppd_enc) ``{
	map mapping = $[
	    "ISOLatin1" : "ISO-8859-1",
	    "ISOLatin2" : "ISO-8859-2",
	    "ISOLatin5" : "ISO-8859-5",
	    "JIS83-RKSJ" : "SHIFT-JIS",
	    "MacStandard" : "MAC",
	    "WindowsANSI" : "MS_ANSI",
	];
	return mapping[ppd_enc]:"";
    }








}
