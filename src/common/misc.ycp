/**
 * File:
 *  misc.ycp
 *
 * Module:
 *  Printer configurator
 *
 * Summary:
 *  Miscelaneous defines.
 *
 * Authors:
 *  Petr Blahos <pblahos@suse.cz>
 *  Jiri Srain <jsrain@suse.cz>   2002
 *
 * $Id$
 *
 * Miscelaneous defines.
 */

{
    textdomain "printer";
    import "Printer";
    import "Printerlib";
    import "Console";

    include "printer/ppds.ycp";
    include "printer/misc-cups.ycp";


    /**
      * Sort items according to locale
      * @param items map items (item key -> item label)
      * @return list of items to be used for selectionbox
      */
    global define list sortitems (map items) ``{
	string enc = Console::encoding;
	items = mapmap (`k, `v, items, ``(
	    [k, UI::Recode ("UTF-8", enc, v)]));
	list l = SCR::Read (.ppd.sort_items, items);
	l = maplist (`i, l, ``{
	    string label = select (i, 1, "");
	    label = UI::Recode (enc, "UTF-8", label);
	    i = remove (i, 2);
	    i = add (i, label);
	    return i;
	});
	return l;
    }

    /**
      * Check if paper size is set and if not, then set the defaul
      * Don't change if already set
      * @param p map of printer to adjust paper size
      * @return map of printer with adjusted paper size
      */
    global define map adjustPaperSize (map p) ``{
	map options = p["options"]:$[];
	if (haskey (options, "PageSize"))
	    return p;
	string pagesize = Printerlib::getDefaultPaperSize () == `a4 ? "A4" : "Letter";
	options["PageSize"] = pagesize;
	options["PageRegion"] = pagesize;
	options["ImageableArea"] = pagesize;
	options["PaperDimension"] = pagesize;
	p["options"] = options;
	return p;
    }


    /**
      * Inform user that function isn't available during preparatino of AI
      * via a popup
      */
    global define void DisplayUnavailableAIPopup () ``{
	// popup message
	UI::MessagePopup (_("This function is not available during
preparation for autoinstallation.
"));
    }

    /**
      * replaces all occurences of 'from' to 'to' in src
      * @param src input string
      * @param from string to be replaced
      * @param to string to be replaced by
      * @return string modified string
      */
    global define string replaceAll(string src, string from, string to) ``{
        if (from == "")
        {
            return src;
        }

        list tokens = [];

        integer p = find(src, from);
        while(p >= 0)
        {
            tokens = add(tokens, substring(src, 0, p));
            src = substring(src, p + size(from), size(src) - (p+size(from)));
            p = find(src, from);
        }
        tokens = add(tokens, src);
        return mergestring(tokens, to);
    }

    /**
      * Get printers (physical devices), which are configured
      * @return a list of printers maps (one queue of each printer)
      */
    global define list(map) getConfiguredPrinters () ``{
        list(string) ukeys = [];
        list(string) uris = [];
	list(string) models = [];
	list(map) printers = [];

        foreach (`p, Printer::printcap, ``{
            string ukey = p["unique_key"]:"";
            string uri = p["uri"]:"";
	    string model = p["ownppd"]:"";
	    if (model == "")
		model = p["vendor_ieee"]:"" + p["device_ieee"]:"";
	    if (model == "")
		model = p["vendor_db"]:"" + p["device_db"]:"";
            if ((! contains (ukeys, ukey)
		    && (! contains (uris, uri))
			|| ! contains (models, model)
		    )
		&& (model != "" && uri != ""))
            {
                uris = add (uris, uri);
                if (ukey != "")
                    ukeys = add (ukeys, ukey);
		models = add (models, model);
                printers = add (printers, p);
            }
        });

	return printers;
    }

    /**
      * List all queues of specified printer
      * @param uri of printer
      * @param vendor string printer vendor name
      * @param device string printer model name
      * @return a list of maps of queues
      */
    global define list(map) getQueuesOfPrinter (string uri, string vendor,
	string device)
    ``{
	list(map) queues = filter (`p, Printer::printcap, ``(
	    p["uri"]:"" == uri &&
		((p["vendor_db"]:"" == vendor && p["device_db"]:"" == device)
		||(p["vendor_ieee"]:"" == vendor && p["device_ieee"]:"" == device))
	    ));
	return queues;
    }

    /**
      * Has a printer (physical) been already configured (contains at least
      * one queue?
      * @param printer map containing at least vendor, device and
      *   unique_key keys for comparsionprinter vendor
      * @return boolean true if already configured
      */
    global define boolean isPrinterConfigured (map printer) ``{
	string vendor_db = printer["vendor_db"]:"";
	string device_db = printer["device_db"]:"";
	string vendor_ieee = printer["vendor_ieee"]:"";
	string device_ieee = printer["device_ieee"]:"";
	string ukey = printer["unique_key"]:"";
	string uri = printer["uri"]:"";
	if (uri == "")
	    uri = printer["bus"]:"parallel" + ":" + printer["dev_name"]:"";
	boolean exists = false;

	foreach (`p, Printer::printcap, ``{
	    if ((p["unique_key"]:"" == ukey && ukey != "")
		|| (p["uri"]:"" == uri && uri != ""
		    && ((p["vendor_db"]:".." == vendor_db
			    && p["device_db"]:".." == device_db)
			|| (p["vendor_ieee"]:".." == vendor_ieee
			    && p["device_ieee"]:".." == device_ieee))
		   ))
	    {
		exists = true;
	    }
	});
	return exists;
    }

    /**
      * check whether spooler (if needed to be running) runns, if not start it
      * @param showPopup boolean true if shall show a popup if needed
      */
    global define void restartSpoolerIfNeeded (boolean showPopup) ``{
	if (Mode::config)
	    return;
        if (Printer::spooler == "cups")
        {
            if (`server == Printer::cupsInstallationType ())
            {
		boolean close_dialog = false;
		integer status = SCR::Execute (.target.bash, "/usr/bin/lpq 2>/dev/null");
                if (status == 0)
                    return;
		if (SCR::Read (.target.size, "/etc/cups/ppds.dat") <= 0)
		{
		    close_dialog = true;
		    showCupsInitPopup ();
		}
                status = SCR::Execute (.target.bash, "/etc/init.d/cups status");
                if (0 != status)
		{
                    SCR::Execute (.target.bash_background, "/etc/init.d/cups start");
		    sleep (1000);
		}
                status = 1;
		integer attempts = 0;
                while (true)
                {
                    status = SCR::Execute (.target.bash, "/usr/bin/lpq 2>/dev/null");
                    if (status == 0)
                        break;
		    attempts = attempts + 1;
		    if (attempts > 5 && ! close_dialog)
		    {
			close_dialog = true;
			showCupsInitPopup ();
		    }
		    if (attempts>60*10)
		    {
			break;
		    }
                    if (close_dialog)
                        UI::ChangeWidget (`id (`cups_prog), `Value, attempts);
                    sleep (1000);
                    status = SCR::Execute (.target.bash, "/etc/init.d/cups status");
                    if (0 != status)
                    {
                        UI::MessagePopup (
                            // error popup
                            _("CUPS daemon died during initialization"));
			break;
                    }
                }
		if (close_dialog)
		{
		    UI::CloseDialog ();
		}
            }
        }
    }

    /**
     * Reinstall all printing related packages using package-manager
     * @return boolean true if success
     */
    global define boolean reinstallAll () ``{
	if (Mode::config)
	{
	    DisplayUnavailableAIPopup ();
	    return true;
	}
	import "PackageCallbacks";
	Printer::printcap = [];
	Printer::default = "";
	Printer::save_all = false;

	Printerlib::stopServices();
	list to_delete = ["plp", "lprold", "lprng", "cups", "cups-client", "cups-drivers", "cups-drivers-cs", "cups-drivers-de", "cups-drivers-stp",
	    "cups-libs", "cups-devel", "lpdfilter", "filters", "ghostscript-fonts-other", "ghostscript-x11", "ghostscript-fonts-std", "ghostscript-library",
	    "ghostscript-fonts-kanji", "ghostscript-serv", "ghostscript-fonts-rus", "ghostscript-library", "a2ps"];
	to_delete = filter (`e, to_delete, ``(Pkg::IsProvided (e) == true));

	list to_install = ["ghostscript-library", "ghostscript-x11", "ghostscript-fonts-std", "ghostscript-fonts-other", "a2ps", "cups-libs"];

	y2milestone("deleting: %1", to_delete);
	foreach (`e, to_delete, ``{Pkg::PkgDelete (e);});
	Pkg::PkgCommit (0);
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/cups/");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/lpdfilter/");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/printcap");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/printcap.rpm*");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/printcap-2*");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/printcap.y2*");
	SCR::Execute (.target.bash, "/bin/rm -rf /var/spool/lpd/");
	SCR::Execute (.target.bash, "/bin/rm -rf /var/spool/cups/");
	SCR::Execute (.target.bash, "/bin/rm -rf /var/lib/YaST2/printers");

	foreach (`e, to_install, ``{Pkg::PkgInstall (e);});

	y2milestone("installing: %1", to_install);
	Pkg::PkgSolve ();
	Pkg::PkgCommit (0);
	WFM::CallModule("inst_suseconfig", []);

	return true;

    }
    /**
     * Get hosts available on local network. Reads from .net.hostnames. Shows popup window: Wait please.
     * @param type "ipp", "samba", "lpd" or ""
     * @return list Sorted list of hosts.
     */
    global define list getHostnames (string type) ``{
        UI::OpenDialog (`opt (`decorated),
                         // text in dialog box
                         `Label (_("Scanning for hosts on this LAN...")));
        list hosts = [];
        if ("samba" == type)
            hosts = SCR::Read (.net.hostnames.samba);
        else if ("ipp" == type)
	{
            hosts = SCR::Read (.net.hostnames, 631);
	    hosts = filter (`h, hosts, ``{
		list queues = SCR::Read (.cups.remote, h);
		return size (queues) > 0;
	    });
	}
        else if ("lpd" == type)
            hosts = SCR::Read (.net.hostnames, 515);
        else if ("socket" == type)
            hosts = SCR::Read (.net.hostnames, 9100);
        else if ("" != type)
	    hosts = SCR::Read (.net.hostnames, tointeger (type));
	else
            hosts = SCR::Read (.net.hostnames);
        if (nil == hosts)
            hosts = [];
        UI::CloseDialog ();
        return sort (hosts);
    }

    /**
      * Get hosts available on local network via listening to IPP broadcasts
      * @return list Sorted list of hosts
      */
    global define list listenCupsServers () ``{
	integer status = SCR::Execute (.target.bash, "/etc/init.d/cups status");
	if (0 == status)
	    SCR::Execute (.target.bash, "/etc/init.d/cups stop");

	SCR::Execute(.target.bash_background,
	    "/usr/lib/YaST2/bin/listen_remote_ipp 30");
	sleep (1000);
	string pid = nil;
	if (SCR::Read (.target.size, "/var/run/listen_remote_ipp.pid") > 0)
	{
	    pid = SCR::Read (.target.string, "/var/run/listen_remote_ipp.pid");
	}
	boolean abort_server = false;
	if (pid != nil)
	{
	    y2milestone ("Scanning for CUPS server in progress");
	    SCR::Execute (.target.bash, sformat ("kill -1 %1", pid));
	    boolean runs = true;
	    boolean displayed = false;
	    integer counter = 0;
	    while (runs)
	    {
		if (counter == 10)
		{
		    displayed = true;
		    UI::OpenDialog (`VBox (`Label (
			// label
			_("Detecting CUPS network server...")),
			`PushButton (`id (`abort), `opt (`key_F9),
			    AbortButtonLabel ())));

		}
		sleep (100);
		runs = SCR::Read (.target.size,
		    "/var/run/listen_remote_ipp.pid") > 0;
		counter = counter + 1;
		if (displayed)
		{
		    any ui = UI::PollInput ();
		    if (ui == `abort)
		    {
			SCR::Execute (.target.bash,
			    sformat ("kill -15 %1", pid));
			runs = false;
			abort_server = true;
		    }
		}
	    }
	    if (displayed)
		UI::CloseDialog ();
	}

	Printer::cups_servers = [];
	if (SCR::Read (.target.size,
	    "/var/lib/YaST2/cups_network_server_name") != -1)
	{
	    y2milestone ("File with CUPS servers found");
	    if (! abort_server)
	    {
		string tmp = SCR::Read (.target.string,
		    "/var/lib/YaST2/cups_network_server_name");
		Printer::cups_servers = splitstring (tmp, "\n");
		Printer::cups_servers = toset (Printer::cups_servers);
		Printer::cups_servers = filter (`s, Printer::cups_servers, ``(
		    s != "" && s != nil));
	     }
	}
	if (0 == status)
	    SCR::Execute (.target.bash_background, "/etc/init.d/cups start");
	return Printer::cups_servers;
    }


    /**
     * Return list without item.
     * @param source source list
     * @param item item to delete
     * @return list List without item. If item was not present in list, list is unchanged.
     */
    global define list DeleteItem (list source, any item) ``{
        return filter (`i, source, ``{
            return i != item;
        });
    }
    /**
      * Test whether spooler supports queue type
      * @param queue string queue type (eg. parallel)
      * @param spooler string "cups" or "lprng"
      * @return boolean true if supports
      */
    global define boolean testSupportedQueueBySpooler
	(string queue, string spooler)
    ``{
	map supported = $[ "cups" : [ "parallel", "usb", "serial", "lpd", "ipp", "samba", "socket", "irda", "class", "novell", "pipe", ],
			   "lprng" : [ "parallel", "usb", "serial", "lpd", "samba", "novell", "irda", "socket", "pipe", ]];
	list l = lookup (supported, spooler, []);
	if (l == [])
	    return true;
	if (contains (l, queue))
	    return true;
	if (spooler == "cups")
	{
	    list(string) backends
		= SCR::Read (.target.dir, "/usr/lib/cups/backend");
	    if (backends != nil)
		return contains (backends, queue);
	}
	return false;
    }
    /**
      * Test whether currently used spooler supports queue type
      * @param queue string queue type (eg. parallel)
      * @return boolean true if supports
      */
    global define boolean testSupportedQueue (string queue) ``{
	return testSupportedQueueBySpooler (queue, Printer::spooler);
    }
    /**
     * Displays message when baud rate is 0.
     * @param brate Baud rate.
     * @return boolean Is baud rate ok?
     */
    global define boolean testBaudRate (integer brate) ``{
	if (brate == 0)
	    {
		// message box
		UI::MessagePopup (_("The baud rate should not be 0!"));
		return false;
	    }
	return true;
    }
    /**
     * Is the hostname correct? Check it for allowed characters. Display message if bad hostname.
     * @param name Hostname to check
     * @return boolean true if hostname is correct.
     */
    global define boolean checkHostName (string name) ``{
	if (size (name) > 0 &&
	    /*size (name) < 50 &&*/
	    "" == filterchars (name,
				":/@"))
	    {
		return true;
	    }
	else
	    {
		// message box
		// the ',' character isn't separator,
		//  but one of a list of characters
		UI::MessagePopup (_("Invalid host name. It must be
shorter than fifty characters and cannot contain
:, / or @.
"));
	    }
	return false;
    };

   /**
     * Is the username correct? Check it for allowed characters. Display message if bad username.
     * @param name Username to check
     * @return boolean true if username is correct.
     */
    global define boolean checkUserName (string name) ``{
        if (/*size (name) > 0 &&
            size (name) < 50 &&*/
            "" == filterchars (name,
                                ":/@"))
            {
                return true;
            }
        else
            {
                // message box
                // the ',' character isn't separator,
                //  but one of a list of characters
                UI::MessagePopup (_("Invalid user name. It cannot 
contain the characters : , / @.
"));
            }
        return false;
    };

   /**
     * Is the password correct? Check it for allowed characters. Display message if bad password.
     * @param name password to check
     * @return boolean true if hostname is correct.
     */
    global define boolean checkPassword (string name) ``{
        if (/*size (name) > 0 &&
            size (name) < 50 &&*/
            "" == filterchars (name,
                                ":/@"))
            {
                return true;
            }
        else
            {
                // message box
                // the ',' character isn't separator,
                //  but one of a list of characters
                UI::MessagePopup (_("Invalid password. It cannot 
contain the characters : , / @.
"));
            }
        return false;
    };



    /**
     * Check if remote_printer is not nil. Display message otherwise.
     * @param remote_printer Printer name to check
     * @return boolean true if name is OK
     */
    global define boolean checkRemotePrinter (string remote_printer) ``{
	if ("" != remote_printer)
	    {
		return true;
	    }
	// message box
	UI::MessagePopup ( _("Please choose which forwarding
queue you want to use."));
	return false;
    };

    /**
      * generate class name
      * @param forbidden_names list of forbidden names
      * @return new class name
      */
    global define string generateClassName (list forbidden_names) ``{
	string name = "class1";
	integer i = 2;
	while (contains (forbidden_names, name))
	{
	    name = sformat ("class%1", i);
	    i = i + 1;
	}
	return name;
    }

    /**
     * TODO: create test case
     * @param name printer name
     * @param forbidden_names list of forbidden names
     * @return new queue name
     */
    global define string generateQueueName (string name, string uri,
	string vendor_name, string device_name, list forbidden_names)
    ``{
	if (name == nil)
	{
	    name = "";
	    if (isRemote (uri) && Printerlib::getUriRemoteQueue (uri) != "")
	    {
	        name = Printerlib::getUriRemoteQueue (uri);
	        integer i = findlastof (name, "/");
	            if (i != nil)
		    name = substring (name, i);
	        name = filterchars (name,
		    "_0123456789abcdefghijklmnopqrstuvwxyz");
		if (size (name) >= 20)
		    name = substring (name, 0, 20);
	    }
	    if (name == "" && device_name != "")
	    {
	        name = filterchars (
		    tolower (vendor_name + "_" + device_name),
		    "_0123456789abcdefghijklmnopqrstuvwxyz");
		if (size (name) >= 20)
		{
		    name = filterchars (
			tolower (device_name),
			"_0123456789abcdefghijklmnopqrstuvwxyz");
		}
		if (size (name) >= 20)
		    name = substring (name, 0, 20);
	    }
	if (name == "")
	    name = "printer";
	}

	integer i = 1;
	while (contains (forbidden_names, name))
	{
	    name = sformat ("printer%1", i);
	    i = i + 1;
	}
	return name;
    }

    global define boolean isRemote (string uri) ``{
	string uri_type = Printerlib::getUriType (uri);
	return contains (["lpd", "ipp", "samba", "novell"], uri_type);
    }

    /**
     * We need this wrapper because of wizard sequencer.
     * @return `next for wizard sequencer
     */
    global define symbol storePrinter () ``{
	Printer::storePrinter ();
	return `next; // because of wizard sequencer
    }

    /**
     * Shows dialog box that allows user to stop printing.
     * @param pr_command Command that was used to start printing. Showed in text field.
     * @return boolean true if printing has to be stopped
     */
    global define boolean OkOrStopPrinting (string pr_command) ``{
	// message box with [OK] [Stop]
	string text = sformat (_("The test page was sent to the printer using
the command '%1'.
Printing should start in a few seconds.

If the printer is not producing the appropriate
output, use the 'Stop!' button.

When the whole page is printed, press
'Printout finished'."), pr_command);
	// push button
	return UI::AnyQuestionPopup (NoHeadline (), text, _("Printout &finished"), StopButtonLabel (), `focus_yes);
    }

    /**
     * Ask if really abort. Uses boolean Printer::dirty. Sets boolean do_abort_now.
     * @return boolean true if user really wants to abort
     */
    global define boolean reallyAbort ()``{
	boolean abort_now = false;
	if (abort_now || !Printer::dirty)
	    {
		return true;
	    }
	abort_now = UI::ReallyAbortPopup (true);
	return abort_now;
    }

    /**
     * Ask if really exit. Uses boolean Printer::dirty. Sets boolean do_abort_now.
     * @return boolean true if user really wants to abort
     */
    global define boolean reallyExit ()``{
        if (!Printer::dirty)
            {
                return true;
            }
	return UI::AnyQuestionPopup( NoHeadline(),
// question popup
_("Really leave printer configuration without saving?
All changes will be lost.
"),
                                      YesButtonLabel(),
                                      NoButtonLabel(),
                                      `focus_no );

    }

    /**
     * Get list of available devices in nice-names.
     * @param dev list of devices to show
     * @param device device that should be selected. If "" then first device will be selected.
     * @return list Items for selection box. One of the items is selected.
     */
    global define list getDevicesItems (list dev, string device) ``{
	list device_val = [];
	boolean default_selected = false;
	foreach (`dev, devices, ``{
	    boolean this_is_selected = (("" != device && dev == device) ||
					("" == device && (dev == "/dev/lp0" ||
							  dev == "/dev/usblp0" ||
							  dev == "/dev/usb/lp0" ||
							  dev == "/dev/ttyS0")));
	    if (this_is_selected)
		default_selected = true;
	    device_val = add (device_val, `item (`id (dev), Printerlib::getDeviceNiceName (dev, false), this_is_selected));
	});
	if (!default_selected)
	    device_val = add (device_val, `item (`id (device), device, true));
	return device_val;
    }
    /**
     * Create the content of table of all entries in the printcap.
     * @return List of items. Item id is index of printer in printcap.
     */
    global define list printcapTable () ``{
	integer count = 0;
	Printer::sortPrinters ();
	return maplist (`ent, Printer::printcap, ``{
		string name = lookup (ent, "name", "???");
		term ret =
		    `item (
			`id (count),
			name == Printer::default ? UI::Glyph (`BulletArrowRight) : " ",
			lookup (ent, "name", ""));

		if ("yast2" == lookup (ent, "type", "yast2"))
		{
		    string description = Printerlib::getUriNiceName (lookup (ent, "uri", ""));
		    if ("void" == Printer::getPrinterState (ent, Printer::spooler))
			// table item. SHORT!
			description = _("- invalid for selected spooler -");
		    ret = add (ret, description);
		}
		else
		    // This printer was not configured using YaST2. Item in table. SHORT!
		    ret = add (ret, _("- not YaST2 -"));
		if (Printer::spooler == "cups" || Printer::spooler == "lprng")
		{
		    if ("yast2" == lookup (ent, "type", "yast2"))
			// table item. SHORT
			ret = add (ret, "commited" == Printer::getPrinterState (ent, Printer::spooler) ? _("OK") : "");
		    else
			// table item. SHORT
			ret = add (ret, _("unknown"));
		}
		else
		{
			// table item. SHORT
		    ret = add (ret, "void" != Printer::getPrinterState (ent, "cups") ? _("OK") : "");
			// table item. SHORT
		    ret = add (ret, "void" != Printer::getPrinterState (ent, "lprng") ? _("OK") : "");
		}
		count = count+1;
		return ret;
	});
    }

    /**
      * Is the name of local queue correct? If not, display message.
      * @param name string queue name
      * @return boolean true if correct
      */
    global define boolean checkLocalQueueName (string name) ``{
	if (size (name) > 0 && size (name) < 127 &&
	    size (filterchars (substring (name, 0, 1),
		"abcdefghijklmnopqrstuvwxyz")) > 0 &&
	    name == filterchars (name,
		"_0123456789abcdefghijklmnopqrstuvwxyz"))
	    {
		return true;
	    }
	    else
	    {
		// popup
		 UI::MessagePopup (_("Invalid queue name. It must be
shorter than 127 characters, start with a letter,
and only contain 0...9, a...z, and _.
"));
		return false;
	    }
    }

    /**
     * Is the name of the remote printer correct? If not, display message.
     * @param name Hostname to check
     * @return boolean true if hostname is correct.
     */
    global define boolean checkQueueName (string name) ``{
	if (size (name) > 0 && /*size (name) < 30 &&
	    size (filterchars (substring (name, 0, 1),
		    "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")) > 0 &&*/
	    "" == filterchars (name,
				"@:"))
	    {
		return true;
	    }
	else
	    {
		// message box
		UI::MessagePopup (_("Invalid remote queue name. 
It cannot contain the characters @ and :.
"));
	    }
	return false;
    }

    /**
     * Check first and optionally 3rd name. 2nd name is 1st name+"-ascii" so it does not bother us,
     * but is checked because of length. Do not allow '-' in names. Do not allow name lp<number>.
     * In names are not OK, show dialog
     *
     * @param forbidden_names list of names that were already used
     * @param name name for current printer
     * @return boolean true if names are OK.
     */
    global define boolean checkName (list forbidden_names, string name) ``{
	boolean ok = true;
	if (size (name)<=0 ||
		size (name)>=20 ||
		name != filterchars (name, "_0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-") ||
		contains (forbidden_names, name) ||
		substring (name, 0, 1) == "-" ||
		"all" == name
		)
	{
	    // message box
	    UI::MessagePopup (_("Invalid name! The name should be less than 20 characters long
and can only use the characters 0..9, a..z, - and _. It must
not start with -. Additionally, you cannot use the name 'all' 
because of its special function.

The name must not be used for another printer."));
	    return false;
	}
	if (contains (Printer::getSystemForbiddenNames (), name))
	{
	    // message box
	    UI::MessagePopup (_("Invalid name! The name must not be used
for any file in directory /etc/lpdfilter"));
	    return false;
	}
	return true;
    }
    /**
     * Get value from UI
     * @param vals values
     * @return selected value
     */
    global define any grabValueUI (any vals) ``{
	if (is (vals, list))
	{
	    return UI::QueryWidget (`id (`vals), `CurrentItem);
	}
	if (is (vals, term))
	{
	    if (`text == symbolof (vals))
	    {
		string c = UI::QueryWidget (`id (`vals), `Value);
		return regexpsub (c, "(" + select (vals, 0, ".*") + ")", "\\1");
	    }
	    if (true == UI::QueryWidget (`id (`vals2), `Value))
	    {
		UI::ChangeWidget (`id (`vals), `Enabled, false);
		return nil;
	    }
	    UI::ChangeWidget (`id (`vals), `Enabled, true);
	    if (`int == symbolof (vals))
	    {
		integer i = UI::QueryWidget (`id (`vals), `Value);
		if (0 != select (vals, 2, 0))
		{
		    i = i - select (vals, 0, 0);
		    i = i / select (vals, 2, 1);
		    i = i * select (vals, 2, 1);
		    i = i + select (vals, 0, 0);
		    if (i < select (vals, 0, 0))
			i = select (vals, 0, 0);
		    if (i > select (vals, 1, select (vals, 0, 0) + 1))
			i = select (vals, 1, select (vals, 0, 0) + 1);
		}
		return i;
	    }
	    if (`float == symbolof (vals))
	    {
		float i = tofloat (UI::QueryWidget (`id (`vals), `Value));
		if (0 != select (vals, 2, 0))
		{
		    i = i - select (vals, 0, 0);
		    i = i / select (vals, 2, 1);
		    i = i * select (vals, 2, 1);
		    i = i + select (vals, 0, 0);
		    if (i < select (vals, 0, 0))
			i = select (vals, 0, 0);
		    if (i > select (vals, 1, select (vals, 0, 0) + 1))
			i = select (vals, 1, select (vals, 0, 0) + 1);
		}
		return i;
	    }
	}
	return nil;
    }
    /**
     * Creates UI widgets from values.
     * @param vals values
     * @return UI representation of vals
     */
    global define term getValuesUI (any vals) ``{
	if (is (vals,list))
	{
	    // selectionbox label
	    return `SelectionBox (`id (`vals), `opt (`notify), _("Val&ues"), vals);
	}
	if (!is (vals, term))
	    return `VStretch ();
	if (`text == symbolof (vals))
	{
	    // textentry label
	    term out = `TextEntry (`id (`vals), `opt (`notify), _("&Value:"), select (vals, 1, ""));
	    return `VBox (
		    `VStretch (),
		    out,
		    // label
		    `Right (`Label (sformat (_("Allowed characters: %1"), select (vals, 0, "")))),
		    `VStretch ());
	}
	if (`int == symbolof (vals))
	{
	    boolean not_used = (nil == select (vals, 4, nil) && nil == select (vals, 3, nil));
	    integer initial = select (vals, 4, nil);
	    if (nil == initial)
	    {
		initial = select (vals, 3, nil);
	    }
	    if (nil == initial)
	    {
		initial = select (vals, 0, nil);
	    }
	    term out = UI::HasSpecialWidget (`Slider) ?
		// slider
		`Slider (`id (`vals), not_used ? `opt (`notify, `disabled) : `opt (`notify), _("&Values")) :
		// int field
		`IntField (`id (`vals), not_used ? `opt (`hstretch, `notify, `disabled) : `opt (`notify), _("&Values"));
	    out = add (out, select (vals, 0, 0));
	    out = add (out, select (vals, 1, 0));
	    out = add (out, initial);
	    if (nil == select (vals, 3, nil))
	    {
		out = `VBox (
			`VStretch (),
			// check box
			`CheckBox (`id (`vals2), `opt (`hstretch, `notify), _("Not &set (use the driver default)"), not_used),
			out,
			// label
			`Label (`opt (`hstretch), sformat (_("Minimal value: %1\nMaximal value: %2\nStep: %3"),
				select (vals, 0, 0), select (vals, 1, 0), select (vals, 2, 0))),
			`VStretch ()
			);
	    }
	    else
	    {
		out = `VBox (
			`VStretch (),
			out,
			// label
			`Label (`opt (`hstretch), sformat (_("Minimal value: %1\nMaximal value: %2\nStep: %3"),
				select (vals, 0, 0), select (vals, 1, 0), select (vals, 2, 0))),
			`VStretch ()
			);
	    }
	    return out;
	}
	if (`float == symbolof (vals))
	{
	    boolean not_used = (nil == select (vals, 4, nil) && nil == select (vals, 3, nil));
	    float initial = select (vals, 4, nil);
	    if (nil == initial)
	    {
		initial = select (vals, 3, nil);
	    }
	    if (nil == initial)
	    {
		initial = select (vals, 0, nil);
	    }
	    term out = `TextEntry (`id (`vals),
		    not_used ? `opt (`disabled, `hstretch, `notify) :
			// textentry label
		    `opt (`hstretch, `notify), _("&Values"), sformat ("%1", initial));
	    if (nil == select (vals, 3, nil))
	    {
		out = `VBox (
			`VStretch (),
			// checkbox
			`CheckBox (`id (`vals2), `opt (`hstretch, `notify), _("Not &set (use the driver default)"), not_used),
			out,
			// label
			`Label (`opt (`hstretch), sformat (_("Minimal value: %1\nMaximal value: %2\nStep: %3"),
				select (vals, 0, 0), select (vals, 1, 0), select (vals, 2, 0))),
			`VStretch ()
			);
	    }
	    else
	    {
		out = `VBox (
			`VStretch (),
			out,
			// label
			`Label (`opt (`hstretch), sformat (_("Minimal value: %1\nMaximal value: %2\nStep: %3"),
				select (vals, 0, 0), select (vals, 1, 0), select (vals, 2, 0))),
			`VStretch ()
			);
	    }
	    return out;
	}
	return `VStretch ();
    }
    /**
     * Remove characters that are not allowed by ieee1284.
     * @param id string to check
     * @return string updated string
     */
    global define string filter1284 (string id) ``{
	return filterchars (tolower (id), "abcdefghijklmnopqrstuvwxyz0123456789_+/");
    }

    /**
     * Compare saved gs_upp file with the generated one.
     * @param file1 contents of one upp file
     * @param file2 contents of the other upp file
     * @return boolean true if files are the same
     */
    global define boolean diffUppFiles (string file1, string file2) ``{
	// save files
	string tmpdir = SCR::Read (.target.tmpdir);
	SCR::Write (.target.string, tmpdir + "/options1.upp", file1);
	SCR::Write (.target.string, tmpdir + "/options2.upp", file2);
	// diff files
	boolean changed = (0 == SCR::Execute (.target.bash, sformat ("/usr/bin/diff -w -B %1/options1.upp %1/options2.upp", tmpdir)));
	// delete files
	SCR::Execute (.target.bash, sformat ("/bin/rm %1/options1.upp %1/options2.upp", tmpdir));
	return changed;
    }
    /**
     * Looks if selected options contain paper size.
     * @param selected currently selected options
     * @return true if they contain paper size
     */
    global define boolean havePaperSize (map selected) ``{
	boolean found = false;
	foreach (`k, `v, selected, ``{
	    if (substring (k, 0, 10) == "papersize-")
		found = true;
	});
	return found;
    }
    /**
      * get RadioButtonGroup for spooler selection
      * @param spooler string currently used spooler (cups, cups-client, lprng or current)
      * @param none boolean show leaving current status
      * @return term RadioButtonGroup widget
      */
    global define term getSpoolerItems (string spooler, boolean none) ``{
	return `RadioButtonGroup (
	    `id (`spooler),
	    `HBox (`HSpacing (1), `VBox (
		`VSpacing (1),
		// radiobutton
		`RadioButton (`id (`cups_server),
		    `opt (`hstretch, `notify),
		    _("CUPS full &server installation"),
		    spooler == "cups"),
		`VSpacing (0.5),
		// radiobutton
		`RadioButton (`id (`cups_client),
		    `opt (`hstretch, `notify),
		    _("CUPS &client-only installation"),
		    spooler == "cups-client"),
		`VSpacing (0.5),
		// radiobutton
		`RadioButton (`id (`lprng),
		    `opt (`hstretch, `notify),
		    _("&LPRng"),
		    spooler == "lprng"),
		none ? `VSpacing (0.5) : `VSpacing (0),
		// radiobutton
		none ? `RadioButton (`id (`none),
		    `opt (`hstretch, `notify),
		    _("L&eave current status"),
		    spooler == "current")
		    : `VSpacing (0),
		`VSpacing (1)
	     ), `HSpacing (1)
	));
    }

    /**
      * Shows a question to a user whether he wants the LPRng or CUPS spooler.
      * @param msg string to be displayed
      * @param abort_msg label of abort button
      * @return symbol specifying users selecion (lprng, cups, exit)
      */
    global define symbol chooseSpooler(string msg, string abort_msg)
    ``{
	symbol ret = `none_symbol;
	UI::OpenDialog (
            `VBox (
		`Label (msg),
		getSpoolerItems ("current", true),
		`HBox (
		    `HWeight (1, `PushButton (`id (`ok), `opt (`key_F10), OKButtonLabel ())),
		    `HWeight (1, `PushButton (`id (`cancel), `opt (`key_F9), abort_msg))))
	);
	while (true)
	{
	    ret = UI::UserInput ();
	    if (ret == `ok || ret == `cancel)
		break;
	}
	if (`ok == ret)
	{
	    ret = UI::QueryWidget (`id (`spooler), `CurrentButton);
	}
	UI::CloseDialog();
	return ret;
    }
    /**
     * Check what spool system is installed. Don't ask user.
     * @return string spooler
     */
    global define string checkSpoolSystemNoDialog () ``{
	integer spool_sys = Printerlib::getSpoolSystem ();
	spool_sys = spool_sys & 0xFF;
	if (1 == spool_sys) //lpd is installed
	{
	    return "lprng";
	}
	else if (2 == spool_sys) //cups is installed
	{
	    return "cups";
	}
	return "unknown";
    }
    /**
     * Check what spool system is installed. Ask user if needed and install spooler if wanted.
     * @return string spooler
     */
    global define string checkSpoolSystem () ``{
	integer spool_sys = Printerlib::getSpoolSystem ();
	if (1 == spool_sys) //lpd is installed
	{
	    return "lprng";
	}
	else if (2 == spool_sys) //cups is installed
	{
	    return "cups";
	}
	else if (0 == spool_sys || 3 == spool_sys || 256 + 1 == spool_sys
	    || 256 + 2 == spool_sys)
	{
	    string message = "";
	    if (0 == spool_sys) //none installed
	    {
		// popup message
		message = _("No printing system installed. 
Select the spooler to 
to install and configure.");
	    }
	    else if (3 == spool_sys) //both spoolers are installed
	    {
		// popup message
		message = _("Both LPRng and CUPS are installed.
Select the spooler  
to leave installed and configure.");
	    }
	    else if (256 + 1 == spool_sys) // lpd is installed, but seems
					   // to be not complete
	    {
		// popup message
		message = _("An LPD-compatible spooler, probably LPRng,
is installed, but the installation does not seem 
complete. Choose to reinstall 
LPRng, install CUPS, or leave the current status.
To repair current configuration, select LPRng.
If you leave the current status, your spooler may not
run properly.");
	    }
	    else if (256 + 2 == spool_sys) // cups is installed, but seems
					   // to be not complete
	    {
		// popup message
		message =_("The CUPS spooler is installed, but the installation 
does not seem complete. Choose to reinstall
CUPS, install LPRng, or leave the current status. 
To repair the current configuration, select the 
CUPS full server installation.
If you leave the current status, your spooler 
may not run properly.");
	    }
	    symbol result = chooseSpooler (message,
		// pushbutton
		_("Abo&rt setup"));
	    if (`cups_server == result)
	    {
		Printerlib::switchTo ("cups");
		return "switched";
	    }
	    else if (`cups_client == result)
            {
                Printerlib::switchTo ("cups_client");
                return "switched";
            }
	    else if (`lprng == result)
	    {
		Printerlib::switchTo ("lprng");
		return "switched";
	    }
            else if (`cancel == result)
                return "exit";
	    else
		return "cups";
	}
	else if (512 + 2 == spool_sys) // only client installation of cups
				       // is installed
	{
	    return "cups";
	}
	return ""; //should be never reached
    }
}
