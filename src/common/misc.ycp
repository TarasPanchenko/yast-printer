/**
 * File:
 *  misc.ycp
 *
 * Module:
 *  Printer configurator
 *
 * Summary:
 *  Miscelaneous defines.
 *
 * Authors:
 *  Petr Blahos <pblahos@suse.cz>
 *  Jiri Srain <jsrain@suse.cz>   2002
 *
 * $Id$
 *
 * Miscelaneous defines.
 */

{
    textdomain "printer";
    import "Printer";
    import "Printerlib";
    import "Console";


    global define list sortitems (map items) ``{
	string enc = Console::encoding;
	items = mapmap (`k, `v, items, ``(
	    [k, UI::Recode ("UTF-8", enc, v)]));
	list l = SCR::Read (.ppd.sort_items, items);
	l = maplist (`i, l, ``{
	    string label = select (i, 1, "");
	    label = UI::Recode (enc, "UTF-8", label);
	    i = remove (i, 2);
	    i = add (i, label);
	    return i;
	});
	return l;
    }

    /**
      * Check if paper size is set and if not, then set the defaul
      * Don't change if already set
      * @param p map of printer to adjust paper size
      * @return map of printer with adjusted paper size
      */
    global define map adjustPaperSize (map p) ``{
	map options = p["options"]:$[];
	if (haskey (options, "PageSize"))
	    return p;
	string pagesize = Printerlib::getDefaultPaperSize () == 0 ? "A4" : "Letter";
	options["PageSize"] = pagesize;
	options["PageRegion"] = pagesize;
	options["ImageableArea"] = pagesize;
	options["PaperDimension"] = pagesize;
	p["options"] = options;
	return p;
    }


    /**
      * Inform user that function isn't available during preparatino of AI
      * via a popup
      */
    global define void DisplayUnavailableAIPopup () ``{
	// popup message
	UI::MessagePopup (_("This function is not available during
preparation for autoinstallation.
"));
    }

    /**
      * replaces all occurences of 'from' to 'to' in src
      * @param src input string
      * @param from string to be replaced
      * @param to string to be replaced by
      * @return string modified string
      */
    global define string replaceAll(string src, string from, string to) ``{
        if (from == "")
        {
            return src;
        }

        list tokens = [];

        integer p = find(src, from);
        while(p >= 0)
        {
            tokens = add(tokens, substring(src, 0, p));
            src = substring(src, p + size(from), size(src) - (p+size(from)));
            p = find(src, from);
        }
        tokens = add(tokens, src);
        return mergestring(tokens, to);
    }

    /**
      * Get printers (physical devices), which are configured
      * @return a list of printers maps (one queue of each printer)
      */
    global define list(map) getConfiguredPrinters () ``{
        list(string) ukeys = [];
        list(string) uris = [];
	list(string) models = [];
	list(map) printers = [];

        foreach (`p, Printer::printcap, ``{
            string ukey = p["unique_key"]:"";
            string uri = p["uri"]:"";
	    string model = p["vendor"]:"" + p["device"]:"";
	    if (p["ownppd"]:"" != "")
		model = p["ownppd"]:"";
	    if (model == "")
		model = p["vendor_ieee"]:"" + p["device_ieee"]:"";
	    if (model == "")
		model = p["vendor_db"]:"" + p["device_db"]:"";
            if ((! contains (ukeys, ukey)
		    && (! contains (uris, uri))
			|| ! contains (models, model)
		    )
		&& (((p["vendor"]:"" != ""
			    && p["device"]:"" != "")
			|| p["ownppd"]:"" != ""
		    )&& p["uri"]:"" != ""))
            {
                if (uri != "")
                    uris = add (uris, uri);
                if (ukey != "")
                    ukeys = add (ukeys, ukey);
		if (model != "")
		    models = add (models, model);
                printers = add (printers, p);
            }
        });

	return printers;
    }

    /**
      * List all queues of specified printer
      * @param uri of printer
      * @param vendor string printer vendor name
      * @param device string printer model name
      * @return a list of maps of queues
      */
    global define list(map) getQueuesOfPrinter (string uri, string vendor,
	string device)
    ``{
	list(map) queues = filter (`p, Printer::printcap, ``(
	    p["uri"]:"" == uri &&
		((p["vendor"]:"" == vendor && p["device"]:"" == device)
		||(p["vendor_db"]:"" == vendor && p["device_db"]:"" == device)
		||(p["vendor_ieee"]:"" == vendor && p["device_ieee"]:"" == device))
	    ));
	return queues;
    }

    /**
      * Has a printer (physical) been already configured (contains at least
      * one queue?
      * @param printer map containing at least vendor, device and
      *   unique_key keys for comparsionprinter vendor
      * @return boolean true if already configured
      */
    global define boolean isPrinterConfigured (map printer) ``{
	string vendor = printer["vendor"]:"";
	string device = printer["device"]:"";
	string ukey = printer["unique_key"]:"";
	string uri = printer["uri"]:"";
	if (uri == "")
	    uri = printer["bus"]:"parallel" + ":" + printer["dev_name"]:"";
	boolean exists = false;

	foreach (`p, Printer::printcap, ``{
	    if ((p["unique_key"]:"" == ukey && ukey != "")
		|| (p["uri"]:"" == uri && uri != ""
		    && ((p["vendor"]:".." == vendor
			    && p["device"]:".." == device)
			|| (p["vendor_db"]:".." == vendor
			    && p["device_db"]:".." == device)
			|| (p["vendor_ieee"]:".." == vendor
			    && p["device_ieee"]:".." == device))
		   ))
	    {
		exists = true;
	    }
	});
	return exists;
    }

    /**
      * Get proposed default queue when using foomatic db
      * @param list of queues
      * @return proposed default queue name
      */
    global define string getFoomaticDefaultQueue (list queues) ``{
	string default_queue = queues[0, "name"]:nil;
        foreach (`q, queues, ``{
            if (regexpmatch (q["name"]:"", "normal[0-9]")
                 || q["name"]:"" == "normal")
            {
                default_queue = q["name"]:"";
            }
        });
	return default_queue;
    }

    /**
      * Sort PPD files according to preference list
      * @param vendor string vendor name
      * @param model string model name
      * @param ppds list of PPD file nicknames
      * @return list of sorted PPD nicknames
      */
    global define list sortPpds (string vend, string mod, list ppds) ``{
        vend = SCR::Read (.ppd.db.vendorname, vend);
	mod = SCR::Read (.ppd.db.modelname, [vend, mod]);
        SCR::Execute (.target.bash, sformat ("/usr/bin/touch %1/ppd_preference_list", Printerlib::baseDataDir));
        map order = SCR::Read (.target.ycp, sformat ("%1/ppd_preference_list", Printerlib::baseDataDir));
        if (order == nil)
            order = $[];

        list(string) preferred = [];
        foreach (`k, `v, order, ``{
            if (regexpmatch (vend, k))
            {
                foreach (`kk, `vv, v, ``{
                    if (regexpmatch (mod, kk))
                    {
                        y2debug ("Matched %1, %2", k, kk);
                        preferred = order[k, kk]:[];
                    }
                });
                if (preferred == [])
                {
                    preferred = order[k, "__default__"]:[];
                }

            }
        });
        if (preferred == [])
            preferred = order["__default__"]:[];
        y2debug ("Order preferred list: %1", preferred);

	map recom = $[];
	map other = $[];

	foreach (`k, ppds, ``{
	    boolean found = false;
	    foreach (`i, preferred, ``{
		if (! found && regexpmatch (k, i))
		{
		    if (issubstring (k, "(recommended)"))
		    {
			recom[i] = add (recom[i]:[], k);
		    }
		    else
		    {
			other[i] = add (other[i]:[], k);
		    }
		    found = true;
		}

	    });
	    if (! found)
	    {
                if (issubstring (k, "(recommended)"))
                {
                    recom["other"] = add (recom["other"]:[], k);
                }
                else
                {
                    other["other"] = add (other["other"]:[], k);
                }
	    }
	});

	list result = [];

	y2debug ("Recom: %1, other: %2", recom, other);

	foreach (`i, preferred, ``{
	    result = merge (result, recom[i]:[]);
	});
	result = merge (result, recom["other"]:[]);

        foreach (`i, preferred, ``{
            result = merge (result, other[i]:[]);
        });
        result = merge (result, other["other"]:[]);

	y2debug ("Sorteed PPD files: %1", result);
	return result;
    }

    /**
      * Get auto queues for printer when using foomatic database
      * @param vendor string vendor db key
      * @param model string model db key
      * @param config string choosen ppd file, nil = auto
      * @return list of PPD files
      */
    global define list getFoomaticAutoQueues (string vendor, string model,
	string config)
    ``{
	list forbidden_names = Printer::getForbiddenNames ();
	y2debug ("Getting auto queues for >>%1<< >>%2<<", vendor, model);
	loadFoomaticIfNeeded ();
	list new_queues = [];
        map ppds = getPpdFiles (vendor, model);
	string ppdfile_orig = "";
	if (vendor == "__ownppd__")
	    ppdfile_orig = model;
	else if (config == nil || config == "")
            ppdfile_orig = getAutoPpdFile (ppds, vendor, model);
	else
	    ppdfile_orig = Printer::foomatic[vendor, model, config, 0]:"";
	y2debug ("Choosen PPD file: %1", ppdfile_orig);
        string config = ppds[ppdfile_orig]:"";
        string ppdfile = SCR::Read (.ppd.file.open,
	    [ppdfile_orig, SCR::Read (.target.tmpdir)]);
        map options = SCR::Read (.ppd.file.options, [ppdfile, ""]);
        list opts = options["data"]:[];
            integer ind = -1;
            boolean found = true;
            find (`i, opts, ``{
                ind = ind + 1;
                found = i["name"]:"" == "PrintoutMode";
                return found;
            });
            map composite = $[];
            if (found)
                composite = opts[ind]:$[];
            if (composite != $[])
            {
                foreach (`v, composite["valorder"]:[], ``{
                    string optname = composite["name"]:"";
		    string pagesize = Printerlib::getDefaultPaperSize () == 0 ? "A4" : "Letter";
                    map new_options = $[
                        optname : v,
			"PageSize" : pagesize,
			"PageRegion" : pagesize,
			"ImageableArea" : pagesize,
			"PaperDimension" : pagesize,
                    ];
                    new_queues = add (new_queues, $[
                        "config" : config,
                        "name" : mergestring (splitstring
			    (tolower (v), "."), "_"),
                        "comment" : composite["values", v]:v,
                        "database" : "foomatic",
                        "options" : new_options,
			"composite" : composite["name"]:"",
                    ]);

                });
            }
            else
            {
                new_queues = [ $[
                    "config" : config,
                    "name" : "lp",
                        // table cell
                    "comment" : _("default configuration"),
                    "database" : "foomatic",
                ]];
            }

            string suffix = Printer::getQueueSuffix (new_queues);
            new_queues = maplist (`v, new_queues, ``{
                v = add (v, "name", Printer::adjustQueueName (lookup (v, "name", "lp") + suffix, forbidden_names));
                if (nil == first_queue)
                {
                    first_queue = lookup (v, "name", "");
                }
                forbidden_names = add (forbidden_names, lookup (v, "name", ""));
                return union (Printer::printer, v);
        });
	y2debug ("Proposing queues %1", maplist (`q, new_queues, ``(q["name"]:"")));
	y2debug ("Proposed queues: %1", new_queues);
	return new_queues;
    }


    /**
      * Check whether foomatic database has been loaded, and if not, then
      * load it
      */
    global define void loadFoomaticIfNeeded () ``{
	if (Printer::foomatic != nil)
	    return;
        y2milestone ("Checking foomatic database");
        if (SCR::Read (.ppd.db.changed))
        {
            y2milestone ("Database changed");
	    boolean fast_update = false;
	    if (SCR::Read (.target.size, "/var/lib/YaST2/ppd_db_list") != -1)
	    {
		fast_update = true;
		SCR::Write (.ppd.db.check_method, `size);
	    }
	    SCR::Write (.ppd.db.create, "");
	    UI::OpenDialog (`VBox (
		`HSpacing (50),
		`ProgressBar (`id(`pr),
			// progress bar label
			_("The list of installed drivers has changed.
Building database of drivers..."), 100, 0)));
	    integer result = 0;
	    while (true)
	    {
		    result = SCR::Read (.ppd.db.creation_status);
		    if (result < 0)
		        break;
		    if (result == 100)
		        break;
		    UI::ChangeWidget (`id (`pr), `Value, result);
                    sleep (1000);
            }
	    UI::CloseDialog ();
	    if (result < 0)
	    {
		    // error report
		    Report::Error (_("An error occurred while creating the database
of printers.
"));
	    }
	    if (fast_update)
	    {
		SCR::Write (.ppd.db.check_method, `checksum);
	    }
        }
	SCR::Execute (.target.bash, "test -f /var/lib/YaST2/ppd_db_list && rm -f /var/lib/YaST2/ppd_db_list");
	Printer::foomatic= SCR::Read (.target.ycp, "/var/lib/YaST2/ppd_db.ycp");
    }

    /**
      * Get the PPD file for automatic installation
      * @param ppds map of ppd files
      * @param vend string vendor name
      * @param mod string model name
      * @return name of the PPD file
      */
    global define string getAutoPpdFile (map ppds, string vend, string mod) ``{
	list(string) names = [];
	map mapping = $[];
	foreach (`k, `v, ppds, ``{
	    mapping[v] = k;
	    names = add (names, v);
	});
	string ret = select (sortPpds (vend, mod, names), 0, "");
	return mapping[ret]:ret;
    }

    /**
      * get configurations, which may be usable for detected printer
      * @param vendor string name of printer vendor
      * @param device string printer model name
      * @return map of ppd files
      */
    global define map getPpdFiles (string vendor, string device) ``{
	string vendor_db = SCR::Read (.ppd.db.vendorname, vendor);
	map models = $[];
	string cache = filterchars (tolower (vendor_db),
	    "abcdefghijklmnopqrstuvwxyz0123456789");
        foreach (`k, `v, Printer::foomatic, ``{
	    if (filterchars (tolower (k),
		"abcdefghijklmnopqrstuvwxyz0123456789") == cache)
	    {
		models = v;
	    }
	});
	map ppds = $[];
	string device_db = SCR::Read (.ppd.db.modelname, [vendor_db, device]);
	cache = filterchars (tolower (device_db),
	    "abcdefghijklmnopqrstuvwxyz0123456789");
	foreach (`k1, `v1, models, ``{
	  if (is (k1, string))
	  {
	    foreach (`k2, `v2, v1, ``{
		if (is (k2, string) && size (v2) > 2)
		{
		    if (filterchars (tolower (select (v2, 2, "")),
			"abcdefghijklmnopqrstuvwxyz0123456789") == cache) // compare ieee1248 id
		    {
			ppds = add (ppds, select (v2, 0, ""), k2);
		    }
		    else if (filterchars (tolower (k1),
			"abcdefghijklmnopqrstuvwxyz0123456789") == cache)
		    {   // if it does not match, try printer name
			ppds = add (ppds, select (v2, 0, ""), k2);
		    }
		}
	    });
	  }
	});
	y2debug ("Possible PPDs: %1", ppds);
	return ppds;
    }

    /**
      * display CUPS initialization popup
      */
    global define void showCupsInitPopup () ``{
	// popup
	UI::OpenDialog(`opt(`decorated ),`VBox (
		// label
	    `Label(_("Initializing CUPS server...
This usually takes one or two minutes")),
	    `ProgressBar (`id (`cups_prog), "", 60 * 10)));
    }
    /**
      * start CUPS server and don't wait until initialization finishes
      */
    global define void startCupsServer () ``{
	integer status = SCR::Execute (.target.bash, "/etc/init.d/cups status");
	if (0 != status)
	{
	    SCR::Execute (.target.bash_background, "/etc/init.d/cups start");
	}
    }
    /**
      * check whether spooler (if needed to be running) runns, if not start it
      * @param showPopup boolean true if shall show a popup if needed
      */
    global define void restartSpoolerIfNeeded (boolean showPopup) ``{
	if (Mode::config)
	    return;
        if (Printer::spooler == "cups")
        {
            if (0 == Printer::cupsInstallationType ())
            {
		boolean close_dialog = false;
		integer status = SCR::Execute (.target.bash, "/usr/bin/lpq 2>/dev/null");
                if (status == 0)
                    return;
		if (SCR::Read (.target.size, "/etc/cups/ppds.dat") <= 0)
		{
		    close_dialog = true;
		    showCupsInitPopup ();
		}
                status = SCR::Execute (.target.bash, "/etc/init.d/cups status");
                if (0 != status)
		{
                    SCR::Execute (.target.bash_background, "/etc/init.d/cups start");
		    sleep (1000);
		}
                status = 1;
		integer attempts = 0;
                while (true)
                {
                    status = SCR::Execute (.target.bash, "/usr/bin/lpq 2>/dev/null");
                    if (status == 0)
                        break;
		    attempts = attempts + 1;
		    if (attempts > 5 && ! close_dialog)
		    {
			close_dialog = true;
			showCupsInitPopup ();
		    }
		    if (attempts>60*10)
		    {
			break;
		    }
                    if (close_dialog)
                        UI::ChangeWidget (`id (`cups_prog), `Value, attempts);
                    sleep (1000);
                    status = SCR::Execute (.target.bash, "/etc/init.d/cups status");
                    if (0 != status)
                    {
                        UI::MessagePopup (
                            // error popup
                            _("CUPS daemon died during initialization"));
			break;
                    }
                }
		if (close_dialog)
		{
		    UI::CloseDialog ();
		}
            }
        }
    }

    /**
     * Reinstall all printing related packages using package-manager
     * @return boolean true if success
     */
    global define boolean reinstallAll () ``{
	if (Mode::config)
	{
	    DisplayUnavailableAIPopup ();
	    return true;
	}
	import "PackageCallbacks";
	Printer::printcap = [];
	Printer::default = "";
	Printer::save_all = false;

	Printerlib::stopServices();
	list to_delete = ["plp", "lprold", "lprng", "cups", "cups-client", "cups-drivers", "cups-drivers-cs", "cups-drivers-de", "cups-drivers-stp",
	    "cups-libs", "cups-devel", "lpdfilter", "filters", "ghostscript-fonts-other", "ghostscript-x11", "ghostscript-fonts-std", "ghostscript-library",
	    "ghostscript-fonts-kanji", "ghostscript-serv", "ghostscript-fonts-rus", "ghostscript-library", "a2ps"];
	to_delete = filter (`e, to_delete, ``(Pkg::IsProvided (e) == true));

	list to_install = ["ghostscript-library", "ghostscript-x11", "ghostscript-fonts-std", "ghostscript-fonts-other", "a2ps", "cups-libs"];

	y2milestone("deleting: %1", to_delete);
	foreach (`e, to_delete, ``{Pkg::PkgDelete (e);});
	Pkg::PkgCommit (0);
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/cups/");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/lpdfilter/");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/printcap");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/printcap.rpm*");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/printcap-2*");
	SCR::Execute (.target.bash, "/bin/rm -rf /etc/printcap.y2*");
	SCR::Execute (.target.bash, "/bin/rm -rf /var/spool/lpd/");
	SCR::Execute (.target.bash, "/bin/rm -rf /var/spool/cups/");
	SCR::Execute (.target.bash, "/bin/rm -rf /var/lib/YaST2/printers");

	foreach (`e, to_install, ``{Pkg::PkgInstall (e);});

	y2milestone("installing: %1", to_install);
	Pkg::PkgSolve ();
	Pkg::PkgCommit (0);
	WFM::CallModule("inst_suseconfig", []);

	return true;

    }
    /**
     * Get hosts available on local network. Reads from .net.hostnames. Shows popup window: Wait please.
     * @param type "ipp", "samba", "lpd" or ""
     * @return list Sorted list of hosts.
     */
    global define list getHostnames (string type) ``{
        UI::OpenDialog (`opt (`decorated),
                         // text in dialog box
                         `Label (_("Scanning for hosts on this LAN...")));
        list hosts = [];
        if ("samba" == type)
            hosts = SCR::Read (.net.hostnames.samba);
        else if ("ipp" == type)
	{
            hosts = SCR::Read (.net.hostnames, 631);
	    hosts = filter (`h, hosts, ``{
		list queues = SCR::Read (.cups.remote, h);
		return size (queues) > 0;
	    });
	}
        else if ("lpd" == type || "filtering" == type || "prefilter" == type)
            hosts = SCR::Read (.net.hostnames, 515);
        else if ("socket" == type)
            hosts = SCR::Read (.net.hostnames, 9100);
        else if ("" != type)
	    hosts = SCR::Read (.net.hostnames, tointeger (type));
	else
            hosts = SCR::Read (.net.hostnames);
        if (nil == hosts)
            hosts = [];
        UI::CloseDialog ();
        return sort (hosts);
    }

    /**
      * Get list of possible banners for CUPS server
      * @return list banners names
      */
    global define list getBannerList () ``{
        map out = SCR::Execute (.target.bash_output, "/bin/ls -1 /usr/share/cups/banners");
        list ban = splitstring (lookup (out, "stdout", ""), "\n");
        ban = toset (add (ban, "none"));
        return filter (`i, ban, ``("" != i));
    }
    /**
     * Return list without item.
     * @param source source list
     * @param item item to delete
     * @return list List without item. If item was not present in list, list is unchanged.
     */
    global define list DeleteItem (list source, any item) ``{
        return filter (`i, source, ``{
            return i != item;
        });
    }
    /**
      * Test whether spooler supports queue type
      * @param queue string queue type (eg. parallel)
      * @param spooler string "cups" or "lprng"
      * @return boolean true if supports
      */
    global define boolean testSupportedQueueBySpooler (string queue, string spooler) ``{
	map supported = $[ "cups" : [ "parallel", "usb", "serial", "filtering", "ipp", "samba", "socket", "irda", "file", "class", "novell", "pipe", ],
			   "lprng" : [ "parallel", "usb", "serial", "lpd", "prefilter", "samba", "novell", "irda", "filtering", "socket", "pipe", "file", ]];
	list l = lookup (supported, spooler, []);
	if (l == [])
	    return true;
	return contains (l, queue);
    }
    /**
      * Test whether currently used spooler supports queue type
      * @param queue string queue type (eg. parallel)
      * @return boolean true if supports
      */
    global define boolean testSupportedQueue (string queue) ``{
	return testSupportedQueueBySpooler (queue, Printer::spooler);
    }
    /**
     * Displays message when baud rate is 0.
     * @param brate Baud rate.
     * @return boolean Is baud rate ok?
     */
    global define boolean testBaudRate (integer brate) ``{
	if (brate == 0)
	    {
		// message box
		UI::MessagePopup (_("The baud rate should not be 0!"));
		return false;
	    }
	return true;
    }
    /**
     * Is the hostname correct? Check it for allowed characters. Display message if bad hostname.
     * @param name Hostname to check
     * @return boolean true if hostname is correct.
     */
    global define boolean checkHostName (string name) ``{
	if (size (name) > 0 &&
	    /*size (name) < 50 &&*/
	    "" == filterchars (name,
				":/@"))
	    {
		return true;
	    }
	else
	    {
		// message box
		// the ',' character isn't separator,
		//  but one of a list of characters
		UI::MessagePopup (_("Invalid host name. It must be
shorter than fifty characters and cannot contain
:, / or @.
"));
	    }
	return false;
    };

   /**
     * Is the username correct? Check it for allowed characters. Display message if bad username.
     * @param name Username to check
     * @return boolean true if username is correct.
     */
    global define boolean checkUserName (string name) ``{
        if (/*size (name) > 0 &&
            size (name) < 50 &&*/
            "" == filterchars (name,
                                ":/@"))
            {
                return true;
            }
        else
            {
                // message box
                // the ',' character isn't separator,
                //  but one of a list of characters
                UI::MessagePopup (_("Invalid user name. It cannot 
contain the characters : , / @.
"));
            }
        return false;
    };

   /**
     * Is the password correct? Check it for allowed characters. Display message if bad password.
     * @param name password to check
     * @return boolean true if hostname is correct.
     */
    global define boolean checkPassword (string name) ``{
        if (/*size (name) > 0 &&
            size (name) < 50 &&*/
            "" == filterchars (name,
                                ":/@"))
            {
                return true;
            }
        else
            {
                // message box
                // the ',' character isn't separator,
                //  but one of a list of characters
                UI::MessagePopup (_("Invalid password. It cannot 
contain the characters : , / @.
"));
            }
        return false;
    };



    /**
     * Check if remote_printer is not nil. Display message otherwise.
     * @param remote_printer Printer name to check
     * @return boolean true if name is OK
     */
    global define boolean checkRemotePrinter (string remote_printer) ``{
	if ("" != remote_printer)
	    {
		return true;
	    }
	// message box
	UI::MessagePopup ( _("Please choose which forwarding
queue you want to use."));
	return false;
    };

    /**
      * generate class name
      * @param forbidden_names list of forbidden names
      * @return new class name
      */
    global define string generateClassName (list forbidden_names) ``{
	string name = "class1";
	integer i = 2;
	while (contains (forbidden_names, name))
	{
	    name = sformat ("class%1", i);
	    i = i + 1;
	}
	return name;
    }

    /**
     * FIXME: create test case
     * @param name printer name
     * @param forbidden_names list of forbidden names
     * @return new queue name
     */
    global define string generateQueueName (string name, list forbidden_names) ``{
	integer i = 1;
	while (contains (forbidden_names, name))
	{
	    name = sformat ("printer%1", i);
	    i = i + 1;
	}
	return name;
    }
    /**
     * Saves printer under some new name and tests it.
     * It can also create NEW prefilter queue for it.
     * @param printer map of printer to test
     * @param testpage_type type of page. Now supports only (0==ps, 1==ascii)
     * @return boolean true if success
     */
    global define boolean testPrinter (map printer, integer testpage_type) ``{
	if (Mode::config)
	{
	    DisplayUnavailableAIPopup ();
	    return true;
	}

	boolean do_not_test = false;
	boolean foomatic = printer["database"]:"" == "foomatic";

	if (foomatic)
	    loadFoomaticIfNeeded ();

	if (Printer::getPrinterState(printer, Printer::spooler) == "void")
	    do_not_test = true;

	if (do_not_test) {
	    // message popup
	    UI::MessagePopup (_("Unable to print a test page. You are using different spooler."));
	    return false;
	}

	restartSpoolerIfNeeded (true);
	if (Printer::spooler != "lprng" && Printer::spooler != "cups")
	{
	    // message box
	    UI::MessagePopup (_("Unable to print a test page. 
Install a spooler 
before printing test pages.
"));
	    return true;
	}
	if (testpage_type != -1)
	{
	    // message box
	    if (!UI::AnyQuestionPopup ("", _("Ready to print a sample page.

Make sure the printer is turned
on and ONLINE then press the 'OK' button.
"),
		    OKButtonLabel (), CancelButtonLabel (), `focus_yes))
	    {
		return ;
	    }
	}
	else
	{
	    UI::OpenDialog (
		`VBox (
		    // label
		    `Label (_("Ready to print a sample page.

Select the test page type, make sure 
the printer is turned on and ONLINE, then 
press 'OK'.
")),
		    `VSpacing (1),
		    `RadioButtonGroup (`id (`type), `VBox (
			// radiobutton
			`Left (`RadioButton (`id (`graphic), _("Test &graphical printing"))),
			// radiobutton
			`Left (`RadioButton (`id (`ascii), _("Test &text printing")))
		    )),
		    `VSpacing (1),
		    `HBox (
			// pushbutton
			`PushButton (`id (`ok), `opt (`key_F10, `default), OKButtonLabel ()),
			// pushbutton
			`PushButton (`id (`cancel), `opt (`key_F9), CancelButtonLabel ())
		    )
		)
	    );
	    UI::ChangeWidget (`id (`type), `CurrentButton, `graphic);
	    symbol ret = nil;
	    while (nil == ret)
	    {
		ret = UI::UserInput ();
		if (ret == `cancel)
		{
		    UI::CloseDialog ();
		    return;
		}
		if (ret == `ok)
		{
		    if (UI::QueryWidget (`id (`type), `CurrentButton) == `ascii)
			testpage_type = 1;
		    else
			testpage_type = 0;
		    break;
		}
		ret = nil;
	    }
	    UI::CloseDialog ();
	}

	// create new name for the printer
	list forbidden_names = union (Printer::getForbiddenNames (), Printer::DeletedNames ());
	string virtual_name = lookup (printer, "name", "");
	string name = Printer::adjustQueueName ("y2test", forbidden_names);
	string uri = lookup (printer, "uri", "");
	string printer_type = uri == "class" ? "class" : "printer";
	printer = add (printer, "name", name);
	printer = add (printer, "recreate", true);
	// is it pre-filter queue?
	map prefilter = $[];
	string prefilter_name = "";

	if ("prefilter" == Printerlib::getUriType (uri) && "cups" != Printer::spooler)
	{
	    prefilter_name = Printer::adjustQueueName ("y2test", add (forbidden_names, name));
	    if (lookup (printer, "create_remote_queue", false))
	    {
		prefilter = $[
		    "name" : prefilter_name,
		    "uri" : "lpd://" + lookup (printer, "remote_host", "") + "/" + lookup (printer, "remote_printer", ""),
		    ];
	    }
	    else
	    {
		string use_prefilter = Printerlib::getUriRemoteQueue (uri);
		foreach (`i, Printer::printcap, ``{
			if (use_prefilter == lookup (i, "name", ""))
			{
			    prefilter = i;
			}
		    });
		prefilter = add (prefilter, "name", prefilter_name);
	    }
	    prefilter = add (prefilter, "recreate", true);
	    printer = add (printer, "uri", "prefilter://" + prefilter_name);
	}

	printer = Printer::fixPrinter (printer);
	y2debug ("Printer for testpage: %1", printer);
	if (Printer::spooler == "cups")
	{
	    Printer::writeCupsPrinter (printer);
	}
	else
	{
	    //
	    // backup printcap
	    //
	    SCR::Execute (.target.bash, "/bin/cp /etc/printcap /etc/printcap.y2bak");

	    //
	    // write printer and possibly prefilter
	    //
	    if (!Printer::writeLpdPrinter (printer))
		return false;
	    if ($[] != prefilter)
	    {
		if (!Printer::writeLpdPrinter (prefilter))
		    return false;
	    }

	    //
	    // restart lpd
	    //
	    SCR::Execute (.target.bash, "/etc/init.d/lpd restart");
	}
	//
	// print test page
	// to queue: name
	// but tell user it is queue: virtual_name
	string switch = " -P" + name;
	string test_page = "";
	if (0 == testpage_type)
	{
	    map consolefonts = SCR::Read (.target.yast2, "consolefonts.ycp");
	    string ce = select (lokup (consolefonts, UI::GetLanguage (false), []), 4, "X");
	    string opts = SCR::Read (.target.tmpdir) + "/testpg.options";
	    string os = "";
	    // encoding first
	    ce = toupper (ce);
	    if (ce != "ISO-8859-2" && ce != "ASCII" && ce != "ISO-8859-15"
		&& ce != "ISO-8859-1")
	    {
		ce = toupper (_("!!!  YOUR  ENCODING  !!!"));
	    }
	    if (ce != "ISO-8859-2" && ce != "ASCII" && ce != "ISO-8859-15"
		&& ce != "ISO-8859-1")
	    {
		ce = "ASCII";
	    }

	    string enc = "ISO-8859-2" == ce ? "h02" : "h01";
	    os = os + sformat ("----X-ENCODING: %1\n", enc);

	    os = os + sformat ("----X-VENDOR: (%1 %2)\n",
		printer["vendor"]:"",
		printer["device"]:"");
	    os = os + sformat ("----X-CONFIG: (%1)\n",
		printer["config"]:"");
	    // TRANSLATORS: keep this short! Only translations in languages
	    // with encodings ISO-8859-[1|2|15] will be used.
	    os = os + sformat ("----X-QUEUE-L: (%1)\n", _("Print queue:"));
            // TRANSLATORS: keep this short! Only translations in languages
            // with encodings ISO-8859-[1|2|15] will be used.
	    os = os + sformat ("----X-PRINTER-L: (%1)\n", _("Printer:"));
	    os = os + sformat ("----X-CONFIG-L: (%1)\n",
		// TRANSLATORS: keep this short! Only
		// translations in languages
		// with encodings ISO-8859-[1|2|15] will be used.
		_("Configuration:"));
            // TRANSLATORS: keep this short! Only translations in languages
            // with encodings ISO-8859-[1|2|15] will be used.
	    os = os + sformat ("----X-OPTION-L: (%1)\n", _("Options:"));
            // TRANSLATORS: keep this short! Only translations in languages
            // with encodings ISO-8859-[1|2|15] will be used.
	    os = os + sformat ("----X-HEAD: (%1)\n", _("YaST2 test page"));

	    // options
	    string filename = SCR::Read (.ppd.file.open,
		[Printer::foomatic[
		    printer["vendor_db"]:"",
		    printer["device_db"]:"",
		    printer["config"]:"", 0]:"",
		SCR::Read (.target.tmpdir)]);
	    map options = SCR::Read (.ppd.file.options, [filename, ""]);
	    list optlist = options["data"]:[];
	    optlist = maplist (`i, optlist, ``{
		    string name = i["name"]:"";
		    string label = i["gui"]:"";
		    string value = printer["options", name]:"";
		    if (value == "")
			value = i["current"]:"";
		    string valuelabel = i["values", value]:"";
		    if (label == "")
			label = name;
		    if (valuelabel == "")
			valuelabel = value;
		    if (label != "" && valuelabel != "")
			return sformat ("(%1: %2) mm", label, valuelabel);
		    else
			return "";
	    });
	    optlist = filter (`o, optlist, ``(o != "" && o != nil));
	    os = os + mergestring (optlist, "\n");

	    if (ce != "X")
	    {
		    os = UI::Recode ("UTF-8", ce, os);
	    }
	    SCR::Write (.target.string, opts, os);
	    test_page = Printerlib::preparePsTestPage
		(virtual_name, opts, true);
	}
	else
	{
	    test_page = Printerlib::prepareAsciiTestPage ();
	}
	string lpr_command = sformat ("/usr/bin/lpr -P%1 %2", name, test_page);
	map out = SCR::Execute (.target.bash_output, lpr_command);
	if (lookup (out, "exit", 0) != 0)
	{
	    UI::MessagePopup (
		// message box
		sformat (_("Unable to print the test page.

Output from lpr:
"), test_page) +
		lookup (out, "stderr", ""));
	    Printer::deletePrinters ([$["name": name, "type": printer_type ], $["name" : prefilter_name, "type": printer_type]]);
	    return false;
	}

	if (false == OkOrStopPrinting (sformat ("lpr -P%1 %2", virtual_name, test_page)))
	{ // Problems, stop the printing!
	    if (Printer::spooler != "cups")
		SCR::Execute (.target.bash, "/etc/init.d/lpd stop");

	    string contype = Printerlib::getUriType (uri);
	    if (contype == "parallel" || contype == "serial" || contype == "usb")
	    {
		string device = Printerlib::getUriDevice (uri);
		if (device != "")
		{
		    SCR::Execute (.target.bash, sformat ("/bin/fuser -k %1", device));  // kill currently printing processes
		}
		if (contype == "parallel" && "/dev/lp" == substring (device, 0, 7))
		{
		    //
		    // do printer_reset only if we are sure that the device is /dev/lp, because
		    // now user may add anything as parallel device and we should send this ioctl
		    // only to parallel port
		    //
		    SCR::Execute (.target.control.printer_reset, device);
		}
	    }

	    SCR::Execute (.target.bash, "/bin/rm `/usr/bin/find /var/spool/lpd -name \"[cd]f*\" -type f`"); // remove all jobs
	    if (Printer::spooler != "cups")
		SCR::Execute (.target.bash, "/etc/init.d/lpd start"); // restart lpd

	    // message box
	    UI::MessagePopup (_("Printing was stopped.

If the printer is still printing, push the reset button
on the printer or remove all the paper from its tray.
After it stops printing, switch off the printer power,
wait 10 seconds and switch it on again.

Again, check the manufacturer and printer model entries
you made previously."));
	}
	else
	{ // don't show notice regarding testing in proposal more
	    Printer::tested = true;
	}
	Printer::deletePrinters ([$["name": name, "type": printer_type], $["name" : prefilter_name, "type": printer_type]]);
//	SCR::Execute (.target.bash, sformat ("/bin/rm /var/lib/YaST2/printers/y2test; \n"));
	return true;
    }
    /**
     * We need this wrapper because of wizard sequencer.
     * @return `next for wizard sequencer
     */
    global define symbol storePrinter () ``{
	Printer::storePrinter ();
	return `next; // because of wizard sequencer
    }

    /**
     * Get items for selection box of all fwd queues.
     * @param queue queue to pre-select in selection box
     * @return list list of items
     */
    global define list getForwardingQueues (string queue) ``{
	list q = Printer::ForwardingQueues ();
	return maplist (`i, q, ``((i == queue) ?
		    `item (`id (i), i, true) :
		    `item (`id (i), i)));
    }

    /**
     * Shows dialog box that allows user to stop printing.
     * @param pr_command Command that was used to start printing. Showed in text field.
     * @return boolean true if printing has to be stopped
     */
    global define boolean OkOrStopPrinting (string pr_command) ``{
	// message box with [OK] [Stop]
	string text = sformat (_("The test page was sent to the printer using
the command '%1'.
Printing should start in a few seconds.

If the printer is not producing the appropriate
output, use the 'Stop!' button.

When the whole page is printed, press
'Printout finished'."), pr_command);
	// push button
	return UI::AnyQuestionPopup (NoHeadline (), text, _("Printout &finished"), StopButtonLabel (), `focus_yes);
    }

    /**
     * Ask if really abort. Uses boolean Printer::dirty. Sets boolean do_abort_now.
     * @return boolean true if user really wants to abort
     */
    global define boolean reallyAbort ()``{
	boolean abort_now = false;
	if (abort_now || !Printer::dirty)
	    {
		return true;
	    }
	abort_now = UI::ReallyAbortPopup (true);
	return abort_now;
    }

    /**
     * Ask if really exit. Uses boolean Printer::dirty. Sets boolean do_abort_now.
     * @return boolean true if user really wants to abort
     */
    global define boolean reallyExit ()``{
        if (!Printer::dirty)
            {
                return true;
            }
	return UI::AnyQuestionPopup( NoHeadline(),
// question popup
_("Really leave printer configuration without saving?
All changes will be lost.
"),
                                      YesButtonLabel(),
                                      NoButtonLabel(),
                                      `focus_no );

    }

    /**
     * FIXME: remove this function
     * Is it known connection?
     * @param con connection
     * @return boolean true if it is known connection
     */
    global define boolean knowConnection (string con) ``{
        return (
            (contains (["file", "parallel", "usb", "serial", "ipp", "lpd", "samba", "socket", "filtering", "irda", "prefilter", "novell", "pipe" ], con)) ?
            con : ""
            );
    }

    /**
     * Create the content of the selection box with all connections
     * @param type type of connection to pre-select.
     * @return List of items. Item of Id is its name.
     */
    global define list advancedConnectionsRadioButtons (string type, boolean queue) ``{
	if (size (getConfiguredPrinters ()) == 0)
	    queue = false;

	return Printer::spooler == "cups" ?
		`VBox (
		    // radiobutton
		    queue ? `RadioButton (`id (`existing), `opt (`hstretch), _("N&ew Queue to Configured Printer"), type == "queue") : `VSpacing (0),
		    // label
		    `Label (`opt (`hstretch), _("LPD and IPP network printing:")),
		    // radiobutton
                    `RadioButton (`id (`filtering),`opt (`hstretch), _("LPD fil&tering and forwarding queue"), type == "filtering"),
		    // radiobutton
		    `RadioButton (`id (`ipp), `opt (`hstretch),    _("&IPP filtering and forwarding queue"), type == "ipp"),
		    // label
		    `Label (`opt (`hstretch), _("Other network printing:")),
		    // radiobutton
		    `RadioButton (`id (`samba), `opt (`hstretch),    _("SMB Printing (Samba/&Windows printer)"), type == "samba"),
		    // radiobutton
                    `RadioButton (`id (`novell), `opt (`hstretch),   _("IPX printing (Nove&ll printer)"), type == "novell"),
		    // radiobutton
		    `RadioButton (`id (`socket), `opt (`hstretch),    _("Direct TCP port printin&g (network printer)"), type == "socket"),
		    // label
		    `Label (`opt (`hstretch), _("Other:")),
		    // radiobutton
		    `RadioButton (`id (`pipe), `opt (`hstretch),     _("&Pipe Printing"), type == "pipe"),
		    // radiobutton
		    `RadioButton (`id (`other), `opt (`hstretch),  _("&Other Printer (set URI)"), "" == knowConnection (type) && type != "class"),
		    // radiobutton
		    `RadioButton (`id (`class), `opt (`hstretch),  _("CUPS &class"), type == "class"),
		    // label
		    `Label (`opt (`hstretch), _("Unsupported printing in CUPS:")),
		    // radiobutton
                    `RadioButton (`id (`remote), `opt (`hstretch, `disabled),     _("LPD &forwarding queue"), type == "lpd"),
		    // radiobutton
                    `RadioButton (`id (`prefilter),`opt (`hstretch, `disabled), _("Prefilter queue for a LPD forwarding &queue"), type == "prefilter")//,
		    // radiobutton
//                    `RadioButton (`id (`novell), `opt (`hstretch, `disabled),   _("IPX printing (Nove&ll printer)"), type == "novell"),
		    // radiobutton
//		    `RadioButton (`id (`pipe), `opt (`hstretch, `disabled),     _("&Pipe Printing"), type == "pipe")
		    )
		: Printer::spooler == "lprng" ?
                `VBox (
		    // radiobuton
		    queue ? `RadioButton (`id (`existing), `opt (`hstretch), _("N&ew Queue to Configured Printer"), type == "queue") : `VSpacing (0),
		    // label
                    `Label (`opt (`hstretch), _("LPD and IPP network printers:")),
		    // radiobutton
                    `RadioButton (`id (`remote), `opt (`hstretch),      _("LPD &forwarding queue"), type == "lpd"),
		    // radiobutton
                    `RadioButton (`id (`prefilter),`opt (`hstretch), _("Prefilter queue for a LPD forwarding &queue"), type == "prefilter"),
		    // radiobutton
                    `RadioButton (`id (`filtering),`opt (`hstretch), _("LPD fil&tering forwarding queue"), type == "filtering"),
		    // label
		    `Label (`opt (`hstretch), _("Other network printing:")),
		    // radiobutton
                    `RadioButton (`id (`samba), `opt (`hstretch),    _("SMB Printing (Samba/&Windows printer)"), type == "samba"),
		    // radiobutton
                    `RadioButton (`id (`novell), `opt (`hstretch),   _("IPX printing (Nove&ll printer)"), type == "novell"),
		    // radiobutton
		    `RadioButton (`id (`socket), `opt (`hstretch),    _("Direct TCP port printin&g (network printer)"), type == "socket"),
		    // label
		    `Label (`opt (`hstretch), _("Other printing:")),
		    // radiobutton
		    `RadioButton (`id (`pipe), `opt (`hstretch),     _("&Pipe Printing"), type == "pipe"),
		    // label
		    `Label (`opt (`hstretch), _("Unsupported printing in LPRng:")),
		    // radiobutton
                    `RadioButton (`id (`ipp), `opt (`hstretch, `disabled),    _("&IPP filtering and forwarding queue"), type == "ipp"),
		    // radiobutton
		    `RadioButton (`id (`other), `opt (`hstretch, `disabled),   _("&Other Printer (set URI)"), "" == knowConnection (type) && type != "class"),
		    // radiobutton
		    `RadioButton (`id (`class), `opt (`hstretch, `disabled),  _("CUPS &class"), type == "class")
                    )
		: //unknown spooler
		`VBox (
		    // radiobutton
		    queue ? `RadioButton (`id (`existing), `opt (`hstretch), _("N&ew Queue to Configured Printer"), type == "queue") : `VSpacing (0),
		    // label
                    `Label (`opt (`hstretch), _("LPD and IPP network printing:")),
		    // radiobutton
                    `RadioButton (`id (`remote), `opt (`hstretch),      _("LPD &forwarding queue"), type == "lpd"),
		    // radiobutton
                    `RadioButton (`id (`prefilter),`opt (`hstretch), _("Prefilter& queue for a LPD forwarding queue"), type == "prefilter"),
		    // radiobutton
                    `RadioButton (`id (`filtering),`opt (`hstretch), _("LPD fil&tering and forwarding queue"), type == "filtering"),
		    // radiobutton
                    `RadioButton (`id (`ipp), `opt (`hstretch),    _("&IPP filtering and forwarding queue"), type == "ipp"),
		    // label
                    `Label (`opt (`hstretch), _("Other network printing:")),
		    // radiobutton
                    `RadioButton (`id (`samba), `opt (`hstretch),    _("SMB Printing (Samba/&Windows printer)"), type == "samba"),
		    // radiobutton
                    `RadioButton (`id (`novell), `opt (`hstretch),   _("IPX printing (Nove&ll printer)"), type == "novell"),
		    // radiobutton
                    `RadioButton (`id (`socket), `opt (`hstretch),    _("Direct TCP port printin&g (network printer)"), type == "socket"),
		    // label
                    `Label (`opt (`hstretch), _("Other:")),
		    // radiobutton
                    `RadioButton (`id (`other), `opt (`hstretch),  _("&Other Printer (set URI)"), "" == knowConnection (type) && type != "class"),
		    // radiobutton
                    `RadioButton (`id (`pipe), `opt (`hstretch),     _("&Pipe Printing"), type == "pipe"),
		    // radiobutton
                    `RadioButton (`id (`class), `opt (`hstretch),  _("CUPS &class"), type == "class")
		);
    }
    /**
     * Create the content of the selection box with all connections
     * @param type type of connection to pre-select.
     * @param all show all possible connections (true) or only local connections (false)?
     * @return List of items. Item of Id is its name.
     */
    global define list connectionsRadioButtons (string type, boolean all, boolean queue) ``{
        if (size (getConfiguredPrinters ()) == 0)
            queue = false;

        return all ?
	    `VBox (
		    // radiobutton
		queue ? `RadioButton (`id (`existing), `opt (`hstretch), _("N&ew Queue to Configured Printer"), type == "queue") : `VSpacing (0),
		    // label
		`Label (`opt (`hstretch), _("Local printing:")),
		    // radiobutton
		`RadioButton (`id (`parallel), `opt (`hstretch), _("&Parallel printer"), type == "parallel"),
		    // radiobutton
		`RadioButton (`id (`usb), `opt (`hstretch),      _("&USB printer"), type == "usb"),
		    // radiobutton
		`RadioButton (`id (`serial), `opt (`hstretch),   _("&Serial printer"), type == "serial"),
		    // radiobutton
		`RadioButton (`id (`irda), `opt (`hstretch),     _("IrD&A printer"), type == "irda"),
		    // radiobutton
//		`RadioButton (`id (`file), `opt (`hstretch),     _("&Disk file"), type == "file"),
		    // label 1/3
		`Label (`opt (`hstretch), _("Expert printer setup, such as LPD, IPP, Samba/Windows")),
		    // label 2/3
		`Label (`opt (`hstretch), _("Novell Netware and direct TCP socket network")),
		    // label 3/3
		`Label (`opt (`hstretch), _("printing and other queue types")),
		    // radiobutton
		`RadioButton (`id (`more), `opt (`hstretch),	 _("Show &more connection types..."), ! contains (["parallel", "usb", "serial", "irda", "file"], type))
	    )
	    :
	    `VBox (
		    // label
		`Label (`opt (`hstretch), _("Local printing:")),
		    // radiobutton
		`RadioButton (`id (`parallel), `opt (`hstretch), _("&Parallel printer"), type == "parallel"),
		    // radiobutton
		`RadioButton (`id (`usb), `opt (`hstretch),      _("&USB printer"), type == "usb"),
		    // radiobutton
		`RadioButton (`id (`serial), `opt (`hstretch),   _("&Serial printer"), type == "serial"),
		    // radiobutton
		`RadioButton (`id (`irda), `opt (`hstretch),     _("IrD&A printer"), type == "irda")//,
		    // radiobutton
//		`RadioButton (`id (`file), `opt (`hstretch),     _("&Disk file"), type == "file")
	    );
    }

    /**
     * Get list of available devices in nice-names.
     * @param dev list of devices to show
     * @param device device that should be selected. If "" then first device will be selected.
     * @return list Items for selection box. One of the items is selected.
     */
    global define list getDevicesItems (list dev, string device) ``{
	list device_val = [];
	boolean default_selected = false;
	foreach (`dev, devices, ``{
	    boolean this_is_selected = (("" != device && dev == device) ||
					("" == device && (dev == "/dev/lp0" ||
							  dev == "/dev/usblp0" ||
							  dev == "/dev/usb/lp0" ||
							  dev == "/dev/ttyS0")));
	    if (this_is_selected)
		default_selected = true;
	    device_val = add (device_val, `item (`id (dev), Printerlib::getDeviceNiceName (dev, false), this_is_selected));
	});
	if (!default_selected)
	    device_val = add (device_val, `item (`id (device), device, true));
	return device_val;
    }
    /**
     * Create the content of table of all entries in the printcap.
     * @return List of items. Item id is index of printer in printcap.
     */
    global define list printcapTable () ``{
	integer count = 0;
	Printer::sortPrinters ();
	return maplist (`ent, Printer::printcap, ``{
		string name = lookup (ent, "name", "???");
		term ret =
		    `item (
			`id (count),
			name == Printer::default ? UI::Glyph (`BulletArrowRight) : " ",
			lookup (ent, "name", ""));

		if ("yast2" == lookup (ent, "type", "yast2"))
		{
		    string description = Printerlib::getUriNiceName (lookup (ent, "uri", ""));
		    if ("void" == Printer::getPrinterState (ent, Printer::spooler))
			// table item. SHORT!
			description = _("- invalid for selected spooler -");
		    ret = add (ret, description);
		}
		else
		    // This printer was not configured using YaST2. Item in table. SHORT!
		    ret = add (ret, _("- not YaST2 -"));
		if (Printer::spooler == "cups" || Printer::spooler == "lprng")
		{
		    if ("yast2" == lookup (ent, "type", "yast2"))
			// table item. SHORT
			ret = add (ret, "commited" == Printer::getPrinterState (ent, Printer::spooler) ? _("OK") : "");
		    else
			// table item. SHORT
			ret = add (ret, _("unknown"));
		}
		else
		{
			// table item. SHORT
		    ret = add (ret, "void" != Printer::getPrinterState (ent, "cups") ? _("OK") : "");
			// table item. SHORT
		    ret = add (ret, "void" != Printer::getPrinterState (ent, "lprng") ? _("OK") : "");
		}
		count = count+1;
		return ret;
	});
    }

    /**
      * Is the name of local queue correct? If not, display message.
      * @param name string queue name
      * @return boolean true if correct
      */
    global define boolean checkLocalQueueName (string name) ``{
	if (size (name) > 0 && size (name) < 127 &&
	    size (filterchars (substring (name, 0, 1),
		"abcdefghijklmnopqrstuvwxyz")) > 0 &&
	    name == filterchars (name,
		"_0123456789abcdefghijklmnopqrstuvwxyz"))
	    {
		return true;
	    }
	    else
	    {
		// popup
		 UI::MessagePopup (_("Invalid queue name. It must be
shorter than 127 characters, start with a letter,
and only contain 0...9, a...z, and _.
"));
		return false;
	    }
    }

    /**
     * Is the name of the remote printer correct? If not, display message.
     * @param name Hostname to check
     * @return boolean true if hostname is correct.
     */
    global define boolean checkQueueName (string name) ``{
	if (size (name) > 0 && /*size (name) < 30 &&
	    size (filterchars (substring (name, 0, 1),
		    "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")) > 0 &&*/
	    "" == filterchars (name,
				"@:"))
	    {
		return true;
	    }
	else
	    {
		// message box
		UI::MessagePopup (_("Invalid remote queue name. 
It cannot contain the characters @ and :.
"));
	    }
	return false;
    }

    /**
     * Check first and optionally 3rd name. 2nd name is 1st name+"-ascii" so it does not bother us,
     * but is checked because of length. Do not allow '-' in names. Do not allow name lp<number>.
     * In names are not OK, show dialog
     *
     * @param forbidden_names list of names that were already used
     * @param name name for current printer
     * @return boolean true if names are OK.
     */
    global define boolean checkName (list forbidden_names, string name) ``{
	boolean ok = true;
	if (size (name)<=0 ||
		size (name)>=20 ||
		name != filterchars (name, "_0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-") ||
		contains (forbidden_names, name) ||
		substring (name, 0, 1) == "-" ||
		"all" == name
		)
	{
	    // message box
	    UI::MessagePopup (_("Invalid name! The name should be less than 20 characters long
and can only use the characters 0..9, a..z, - and _. It must
not start with -. Additionally, you cannot use the name 'all' 
because of its special function.

The name must not be used for another printer."));
	    return false;
	}
	if (contains (Printer::getSystemForbiddenNames (), name))
	{
	    // message box
	    UI::MessagePopup (_("Invalid name! The name must not be used
for any file in directory /etc/lpdfilter"));
	    return false;
	}
	return true;
    }
    /**
     * Get value from UI
     * @param vals values
     * @return selected value
     */
    global define any grabValueUI (any vals) ``{
	if (is (vals, list))
	{
	    return UI::QueryWidget (`id (`vals), `CurrentItem);
	}
	if (is (vals, term))
	{
	    if (`text == symbolof (vals))
	    {
		string c = UI::QueryWidget (`id (`vals), `Value);
		return regexpsub (c, "(" + select (vals, 0, ".*") + ")", "\\1");
	    }
	    if (true == UI::QueryWidget (`id (`vals2), `Value))
	    {
		UI::ChangeWidget (`id (`vals), `Enabled, false);
		return nil;
	    }
	    UI::ChangeWidget (`id (`vals), `Enabled, true);
	    if (`int == symbolof (vals))
	    {
		integer i = UI::QueryWidget (`id (`vals), `Value);
		if (0 != select (vals, 2, 0))
		{
		    i = i - select (vals, 0, 0);
		    i = i / select (vals, 2, 1);
		    i = i * select (vals, 2, 1);
		    i = i + select (vals, 0, 0);
		    if (i < select (vals, 0, 0))
			i = select (vals, 0, 0);
		    if (i > select (vals, 1, select (vals, 0, 0) + 1))
			i = select (vals, 1, select (vals, 0, 0) + 1);
		}
		return i;
	    }
	    if (`float == symbolof (vals))
	    {
		float i = tofloat (UI::QueryWidget (`id (`vals), `Value));
		if (0 != select (vals, 2, 0))
		{
		    i = i - select (vals, 0, 0);
		    i = i / select (vals, 2, 1);
		    i = i * select (vals, 2, 1);
		    i = i + select (vals, 0, 0);
		    if (i < select (vals, 0, 0))
			i = select (vals, 0, 0);
		    if (i > select (vals, 1, select (vals, 0, 0) + 1))
			i = select (vals, 1, select (vals, 0, 0) + 1);
		}
		return i;
	    }
	}
	return nil;
    }
    /**
     * Creates UI widgets from values.
     * @param vals values
     * @return UI representation of vals
     */
    global define term getValuesUI (any vals) ``{
	if (is (vals,list))
	{
	    // selectionbox label
	    return `SelectionBox (`id (`vals), `opt (`notify), _("Val&ues"), vals);
	}
	if (!is (vals, term))
	    return `VStretch ();
	if (`text == symbolof (vals))
	{
	    // textentry label
	    term out = `TextEntry (`id (`vals), `opt (`notify), _("Value:"), select (vals, 1, ""));
	    return `VBox (
		    `VStretch (),
		    out,
		    // label
		    `Right (`Label (sformat (_("Allowed characters: %1"), select (vals, 0, "")))),
		    `VStretch ());
	}
	if (`int == symbolof (vals))
	{
	    boolean not_used = (nil == select (vals, 4, nil) && nil == select (vals, 3, nil));
	    integer initial = select (vals, 4, nil);
	    if (nil == initial)
	    {
		initial = select (vals, 3, nil);
	    }
	    if (nil == initial)
	    {
		initial = select (vals, 0, nil);
	    }
	    term out = UI::HasSpecialWidget (`Slider) ?
		// slider
		`Slider (`id (`vals), not_used ? `opt (`notify, `disabled) : `opt (`notify), _("&Values")) :
		// int field
		`IntField (`id (`vals), not_used ? `opt (`hstretch, `notify, `disabled) : `opt (`notify), _("&Values"));
	    out = add (out, select (vals, 0, 0));
	    out = add (out, select (vals, 1, 0));
	    out = add (out, initial);
	    if (nil == select (vals, 3, nil))
	    {
		out = `VBox (
			`VStretch (),
			// check box
			`CheckBox (`id (`vals2), `opt (`hstretch, `notify), _("Not &set (use the driver default)"), not_used),
			out,
			// label
			`Label (`opt (`hstretch), sformat (_("Minimal value: %1\nMaximal value: %2\nStep: %3"),
				select (vals, 0, 0), select (vals, 1, 0), select (vals, 2, 0))),
			`VStretch ()
			);
	    }
	    else
	    {
		out = `VBox (
			`VStretch (),
			out,
			// label
			`Label (`opt (`hstretch), sformat (_("Minimal value: %1\nMaximal value: %2\nStep: %3"),
				select (vals, 0, 0), select (vals, 1, 0), select (vals, 2, 0))),
			`VStretch ()
			);
	    }
	    return out;
	}
	if (`float == symbolof (vals))
	{
	    boolean not_used = (nil == select (vals, 4, nil) && nil == select (vals, 3, nil));
	    float initial = select (vals, 4, nil);
	    if (nil == initial)
	    {
		initial = select (vals, 3, nil);
	    }
	    if (nil == initial)
	    {
		initial = select (vals, 0, nil);
	    }
	    term out = `TextEntry (`id (`vals),
		    not_used ? `opt (`disabled, `hstretch, `notify) :
			// textentry label
		    `opt (`hstretch, `notify), _("&Values"), sformat ("%1", initial));
	    if (nil == select (vals, 3, nil))
	    {
		out = `VBox (
			`VStretch (),
			// checkbox
			`CheckBox (`id (`vals2), `opt (`hstretch, `notify), _("Not &set (use the driver default)"), not_used),
			out,
			// label
			`Label (`opt (`hstretch), sformat (_("Minimal value: %1\nMaximal value: %2\nStep: %3"),
				select (vals, 0, 0), select (vals, 1, 0), select (vals, 2, 0))),
			`VStretch ()
			);
	    }
	    else
	    {
		out = `VBox (
			`VStretch (),
			out,
			// label
			`Label (`opt (`hstretch), sformat (_("Minimal value: %1\nMaximal value: %2\nStep: %3"),
				select (vals, 0, 0), select (vals, 1, 0), select (vals, 2, 0))),
			`VStretch ()
			);
	    }
	    return out;
	}
	return `VStretch ();
    }
    /**
     * Remove characters that are not allowed by ieee1284.
     * @param id string to check
     * @return string updated string
     */
    global define string filter1284 (string id) ``{
	return filterchars (tolower (id), "abcdefghijklmnopqrstuvwxyz0123456789_+/");
    }

    /**
     * Compare saved gs_upp file with the generated one.
     * @param file1 contents of one upp file
     * @param file2 contents of the other upp file
     * @return boolean true if files are the same
     */
    global define boolean diffUppFiles (string file1, string file2) ``{
	// save files
	string tmpdir = SCR::Read (.target.tmpdir);
	SCR::Write (.target.string, tmpdir + "/options1.upp", file1);
	SCR::Write (.target.string, tmpdir + "/options2.upp", file2);
	// diff files
	boolean changed = (0 == SCR::Execute (.target.bash, sformat ("/usr/bin/diff -w -B %1/options1.upp %1/options2.upp", tmpdir)));
	// delete files
	SCR::Execute (.target.bash, sformat ("/bin/rm %1/options1.upp %1/options2.upp", tmpdir));
	return changed;
    }
    /**
     * Looks if selected options contain paper size.
     * @param selected currently selected options
     * @return true if they contain paper size
     */
    global define boolean havePaperSize (map selected) ``{
	boolean found = false;
	foreach (`k, `v, selected, ``{
	    if (substring (k, 0, 10) == "papersize-")
		found = true;
	});
	return found;
    }
    /**
     * Tries to find paper size between selected options. If there is any,
     * doesn't touch anything. Otherwise finds the first paper-size option
     * in opts and sets it to 0(a4) or 1(letter) according to local
     * settings.
     * @param selected currently selected options
     * @param opts option list
     * @return modified settings
     */
    global define map solvePaperSize (map selected, list opts) ``{
	integer len = size (opts);
	integer i = 0;
	while (i < len)
	{
	    string s = select (select (select (select (opts, i, `i ()), 0, `id ([])), 0, []), 1, "");
	    if (substring (s, 0, 10) == "papersize-")
	    {
		selected = add (selected, s, Printerlib::getDefaultPaperSize ());
		break;
	    }
	    i = i + 1;
	}
	return selected;
    }
    /**
      * get RadioButtonGroup for spooler selection
      * @param spooler string currently used spooler (cups, cups-client, lprng or current)
      * @param none boolean show leaving current status
      * @return term RadioButtonGroup widget
      */
    global define term getSpoolerItems (string spooler, boolean none) ``{
	return `RadioButtonGroup (
	    `id (`spooler),
	    `HBox (`HSpacing (1), `VBox (
		`VSpacing (1),
		// radiobutton
		`RadioButton (`id (`cups_server),
		    `opt (`hstretch, `notify),
		    _("CUPS full &server installation"),
		    spooler == "cups"),
		`VSpacing (0.5),
		// radiobutton
		`RadioButton (`id (`cups_client),
		    `opt (`hstretch, `notify),
		    _("CUPS &client-only installation"),
		    spooler == "cups-client"),
		`VSpacing (0.5),
		// radiobutton
		`RadioButton (`id (`lprng),
		    `opt (`hstretch, `notify),
		    _("&LPRng"),
		    spooler == "lprng"),
		none ? `VSpacing (0.5) : `VSpacing (0),
		// radiobutton
		none ? `RadioButton (`id (`none),
		    `opt (`hstretch, `notify),
		    _("L&eave current status"),
		    spooler == "current")
		    : `VSpacing (0),
		`VSpacing (1)
	     ), `HSpacing (1)
	));
    }

    /**
      * Shows a question to a user whether he wants the LPRng or CUPS spooler.
      * @param msg string to be displayed
      * @param abort_msg label of abort button
      * @return symbol specifying users selecion (lprng, cups, exit)
      */
    global define symbol chooseSpooler(string msg, string abort_msg)
    ``{
	symbol ret = `none_symbol;
	UI::OpenDialog (
            `VBox (
		`Label (msg),
		getSpoolerItems ("current", true),
		`HBox (
		    `HWeight (1, `PushButton (`id (`ok), `opt (`key_F10), OKButtonLabel ())),
		    `HWeight (1, `PushButton (`id (`cancel), `opt (`key_F9), abort_msg))))
	);
	while (true)
	{
	    ret = UI::UserInput ();
	    if (ret == `ok || ret == `cancel)
		break;
	}
	if (`ok == ret)
	{
	    ret = UI::QueryWidget (`id (`spooler), `CurrentButton);
	}
	UI::CloseDialog();
	return ret;
    }
    /**
     * Check what spool system is installed. Don't ask user.
     * @return string spooler
     */
    global define string checkSpoolSystemNoDialog () ``{
	integer spool_sys = Printerlib::getSpoolSystem ();
	spool_sys = spool_sys & 0xFF;
	if (1 == spool_sys) //lpd is installed
	{
	    return "lprng";
	}
	else if (2 == spool_sys) //cups is installed
	{
	    return "cups";
	}
	return "unknown";
    }
    /**
     * Check what spool system is installed. Ask user if needed and install spooler if wanted.
     * @return string spooler
     */
    global define string checkSpoolSystem () ``{
	integer spool_sys = Printerlib::getSpoolSystem ();
	if (1 == spool_sys) //lpd is installed
	{
	    return "lprng";
	}
	else if (2 == spool_sys) //cups is installed
	{
	    return "cups";
	}
	else if (0 == spool_sys || 3 == spool_sys || 256 + 1 == spool_sys
	    || 256 + 2 == spool_sys)
	{
	    string message = "";
	    if (0 == spool_sys) //none installed
	    {
		// popup message
		message = _("No printing system installed. 
Select the spooler to 
to install and configure.");
	    }
	    else if (3 == spool_sys) //both spoolers are installed
	    {
		// popup message
		message = _("Both LPRng and CUPS are installed.
Select the spooler  
to leave installed and configure.");
	    }
	    else if (256 + 1 == spool_sys) // lpd is installed, but seems
					   // to be not complete
	    {
		// popup message
		message = _("An LPD-compatible spooler, probably LPRng,
is installed, but the installation does not seem 
complete. Choose to reinstall 
LPRng, install CUPS, or leave the current status.
To repair current configuration, select LPRng.
If you leave the current status, your spooler may not
run properly.");
	    }
	    else if (256 + 2 == spool_sys) // cups is installed, but seems
					   // to be not complete
	    {
		// popup message
		message =_("The CUPS spooler is installed, but the installation 
does not seem complete. Choose to reinstall
CUPS, install LPRng, or leave the current status. 
To repair the current configuration, select the 
CUPS full server installation.
If you leave the current status, your spooler 
may not run properly.");
	    }
	    symbol result = chooseSpooler (message,
		// pushbutton
		_("Abo&rt setup"));
	    if (`cups_server == result)
	    {
		Printerlib::switchTo ("cups");
		return "switched";
	    }
	    else if (`cups_client == result)
            {
                Printerlib::switchTo ("cups_client");
                return "switched";
            }
	    else if (`lprng == result)
	    {
		Printerlib::switchTo ("lprng");
		return "switched";
	    }
            else if (`cancel == result)
                return "exit";
	    else
		return "cups";
	}
	else if (512 + 2 == spool_sys) // only client installation of cups
				       // is installed
	{
	    return "cups";
	}
	return ""; //should be never reached
    }
}
