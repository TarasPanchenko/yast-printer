/**
 * File:
 *   modules/Printer.ycp
 *
 * Package:
 *   printer configuration tool
 *
 * Summary:
 *   Module for printer.
 *
 * Authors:
 *  Petr Blahos <pblahos@suse.cz>
 *  Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 * Well we all know what modules are for.
 */

{
    module "Printer";
    import "Printerlib";
    import "Progress";
    import "Runlevel";
    import "Report";
    import "Summary";
    import "Mode";
    import "HTML";
    import "Popup";
    import "Arch";
    include "printer/misc.ycp";
    include "printer/misc-lprng.ycp";
    include "printer/misc-cups.ycp";
    include "printer/ppds.ycp";

    textdomain "printer";

    //////////
    ////////// Module data
    //////////

    /**
      * Version of YaST2 printer module for updates handling
      */
    global integer version = 256 * 2 + 8; // 2.8
    /**
      * Don't run SuSEconfig, don't restart services if true and possible
      */
    global boolean write_only = false;
    /**
     * Type of cups installation.
     * nil: unknown
     * `server:  server
     * `client: client
     */
    global symbol cups_installation = nil;
    /**
      * Use CUPS-like USB devices names
      * `always, `never, `serial
      */
    global symbol cups_usb_dev_names = `always;
    /**
     * If this is only cups client station,
     * server host name is here.
     */
    global string server_hostname = "";
    /**
      * List of detected CUPS servers
      */
    global list(string) cups_servers = [];
    /**
      * Shall be printers detected
      * If nil, ask user
      */
    global boolean detect = true;

    /**
     * List of print queues. See description of map printer
     * for members structure.
     */
    global list printcap = [];
    /**
      *Backup list of print queues. See description of map printer
      * for members structure.
      */
    global list printcap_backup = [];
    /**
     * Default queue name
     */
    global string default = "";
    /**
     * Were settings changed?
     */
    global boolean dirty = false;
    /**
      * Has to be saved all?
      */
    global boolean save_all = false;
    /**
      * Shall be settings read at the beginning?
      */
    global boolean reread = true;
    /**
      * Were settings read?
      */
    global boolean read_done = false;
    /**
      * Settings of CUPS server
      */
    global map cups_server_settings = $[];
    /**
      * map of foomatic printers database
      */
    global map foomatic = nil;
    /**
     * Print queue we are currently working with.
     * @example
     * $[
     * "name" : string, //queue name
     * "uri" : string, //printer uri
     * "unique_key" : string,  // from libhd  -|
     * "vendor_ieee" : string, // detected id -|- these are only present for autodetected printers
     * "device_ieee" : string, // detected id -|
     * "vendor_db" : string, // vendor from printer db -|
     * "device_db" : string, // device from printer db -|
     * "config" : string, // config from printer db -|-only for non-raw queues
     * "options": map,   // options from printer db -|
     * "ff" : boolean, // print formfeed between pages, present only for queues with formfeed
     * "raw": boolean, // raw queue, present only for raw queues
     * ]
     */
    global map printer = $[];
    /**
     * Index of printer we are working with.
     */
    global integer index = 0;
    /**
     * List of printers that were deleted during this configuration
     * session.
     */
    global list deleted = [];
    /**
     * List of autodetected printers. For documentation see
     * yast2-lib-printer.
     */
    global list autodetected = [];

    /**
     * Printer's name mustn't be the same as a name of one of the files
     * in the /etc/lpdfilter directory. These are the files. If it is nil,
     * the list hasn't been initialized yet. Use function
     * getSystemForbiddenNames for accessing this list.
     */
     // this wasn't global before, but variable is used directly in printer.ycp
    global list sys_forbidden_names = [];//nil;

    /**
     * List of unique keys of the printers read at the beginning.
     * We need this because when writting, we must call
     * Write (.probe.status.configured, "unique_key", `yes | `no)
     * It is map of $[ unique_key : true ]. When saving, unique keys that
     * are still configured are replaced by $[ unique_key : false ]
     */
    map original_unique_keys = $[];

    /**
     * Should we warn before saving settings?
     * (false for proposal and auto modes)
     */
    global boolean warn_finish = true;

    /**
      * Currently used spooler, cups or lprng
      */
    global string spooler = "unknown";

    /**
      * Type of start, true if autodetection
      */
    global boolean detection = false;
    /**
      * At least one queue has been tested - because of hw proposal
      */
    global boolean tested = false;

    /**
      * Forbid to read CUPS settings, because it would mean to start CUPS server
      */
    global boolean do_not_read_cups = false;

// variables for UI purproses

    /**
      * Current mode of configuration
      * `det for configuring from detected printers dialog
      * `adm for configuring from printer administration dialog
      */
    global symbol confmode = nil;

    /**
      * Selected item from main connection type dialog
      */
    global symbol connection_type_selected = `local;

    /**
      * Old URI due to backing it up during edit sequence
      */
    global string old_uri = "";

    /**
      * Configuring printer, which is result of detection?
      */
    global boolean conf_detected = false;



    /**
     * Get list of names that are forbidden because they are used as
     * filenames in /etc/lpdfilter
     * @return list of strings -- these strings are not allowed as queue
     * names.
     */
    global define list getSystemForbiddenNames () ``{
	if (nil == sys_forbidden_names)
	{
	    if (0 != SCR::Execute (.target.bash, "test -d /etc/lpdfilter"))
		sys_forbidden_names = [];
	    else
		sys_forbidden_names = SCR::Read (.etc.printcap.sysnames);
	    if (nil == sys_forbidden_names)
		sys_forbidden_names = [];
	}
	sys_forbidden_names
	    = maplist (`n, sys_forbidden_names, ``(tolower (n)));
	return sys_forbidden_names;
    }
    /**
     * Autodetect printers.
     */
    global define void Detect () ``{
	dirty = true;
	autodetected = Printerlib::Detect (false);
	autodetected = maplist (`i, autodetected, ``{
	    i["uri"] = i["bus"]:"parallel" + ":" + i["dev_name"]:"";
	    i["info"] = i["vendor"]:"" + " " + i["device"]:"";
            i["location"] = Printerlib::getUriNiceName (i["uri"]:"");
	    i["vendor_db"] = SCR::Read (.ppd.db.vendorname, i["vendor"]:"");
	    i["device_db"] = SCR::Read (.ppd.db.modelname,
		    [i["vendor_db"]:"", i["device"]:""]);
	    y2milestone ("Detected printer %1", i);
	    return i;
	});
	if (spooler == "cups")
	{
	    Printerlib::setCupsUsbDevicesInfo ();
	    autodetected = filter (`a, autodetected, ``(
		! contains (Printerlib::getProblematicCupsUsbDevices (),
			a["dev_name"]:"")
	    ));
	}
    }

    /**
     * Select printer to edit or something.
     * @param i printer to select. Pass nil if you do not want to select
     *		printer, e.g. if printer is going to be added.
     */
    global define void selectPrinter (integer i) ``{
	if (nil == i || i < 0 || i >= size (printcap))
	{
	    index = -1;
	    printer = $[];
	    return ;
	}
	index = i;
	printer = select (printcap, index, $[]);
    }
    /**
     * Select printer to edit or something.
     * @param name printer to select. Pass nil if you do not want to select
     *          printer, e.g. if printer is going to be added.
     */
    global define void selectPrinterByName (string name) ``{
        index = -1;
        printer = $[];
	integer ind = -1;
	foreach (`p, printcap, ``{
	    ind = ind + 1;
	    if (p["name"]:"" == name)
	    {
		index = ind;
		printer = p;
	    }
	});
    }

    /**
     * Let print queue named name be currently edited.
     * If printer is not found, then queue will be $[] and index -1
     * @param name name of the queue to find
     */
    global define void selectPrinterByName (string name) ``{
	index = -1;
	integer j = -1;
	foreach (`i, printcap, ``{
	    j = j + 1;
	    if (name == lookup (i, "name", ""))
	    {
		index = j;
	    }
	});
	printer = select (printcap, index, $[]);
    }

    /**
     * Delete currently selected printer.
     */
    global define void deletePrinter () ``{
	if (index < 0 || index >= size (printcap))
	    return ;
	printer = select (printcap, index, $[]);
	if (nil == printer)
	    printer = $[];
	string printer_type = "";
	if (lookup (printer, "type", "yast2") == "lprng")
	    printer_type = "printer";
	else if (lookup (printer, "type", "yast2") == "yast2")
	    printer_type = lookup (printer, "uri", "class") == "class" ? "class" : "printer";
	else
	{
	    if (lookup (printer, "uri", "") == "class")
		printer_type = "class";
	    else if (lookup (printer, "uri", "") != "")
		printer_type = "printer";
	    else
	    {
		printer_type = "class";
		addToDeleted (lookup (printer, "name", ""), "printer");
	    }
	}
	addToDeleted (lookup (printer, "name", ""), printer_type);
	printcap = remove (printcap, index);
	if (index >= size (printcap))
	    index = index - 1;
	dirty = true;
	assignDefault ();
    }
    /**
      * Set implicit default queue if no queue is set as default
      */
    global define void assignDefault () ``{
	boolean found_default = false;
	boolean found_lp = false;
	boolean found_normal = false;
	boolean found_defstr = false;
	string norm_name = "";
	string first = "";
	string state_string = spooler + "-state";
	foreach (`e, printcap, ``{
	    string name = lookup (e, "name", "");
	    if (lookup (e, state_string, "") != "void")
	    {
		if (name == "lp")
		    found_lp = true;
		if (name == default)
		    found_default = true;
		if (name == "normal" || regexpmatch (name, "normal[0-9]"))
		{
		    norm_name = name;
		    found_normal = true;
		}
		if (name == "default")
		    found_defstr = true;
		if (first == "")
		    first = name;
	    }
	});
	if (found_default)
	{

	}
	else if (found_lp)
	{
	    default = "lp";
	    dirty = true;
	}
	else if (found_normal)
	{
	    default = norm_name;
	    dirty = true;
	}
	else if (found_default)
	{
	    default = "default";
	    dirty = true;
	}
	else
	{
	    default = first;
	    dirty = true;
	}
    }

    /**
     * Set current printer as default printer
     */
    global define void setDefaultPrinter () ``{
	if (index < 0 || index >= size (printcap))
	    return ;
	default = lookup (printer, "name", "");
	dirty = true;
    }
    /**
     * Return list(set) of names that can not be used as printer name. There can be
     * same name for more printers in /etc/printcap. It was impossible to add printer,
     * because all names were invalid because
     * size (union (forbidden_names, new_names)) != size (forbidden_names) + size (new_names).
     * @return list set of already used names
     */
    global define list getForbiddenNames() ``{
	list l = toset (add (flatten (maplist (`entry, printcap, ``(add (lookup (entry, "names", []), lookup (entry, "name", ""))))), "all"));
	list names = maplist (`i, l, ``(tolower (i)));
	names = toset (names);
	return names;
    }
    /**
      * Assign states to a printer
      * @param p map printer
      * @param changed boolean true if queue was changed
      *   (to assign correct state)
      * @return map printer with assigned states
      */
    global define map assignStates (map p, boolean changed) ``{
	if (lookup (p, "type", "yast2") != "yast2")
	    return p;
	boolean supported = true;
	list spoolers = ["cups", "lprng"];
	string uri = lookup (p, "uri", "");
	string q_type = Printerlib::getUriType (uri);
	string config = lookup (p, "config", "");
	string q_filter = "";
	if (p["ownppd"]:"" == "")
	{
	    q_filter = foomatic [p["vendor_db"]:"",
		p["device_db"]:"", config, "filter"]:nil;
	}
	else
	{
	    string filename = p["ownppd"]:"";
	    if (SCR::Read (.target.size, filename) <= 0)
	    {
		filename = p["ppd"]:"";
	    }
	    if (isPpd (filename))
	    {
		map info = ppdInfo (filename);
		q_filter = info["filter"]:"";
	    }
	}
	if (q_filter == nil)
	    supported = false;
	boolean is_class = q_type == "class";
	if (is_class || p["raw"]:false)
	    supported = true;
	foreach (`s, spoolers, ``{
	    boolean filt_sup = ((s == "cups" || ! is_class)
		    && (s == "cups" || q_filter == "foomatic-rip"))
		|| p["raw"]:false;
	    boolean spool_sup = testSupportedQueueBySpooler (q_type, s);
	    string key = s + "-state";
	    boolean sup = supported && filt_sup && spool_sup;
	    p[key] = sup
		    ?
			(changed ?
			    "changed"
			:
			    (lookup (p, key, "changed") == "void"
			    ?
				"changed"
			    :
				lookup (p, key, "changed")))
		    :
			"void";
	});
	return p;
    }
    /**
      * Gets state of printer for choosen spooler
      * @param p map printer
      * @param spooler string spooler (cups or lprng)
      * @return string state
      */
    global define string getPrinterState (map p, string spooler) ``{
	string s = spooler + "-state";
	return p[s]:"changed";
    }
    /**
      * Adds a queue to the deleted list
      * @param name string queue name
      * @param printer_type string "printer" or "class"
      */
    global define void addToDeleted (string name, string printer_type) ``{
	deleted = add (deleted, $[ "name" : name, "type" : printer_type, "states" : $["cups-state" : "changed", "lprng-state" : "changed"]]);
    }
    /**
     * Save currently edited printer.
     */
    global define void storePrinter () ``{
	cups_installation = `server;
	if (printer["uri"]:"" == "listen_ipp")
	{
	    if (cups_server_settings["Browsing"]:"On" == "On")
	    {
		// TODO make sure CUPS server will be running

	    }
	    return;
	}
	else if (printer["uri"]:"" == "cups_client")
	{
	    cups_installation = `client;
	    return;
	}

	printer = assignStates (printer, true);

	y2milestone ("Storing printer %1, index %2", printer, index);

	if (-1 == index)
	{
	    printcap = add (printcap, printer);
	    index = size (printcap) - 1;
	}
	else
	{
	    // we do not need care about creating new remote queue, it is
	    // impossible in this situation
	    integer c = -1;
	    printcap = maplist (`i, printcap, ``{
		c = c + 1;
		if (c == index)
		    return printer;
		return i;
	    });
	}
	// fix default printer
	if ("" == default || nil == default)
	{
	    default = lookup (printer, "name", "");
	}
	else
	{
	    boolean found = false;
	    foreach (`i, printcap, ``{
		    if (!found && lookup (i, "name", "") == default)
			found = true;
	    });
	    if (!found)
		default = lookup (printer, "name", "");
	}
	dirty = true;
	y2debug ("Final printcap: %1", printcap);
    }
    /**
     * Export module settings to map.
     * @return Map of module settings.
     */
    global define map Export () ``{
	return $[
	    "printcap" : printcap,
	    "default"  : default,
	    "spooler" : spooler,
	    "cups_installation" : cups_installation,
	    "server_hostname" : server_hostname,
	];
    }
    /**
     * Import module settings.
     * @param settings module settings
     */
    global define void Import (map settings) ``{
	dirty = true;
	spooler = settings["spooler"]:"cups";
	cups_installation = lookup (settings, "cups_installation", nil);
	server_hostname = lookup (settings, "server_hostname", "");
	default = lookup (settings, "default", "");
	printcap = lookup (settings, "printcap", []);
	cups_usb_dev_names = `always;
	index = -1;
	deleted = [];
    }
    /**
     * Reset all settings...
     */
    global define void Reset () ``{

	list pr = printcap;
	foreach (`e, pr, ``{
	    string uri = lookup (e, "uri", "");
	    deletePrinters ([$["name": lookup (e, "name", ""), "type":  uri == "class" ? "class" : "printer"]]);
	});
	server_hostname = "";
	cups_installation = nil;
	dirty = true;
	default = "";
	printcap = [];
	index = -1;
	deleted = [];
	autodetected = [];
	cups_usb_dev_names = `always;
    }
    /**
     * read printers from /etc/printcap
     * @return list of printers
     */
    global define list printcapRead () ``{
	SCR::Execute (.target.bash, "test -d /etc/lpdfilter || /bin/mkdir /etc/lpdfilter");
	list ret = SCR::Read (.etc.printcap);
	default = SCR::Read (.sysconfig.printer.DEFAULT_PRINTER);
	if (nil == ret)
	    return [];
	return ret;
    }
    /**
     * Read client.conf host name to server_hostname
     */
    define void loadClientHostName () ``{
        // grep /etc/cups/client.conf for ServerName
        server_hostname = "";
        map e = SCR::Execute (.target.bash_output, "/usr/bin/awk '/^ServerName/ { print $2 }' /etc/cups/client.conf");
        if (0 == lookup (e, "exit", 1))
        {
            server_hostname = select (splitstring (lookup (e, "stdout", ""), "\n"), 0, "");
            if (nil == server_hostname || "" == server_hostname || "nil" == server_hostname ||
                "localhost" == server_hostname || "127.0.0.1" == server_hostname)
                server_hostname = "";
        }
    }
    /**
     * Save client.conf host name host name
     */
    global define void saveClientHostName () ``{
    // added check for nil value (bug #19226)
	if (server_hostname == "" || server_hostname == nil)
	{
	     SCR::Execute (.target.bash, "test -f /etc/cups/client.conf && (/usr/bin/awk '
BEGIN { used = 0 }
/^ServerName/ { next }
{ print $0; }
' /etc/cups/client.conf > /etc/cups/client.conf.yast2; mv /etc/cups/client.conf.yast2 /etc/cups/client.conf)");
	}
	else
	{
            SCR::Execute (.target.bash,
                      sformat ("test -f /etc/cups/client.conf && (/usr/bin/awk '
BEGIN { used = 0 }
/^ServerName/ { print \"ServerName %1\"; used = 1; next }
{ print $0; }
END { if (!used) print \"ServerName %1\" }
' /etc/cups/client.conf > /etc/cups/client.conf.yast2; /bin/mv /etc/cups/client.conf.yast2 /etc/cups/client.conf)", server_hostname));
	}
	if (server_hostname == "")
	    server_hostname = nil;
	SCR::Write (.sysconfig.printer.CUPS_SERVER, server_hostname);
	SCR::Write (.sysconfig.printer, nil);
	SCR::Execute (.target.bash, "/sbin/SuSEconfig --module profiles");
    }
    /**
     * If only client is installed or remote server to use is set,
     * returns 1, if this is real server installation, returns 0
     * Also sets server_hostname and cups_installation
     * @return symbol `client or `server
     */
    global define symbol cupsInstallationType () ``{
        if (nil != cups_installation)
            return cups_installation;

        if (Pkg::IsProvided ("cups-libs") &&
            !Pkg::IsProvided ("cups"))
        {
            loadClientHostName ();
            cups_installation = `client;
            return `client;
        }
        loadClientHostName ();
        cups_installation = (("" != server_hostname) ? `client : `server);
        return cups_installation;
    }
    /**
     * Read the CUPS settings.
     * @return list of printers
     */
    global define list cupsRead () ``{
        if (`server == cupsInstallationType () && ! do_not_read_cups)
        {
	    restartSpoolerIfNeeded (true);
//	    foomatic = SCR::Read (.target.ycp, "/var/lib/YaST2/ppd_db.ycp");
            list ret = SCR::Read (.cups.printers);
	    ret = filter (`e, ret, ``(lookup (e, "uri", "") != ""));
            list classes = SCR::Read (.cups.classes);
	    if (nil == ret) ret = [];
	    if (nil == classes)  classes = [];
	    classes = maplist (`e, classes, ``(add (e, "uri", "class")));
	    ret = ret + classes;
	    default = SCR::Read (.cups.default_dest);
	    readCupsSettings ();
	    return ret;
        }
        return [];
    }
    /**
      * Sorts entries of printcap
      */
    global define void sortPrinters () ``{
	list yast = filter (`e, printcap, ``(lookup (e, "type", "yast2") == "yast2"));
	list non_yast = filter (`e, printcap, ``(lookup (e, "type", "yast2") != "yast2"));
	list classes = filter (`e, yast, ``(lookup (e, "uri", "class") == "class"));
	list printers = filter (`e, yast, ``(lookup (e, "uri", "class") != "class"));
	map sorted = $[];
	list locals = filter (`e, printers, ``(contains (["parallel", "serial", "irda", "usb", "pipe"], Printerlib::getUriType (lookup (e, "uri", "")))));
	list remote = filter (`e, printers, ``(! contains (["parallel", "serial", "irda", "usb", "pipe"], Printerlib::getUriType (lookup (e, "uri", "")))));

	foreach (`e, locals, ``{
	    string uri = lookup (e, "uri", "");
	    list s = lookup (sorted, uri, []);
	    s = add (s, e);
	    sorted = add (sorted, uri, s);
	});
	locals = [];
	foreach (`k, `v, sorted, ``{locals = merge (locals, v);});
	sorted = $[];
	foreach (`e, remote, ``{
	    string uri = lookup (e, "uri", "");
	    list s = lookup (sorted, uri, []);
	    s = add (s, e);
	    sorted = add (sorted, uri, s);
	});
        remote = [];
        foreach (`k, `v, sorted, ``{remote = merge (remote, v);});

	printcap = merge (locals, remote);
	classes = sort (`x, `y, classes, ``(lookup (x, "name", "") <= lookup (y, "name", "")));
	printcap = merge (printcap, classes);
	non_yast = sort (`x, `y, non_yast, ``(lookup (x, "name", "") <= lookup (y, "name", "")));
	printcap = merge (printcap, non_yast);
    }



    /**
     * Read settings from disk or where.
     * @return boolean success?
     */
    global define boolean Read () ``{
	boolean skip_autodetection = Arch::s390;
	boolean test_mode = false;
	boolean skip_io = false;
	list stages = [
	    // progress stage, text in dialog (short) (infinitive)
	    _("Check environment"),
	    // progress stage, text in dialog (short) (infinitive)
	    _("Load current settings"),
	    // progress stage, text in dialog (short) (infinitive)
	    _("Check database of printers"),
	];
	list titles = [
	    // progress stage, text in dialog (short)
	    _("Checking environment..."),
	    // progress stage, text in dialog (short)
	    _("Loading current settings..."),
	    // progress stage, text in dialog (short)
	    _("Checking database of printers..."),
	];
	if (!skip_autodetection)
	{
	    // progress stage, text in dialog (short) (infinitive)
	    stages = add (stages, _("Autodetect printers"));
	    // progress stage, text in dialog (short)
	    titles = add (titles, _("Autodetecting printers..."));
	}

	Progress::New (_("Initializing printer configuration tool..."),
	    " ", skip_autodetection ? 12 : 16, stages, titles, "");

	// step 0
	Progress::NextStageStep (0); if (testAbort ()) return false;



	// make sure we are root
	if (!Printerlib::amIRoot () && !test_mode)
	{
	    if (! Popup::AnyQuestion ("",
		// popup
		_("You must be root to run the printer configuration tool. 
 If you continue, you will not be able to save your settings. 
 Continue?"),
		Label::YesButton (), Label::NoButton (), `focus_no))
	    {
		return false;
	    }
	}

	Printer::spooler = checkSpoolSystem();
	if (Printer::spooler == "switched")
	{
	    Printer::save_all = true;
	    Printer::reread = true;
	    Printer::sys_forbidden_names = nil;
	    return Read ();
	}
	if (Printer::spooler == "exit")
	    return false;


	if (!test_mode)
	{
	    if (Printer::spooler == "cups")
	    {
		if (`server == Printer::cupsInstallationType ())
		{
		    integer status = SCR::Execute (.target.bash,
			"/usr/bin/lpq 2>/dev/null");
		    if (status == 0)
		    {
			// step 1,2
			Progress::NextStep (); if (testAbort ()) return false;
			Progress::NextStep (); if (testAbort ()) return false;
		    }
		    else
		    {
			restartSpoolerIfNeeded (true);
			// step 1,2
			Progress::NextStep (); if (testAbort ()) return false;
			Progress::NextStep (); if (testAbort ()) return false;
		    }
		}
		else
		{
		    // step 1,2
		    Progress::NextStep (); if (testAbort ()) return false;
		    Progress::NextStep (); if (testAbort ()) return false;
		}
	    }
	    else if (Printer::spooler == "lprng")
	    {
		SCR::Execute (.target.bash,
		    "/usr/bin/touch /etc/printcap; /bin/chmod u=rw,g=r,o=r /etc/printcap; /etc/init.d/lpd stop");
		// step 1
		Progress::NextStep (); if (testAbort ()) return false;
		integer lpdaemon = SCR::Execute (.target.bash,
		    "/etc/init.d/lpd start");
		// step 2
		Progress::NextStep (); if (testAbort ()) return false;
		if (lpdaemon != 0)
		{
		    // message box
		    if (!Popup::AnyQuestion (
			Label::ErrorMsg (),
			// error popup
			_("Unable to restart the lpd daemon."),
			Label::ContinueButton (),
			Label::AbortButton (),
			`focus_no))
		    {
			UI::CloseDialog ();
			return false;
		    }
		}
	    }
	    else
	    {
		// step 1,2
		Progress::NextStep();
		Progress::NextStep();
	    }
	}
	// step 3
	Progress::NextStep (); if (testAbort ()) return false;

	if (SCR::Execute (.target.bash, "/usr/bin/which gs") != 0)
	{
	    // message box
	    Report::Warning (_("It seems that you do not have GhostScript
installed on your computer. It is needed
to print."));
	}

	// step 4
	Progress::NextStageStep (4); if (testAbort ()) return false;

	if (!skip_io && (Printer::spooler != "cups"
	    || Printer::cupsInstallationType () == `server))
	{
	    if (!Printer::oldRead ())
	    {
		// message box
		Report::Error (_("Unable to read the current configuration."));
                return false;
	    }
	}

	// step 8
	Progress::NextStageStep (8); if (testAbort ()) return false;

	if (Printer::spooler != "cups"
	    || Printer::cupsInstallationType () == `server)
	{
	    loadFoomaticIfNeeded ();
	}

	// Autodetection
	if (!skip_autodetection)
	{
	    // step 12
	    Progress::NextStageStep (12); if (testAbort ()) return false;
	    if (Printer::detect != false)
		Printer::detect = Crash::AskRun ("printer_detection",
		    // popup
		    _("During the following step, YaST2 will try to detect local printers only.

Printer detection can now start. In some cases, detection can cause a
system freeze. If a freeze happens, select Skip Detection
when next running the printer configuration.

Detect your printers?"));

	    if (Printer::detect)
	    {
		Crash::Run ("printer_detection");
		runProbeDialog ();
		Crash::Finish ("printer_detection");
	    }
	}
	// Progress finish
	Progress::Finish (); if (testAbort ()) return false;
	return true;
    }

    global define boolean oldRead () ``{
	list tmplist = [];
	list tmpdellist = [];
	boolean ret = true;
//	boolean update = false;
	list nonyast = [];
	string old_default = default;

	if (spooler == "cups")
        {
            nonyast = cupsRead();
        }
        else if (spooler == "lprng")
        {
            nonyast = printcapRead();
        }
	if (! reread)
	{
	    printcap = filter (`e, printcap, ``(lookup (e, "type", "yast2") == "yast2"));
	    foreach (`e, printcap, ``{
		string name = lookup (e, "name", "");
		if ("" != name)
		    tmplist = add (tmplist, name);
	    });
	    foreach (`e, deleted, ``{
		string name = lookup (e, "name", "");
		if ("" != name)
		    tmpdellist = add (tmpdellist, name);
	    });
	}
	else
	{
	    printcap = [];
	    SCR::Execute (.target.bash, "/bin/touch /var/lib/YaST2/printers");
	    map state = SCR::Read (.target.ycp, "/var/lib/YaST2/printers");
	    if (nil == state)
	    {
		state = $[];
	    }
	    integer read_version = state["version"]:0;
	    if ( !(spooler == "cups" && cupsInstallationType () == `client))
	    {
		printcap = state["printers"]:[];
	    }
	    if (read_version < version)
	    {
	        printcap = maplist (`p, printcap, ``{
		    if (substring (p["uri"]:"", 0, 12) == "prefilter://")
		        p["uri"] = "filtering://localhost/"
			    + substring (p["uri"]:"", 12);
		    if (substring (p["uri"]:"", 0, 6) == "lpd://")
			p["raw"] = true;
		    if (substring (p["uri"]:"", 0, 12) == "filtering://")
			p["uri"] = "lpd://" + substring (p["uri"]:"", 12);
		    return p;
		});
	    }
	    deleted = lookup (state, "deleted", []);
	    default = lookup (state, "default", "");
	    cups_usb_dev_names = state["cups_usb_devices"]:`always;
	    printcap = maplist (`e, printcap, ``(
		add (e, "type", "yast2")
	    ));
	    foreach (`e, printcap, ``{
		string name = lookup (e, "name", "");
		if ("" != name)
		    tmplist = add (tmplist, name);
	    });
	    foreach (`e, deleted, ``{
		string name = lookup (e, "name", "");
		if ("" != name)
		    tmpdellist = add (tmpdellist, name);
	    });
	}
	list nyl = maplist (`e, nonyast, ``{return lookup (e, "name", "");});
	nyl = filter (`e, nyl, ``(e != ""));
	printcap = maplist (`e, printcap, ``{
	    boolean ready = contains (nyl, lookup (e, "name", ""));
	    string state = spooler + "-state";
        // changed due to bug #19224, but I'm not sure, if it is really OK!
	    e[state] = ready ? e[state]:"changed" : "changed";
	    return e;
	});
	printcap = maplist (`e, printcap, ``{return assignStates (e, false);});
	if (old_default != "" && old_default != nil)
	    default = old_default;
        foreach (`e, nonyast, ``{
            string name = lookup (e, "name", "");
	    if (! contains (tmpdellist, name))
	    {
                if (! contains (tmplist, name))
                {
		    string uri = lookup (e, "uri", "");
		    e = add (e, "type", "nonYaST");
                    printcap = add (printcap, e);
                }
	        else if (spooler == "cups")
	        {
		    printcap = maplist (`ye, printcap, ``{
		        if (lookup (ye, "name", "") == name)
			{
			    if (lookup (e, "ppd", "") != "")
			    {
			        ye = add (ye, "ppd", lookup (e, "ppd", ""));
			    }
			    if (lookup (ye, "uri", "") == "")
			    {
				ye = add (ye, "uri", lookup (e, "uri", ""));
			    }
		        }
			return ye;
		    });
	        }
	    }
        });
        original_unique_keys = $[];
        foreach (`i, printcap, ``{
            if (haskey (i, "unique_key"))
                original_unique_keys = add (original_unique_keys, lookup (i, "unique_key", ""), true);
        });
	read_done = true;
	assignDefault ();
        return ret;
     }
    /**
      * deletes printers
      * @param l list of strings representing names
      * @return success state
      */
    global define boolean deletePrinters (list l) ``{
	if (size (l) > 0)
	{
	    string command = "";
	    foreach (`printer, l, ``{
		string name = lookup (printer, "name", "");
		string p_type = lookup (printer, "type", "class");
		map states = lookup (printer, "states", $[]);
		if ("" != name)
		{
		    if (spooler == "cups")
		    {
			if (lookup (states, "cups-state", "changed") != "commited")
			{
			    if (p_type == "class")
			    {
				SCR::Write (.cups.classes.remove, name);
			    }
			    else
			    {
				SCR::Write (.cups.printers.remove, name);
			    }
			}
		    }
		    else if (spooler == "lprng")
		    {
			if (p_type != "class" && lookup (states, "lprng-state", "changed") != "commited")
			{
			    command = command +
				sformat ("/bin/rm -r /etc/lpdfilter/%1 /var/spool/lpd/%1; \n", name);
			    callLprsetup (sformat ("/usr/lib/lpdfilter/bin/lprsetup -lprng -delete %1", name));
			}
		    }
		}
	    });
	    if (command != "")
		SCR::Execute (.target.bash, command);
	}
	return true;
    }

    /**
     * Write settings.
     * @return success state
     */
    global define boolean Write () ``{
	boolean ret = true;
	boolean skip_io = false;
	if (!skip_io)
	{
	    ret = Printer::oldWrite ();
	    SCR::Execute (.target.bash, "/sbin/SuSEconfig -quick --nonewpackage --module profiles");
	    Runlevel::RunInitScript ("lpd", "restart");
	    // popup
	    Popup::Message (
		_("The new configuration \nwas stored successfully."));
	}

	if (Mode::cont)
	{
	    if (Printer::spooler == "cups")
		SCR::Execute (.target.bash, "/etc/init.d/cups stop");
	    else if (Printer::spooler == "lprng")
		SCR::Execute (.target.bash, "/etc/init.d/lpd stop");
	}
	else if (size (Printer::printcap) > 0)
	{
	    if (Printer::spooler == "cups")
	    {
		if (Printer::cupsInstallationType () == `server)
		{
		    SCR::Execute (.target.bash_background,
			"/etc/init.d/cups restart");
		}
		else
		{
		    SCR::Execute (.target.bash, "/etc/init.d/cups stop");
		}
	    }
	    else if (Printer::spooler == "lprng")
	    {
		SCR::Execute (.target.bash, "/etc/init.d/lpd restart");
	    }
	}
	return ret;
    }
    global define boolean oldWrite () ``{
	Printerlib::stopServices();
	if (spooler == "cups")
	{
	    if (SCR::Read (.init.scripts.exists, "lpd"))
		Runlevel::ServiceAdjust ("lpd", "disable");
	    if (`server == cupsInstallationType ())
	    {
		writeCupsSettings ();
		server_hostname = "";
		saveClientHostName ();
	    }
            if (`client == cupsInstallationType ())
	    {
		Printerlib::stopServices();
		if (SCR::Read (.init.scripts.exists, "cups"))
		    Runlevel::ServiceAdjust ("cups", "disable");
		saveClientHostName ();
		boolean delete = false;
		if (! Mode::autoinst)
		{
		    // popup
		    delete = Pkg::IsProvided ("cups") && Popup::YesNo (_("Some packages installed are not needed
for CUPS client-only installation. 
Remove them?
"));
		}
		if (delete)
		{
		    import "PackageCallbacks";
		    list del = ["cups", "cups-drivers", "cups-drivers-stp", "cups-drivers-de", "cups-drivers-cs"];
		    del = filter (`e, del, ``(Pkg::IsProvided(e) == true));
/*		    map script = $["userInput" : false, "install" : "", "delete" : del];
		    string fn = SCR::Read (.target.tmpdir);
		    fn = fn + "/script.sw_single";
		    SCR::Write (.target.ycp, fn, script);
		    CallFunction (`sw_single (fn));*/
		    foreach (`d, del, ``{Pkg::PkgDelete (d);});
		    Pkg::PkgSolve ();
		    Pkg::PkgCommit (0);
		    WFM::CallModule("inst_suseconfig", []);
		}
		return true;
	    }
	}
	else
	{
	    if (SCR::Read (.init.scripts.exists, "cups"))
		Runlevel::ServiceAdjust ("cups", "disable");
	}
	restartSpoolerIfNeeded (true);
	// caption of progress
	Progress::New (_("Saving settings of printers. Please wait..."),
		       // progress stages, short texts
		       " ", size (printcap) + 3,
			// progress bar states
		       [ _("Delete old printers"),
			// progress bar states
			 _("Save printers"),
			// progress bar states
			 _("Save system settings") ],
			// progress bar states
		       [ _("Deleting old printers..."),
			// progress bar states
			 _("Saving printer..."),
			// progress bar states
			 _("Saving system settings...")],
		       "");
	Progress::NextStage ();

	deletePrinters (deleted);
	deleted = maplist (`e, deleted, ``{
	    map states = lookup (e, "states", $[]);
	    if (spooler == "cups")
	    {
		states = add (states, "cups-state", "commited");
	    }
	    else if (spooler == "lprng")
	    {
		states = add (states, "lprng-state", "commited");
	    }
	    e = add (e, "states", states);
	    return e;
	});

	Progress::NextStage ();
	list unique_keys = [];
	//
	// We are not sure if default printer exists, someone could have deleted it.
	// If default printer does not exist, set default printer to "".
	//
	boolean default_printer_found = false;
	printcap = maplist (`entry, printcap, ``{
	    string uri = lookup (entry, "uri", "");
	    string name = lookup (entry, "name", "");
	    // progress title
	    Progress::Title (sformat (_("Saving printer %1"), name));
	    if (name == "")
	    {
		// error report. %1 is queue name
		Report::Error (sformat (_("Attempting to save unnamed printer. Skipping: %1"), ent));
		return;
	    }
	    string state = spooler + "-state";
	    if (name == default && lookup (entry, state, "changed") != "void")
		default_printer_found = true;

	    string unique_key = lookup (entry,"unique_key", nil);
	    if (nil != unique_key)
	    {
		unique_keys = add (unique_keys, unique_key);
		original_unique_keys = add (original_unique_keys, unique_key, false);
	    }
	    entry = fixPrinter(entry);
	    if (spooler == "cups")
	    {
		if (lookup (entry, "cups-state", "changed") == "void")
		{
		    Popup::Message (sformat(
			// popup %1 is queue name
			_("Queue %1 cannot be saved because
the selected spooler does not support it."), name));
		}
		else if ((lookup (entry, "cups-state", "changed") == "changed" || save_all) && (lookup (entry, "type", "yast2") == "yast2"))
		{
		    y2debug ("Saving printer %1", entry);
		    if (writeCupsPrinter (entry))
		    {
			y2debug ("Success");
			entry = add (entry, "cups-state", "commited");
		    }
		}
	    }
	    else if (spooler == "lprng")
	    {
		if (lookup (entry, "lprng-state", "changed") == "void")
		{
		    Popup::Message (sformat(
			// popup %1 is queue name
			_("Queue %1 cannot be saved because
the selected spooler does not support it."), name));
		}
		else if ((lookup (entry, "lprng-state", "changed") == "changed" || save_all) && (lookup (entry, "type", "yast2") == "yast2"))
		{
		    if (writeLpdPrinter (entry))
			entry = add (entry, "lprng-state", "commited");
		}
	    }
	    Progress::NextStep ();
	    return entry;
	});
	Progress::NextStage ();
	saveTheConfiguration();
	if (spooler == "cups")
	{
	}
	else
	{
	    // set 0644 mode to /etc/printcap (file does not exist if there is no printer)
	    if (-1 != SCR::Read(.target.size, "/etc/printcap"))
		SCR::Execute (.target.bash, "/bin/chmod 0644 /etc/printcap");
	}

	// Save unique_keys for autedetected printers to libhd
	foreach (`k, `v, original_unique_keys, ``{
	    SCR::Write (.probe.status.configured, k, v ? `no : `yes);
	});
	if (spooler == "cups")
	{
	    SCR::Write (.sysconfig.printer.DEFAULT_PRINTER, default_printer_found ? default : "none");
	    SCR::Write (.sysconfig.printer, nil);
	    SCR::Write (.cups.default_dest, default_printer_found ? default : "");
	    SCR::Execute (.target.bash, "/usr/sbin/rccups restart");
	    if (size (printcap) > 0)
		Runlevel::ServiceAdjust ("cups", "enable");
	    else
	    {
		Printerlib::stopServices();
		if (SCR::Read (.init.scripts.exists, "cups"))
		    Runlevel::ServiceAdjust ("cups", "disable");
	    }
	}
	else
	{
	    SCR::Write (.sysconfig.printer.DEFAULT_PRINTER, default_printer_found ? default : "none");
	    SCR::Write (.sysconfig.printer, nil);
	    if (size (printcap) > 0)
		Runlevel::ServiceAdjust ("lpd", "enable");
	    else
	    {
		Printerlib::stopServices();
		if (SCR::Read (.init.scripts.exists, "lpd"))
		    Runlevel::ServiceAdjust ("lpd", "disable");
	    }
	}
	    Progress::NextStage ();
	return true;
    }

    /**
      * Remove from deleted printers list printers which are deleted from both spoolers and which were recreated
      */
    define void cleanDeletedPrinters () ``{
	//remove deleted from all spoolers from list
	deleted = filter (`e, deleted, ``{
	    map states = lookup (e, "states", $[]);
	    boolean res = false;
	    foreach (`k, `v, states, ``{
		if (v != "commited")
		    res = true;
	    });
	    return res;
	});
    }
    /**
     * Write /var/lib/yast2/printers
     * @return boolean true if successful
     */

    define boolean saveTheConfiguration () ``{
	list l = filter (`e, printcap, ``(lookup (e, "type", "yast2") == "yast2"));
	list forbidden_keys = ["changed", "ppd", "auto_propose",
	    "modelset_required", "composite", "comment", "saved",
	    "newer_gs_upp", "database", ];
	l = maplist (`e, l, ``(filter (`k, `v, e,
	    ``(! contains (forbidden_keys, k)))));
	cleanDeletedPrinters ();
	map save = $["printers" : l, "deleted" : deleted, "default" : default,
	    "cups_usb_devices" : cups_usb_dev_names ];
	save["version"] = version;
	if (! SCR::Write (.target.ycp, "/var/lib/YaST2/printers", save))
	{
	    // error report. %1 is filename
	    Report::Error (sformat (_("Cannot write %1."), "/var/lib/YaST2/printers"));
	    return false;
	}
	// It can contain Samba/Novell passwords...
	SCR::Execute (.target.bash, sformat ("/bin/chmod 600 %1", "/var/lib/YaST2/printers"));
	return true;
    }

    /**
      * separates from config map only values of specified type
      * @param config Map of configuration
      * @param type String specifying type
      * @return map of selected values
      */
    global define map getArgsOfType (map config, string type) ``{
	map result = $[];

	foreach (`k, `v, config, ``{
	    map valmap = lookup (config, k, $[]);
	    string value = lookup (valmap,type,"");
	    if (value != "") {
		result = add (result, k, value);
	    }
	});
	return result;
    }

    /**
     * Write conf file onto disk.
     * @param fn filename
     * @param conf file contents
     */
    define void writeConf (string fn, map conf) ``{
	string s = "#\n# for documentation see /usr/lib/lpdfilter/global/optional.options\n#\n\n";
	foreach (`k, `v, conf, ``{
	    s = s + sformat ("%1=\"%2\"\n", k, v);
	});
	SCR::Write (.target.string, fn, s);
	SCR::Execute (.target.bash, sformat ("/bin/chmod 660 %1 ; /bin/chown lp:lp %1", fn));
    }

    /**
     * Create string with the definition of samba print command
     * @param uri Uri of the printer
     * @return string string with definition
     */
    define string getRemoteEntry (string uri) ``{
	boolean type = (("novell" == Printerlib::getUriType (uri)) ? true : false);
	list up = Printerlib::getUriUsernamePass (uri);
	string user = "";
	string pass = "";
	if (select (up, 0, "") != "")
	    user = sformat ("-U \"%1\"", select (up, 0, ""));
	if (select (up, 1, "") != "") // -P only for non empty novell printer
	    pass = ((type ? "-P " : "") + sformat ("\"%1\"", select (up, 1, "")));

	return type ?
	    sformat ("/usr/lib/lpdfilter/redirect/novell_print -S %1 %2 %3 -q \"%4\" -\n",
		    Printerlib::getUriHost (uri), user, pass, Printerlib::getUriRemoteQueue (uri))
	    :
	    sformat ("/usr/lib/lpdfilter/redirect/samba_print //%1/\"%2\" %3 %4 -N -P\n",
		    Printerlib::getUriHost (uri), Printerlib::getUriRemoteQueue (uri), pass, user);
    }
    /**
     * Create .upp file from the options. Note that there can be depended options.
     * @param options Options list
     * @return string upp file content
     */
    define string optionsToString (list options) ``{
	string upp = "";
	if (nil != options)
	{
	    foreach (`opt, options, ``{
		integer defaultindex = lookup (opt,"defaultindex", nil);
		string def = lookup (opt, "default", "");
		list val = lookup (opt,"values", []);
		list depended_opt = lookup (select (val,0, $[]),"options", nil);
		if (nil != defaultindex)
		{
		    def = lookup (select (val,defaultindex, $[]),"value", nil);
		    depended_opt = lookup (select (val,defaultindex, $[]),"options", nil);
		}
		//else if there is no defaultindex, no changes were made, so let "default"
		if (def != "")
		    upp = upp+sformat ("%1\n", def);
		// if there is no defaultindex, no suboptions can be here
		if (nil != depended_opt)
		    upp = upp+optionsToString (depended_opt);
	    });
	}
	return upp;
    }
    /**
     * Creates summary from autodetected printers and printcap.
     * @param style type of summary - list of symbols - flags:
     *		`test: add test link<br>
     *		`nonew: do not include new -- unconfigured printers into summary<br>
     *		`short: short summary doesn't contain queue description
     *		`state: show printer state
     * @return summary string
     */
    global define string Summary (list style) ``{
	if (spooler == "cups" && cups_installation == `client)
	{
	    string ret =
                // summary text
                // %1 is info about config status of the server
		sformat (_("<LI>CUPS Client-Only Configuration:<BR>%1</LI>"),
			// summary text part
			// %1 server name
		    sformat (_("using server %1."), server_hostname));
	    list servers = filter (`s, cups_servers, ``(s != server_hostname));
	    servers = toset (servers);
	    if (size (servers) > 0)
	    {
		// sumary text
		ret = ret + sformat(_("<li>Other Detected Servers:<br>%1</li>"),
		    mergestring (servers, ", "));
	    }
	    ret = "<UL>" + ret + "</UL>";
	    return ret;
	}
	// Configured as name_of_queue.
	string format = contains (style, `short) ? _("Configured as %1.")
	// Configured as name_of_queue.
	: _("Configured as:<br>%1");
	list summary = [];
	list used = [];
	// autodetected printer
//	y2milestone ("Listing autodetected");
	foreach (`i, autodetected, ``{
	    string found = "";
	    string vendor = lookup (i, "vendor", "");
	    string model = lookup (i, "device", "");
	    string dev = sformat ("%1 %2: %3", vendor, model, Printerlib::getUriNiceName (lookup (i, "uri", "")));
	    foreach (`entry, printcap, ``{
		if (lookup (i, "unique_key", "") == lookup (entry, "unique_key", " "))
		{
		    entry = assignStates (entry, false);
		    string cache = lookup (entry, "name", "");
		    used = add (used, cache);
		    if (contains (style, `test))
		    {
			if ((spooler == "cups" && lookup (entry, "cups-state", "") != "void")
			    || (spooler == "lprng" && lookup (entry, "lprng-state", "") != "void"))
			{
			    cache = sformat ("%1 [<a href=\"%1\">test</a>]", cache);
			}
		    }
		    if (contains (style, `short))
		    {
			found = found + ("" != found ? ", " : "") + cache;
		    }
		    else
		    {
			string state = "";
			if (spooler == "cups")
			    state = entry["cups-state"]:"changed";
			else if (spooler == "lprng")
			    state = entry["lprng-state"]:"changed";
			if (state != "" && state != nil)
			{
			    if (state == "commited")
			    {
				// summary part, printer state
				state = " - " + HTML::Colorize (
				    _("ready"), "green");
			    }
			    else if (state == "changed")
			    {
				// summary part, printer state
				state = " - " + HTML::Colorize (
				    _("changed, not yet saved"), "orange");
			    }
			    else if (state == "void")
			    {
				// summary part, printer state
                                state = " - " + HTML::Colorize (
                                    _("invalid for current spooler"), "red");
			    }
			    else state = "";
			}
			found = found + ("" != found ? "<br>" : "") + cache + state;
		    }
		}
	    });
	    if ("" == found)
	    {
		if (!contains (style, `nonew))
		    summary = add (summary, Summary::Device (dev, Summary::NotConfigured ()));
	    }
	    else
		summary = add (summary, Summary::Device (dev, contains (style, `short) ? sformat (format, found) : sformat (format + "<br>", found)));
	});
//	y2milestone ("Listing others");
	// other than autodetected printers
	map other_printers = $[];
	foreach (`i, printcap, ``{
	    string cache = lookup (i, "name", "");
	    if (!contains (used, cache))
	    {
		string type = lookup (i, "type", "yast2");
		string cfg = "";
		if (type == "yast2")
		{
		    string model = "";
		    model = i["vendor_ieee"]:"" + " " + i["device_ieee"]:"";
		    string ppd = lookup (i, "ownppd", "");
	            if (ppd != "" && ! isPpd (ppd))
	                ppd = lookup (i, "ppd", "");
		    if ("" != ppd)
			model = "PPD file: ";
	            if (isPpd (ppd))
	            {
	                map info = ppdInfo (lookup (i, "ownppd", ""));
	                model = lookup (info, "manufacturer", "") + " " + lookup (info, "model", "");
	            }

		    i = assignStates (i, false);
		    boolean raw = i["raw"]:false;
		    string dev = (raw ?
			// menu item, %1 is URI
			sformat (_("Raw queue: %1"), Printerlib::getUriNiceName (lookup (i, "uri", "")))
			:
			sformat ("%1: %2", model, Printerlib::getUriNiceName (lookup (i, "uri", "")))
		    );
		    if (contains (style, `test) && !raw)
		    {
			if ((spooler == "cups" && lookup (i, "cups-state", "") != "void")
			    || (spooler == "lprng" && lookup (i, "lprng-state", "") != "void"))
			{
			    cache = sformat ("%1 [<a href=\"%1\">test</a>]", cache);
			}
		    }
		    if (!contains (style, `short))
		    {
			if (nil != cfg && "" != cfg)
			    cache = cache + "  -  " + cfg;

                        string state = "";
                        if (spooler == "cups")
                            state = i["cups-state"]:"changed";
                        else if (spooler == "lprng")
                            state = i["lprng-state"]:"changed";
                        if (state != "" && state != nil)
                        {
                            if (state == "commited")
                            {
                                // summary part, printer state
                                state = " - " + HTML::Colorize (
				    _("ready"), "green");
                            }
                            else if (state == "changed")
                            {
                                // summary part, printer state
                                state = " - " + HTML::Colorize (
				    _("changed, not yet saved"), "orange");
                            }
                            else if (state == "void")
                            {
                                // summary part, printer state
                                state = " - " + HTML::Colorize (
				    _("invalid for current spooler"), "red");
			    }
                            else state = "";
                        }
			cache = cache + state;
		    }
		    if (haskey (other_printers, dev))
			other_printers = add (other_printers, dev, lookup (other_printers, dev, "???") + (contains (style, `short) ? ", " : "<br>") + cache);
		    else
			other_printers = add (other_printers, dev, cache);
		}
		else
		{
		    // This printer was not configured using YaST2. Item in table. SHORT!
		    if (contains (style, `test))
			cache = sformat ("%1"/* [<a href=\"%1\">test</a>]"*/, cache);
		    // menu item part
		    if (haskey (other_printers, _("- not YaST2 -")))
			// menu item part
			other_printers = add (other_printers, _("- not YaST2 -"), lookup (other_printers, _("- not YaST2 -"), "???") + ", " + cache);
		    else
			// menu item part
			other_printers = add (other_printers, _("- not YaST2 -"), cache);
		}
	    }
	});
	foreach (`k, `v, other_printers, ``{
	    summary = add (summary, Summary::Device (k, sformat (format, v)));
	});
	if (spooler == "cups")
	{
	    if (cups_server_settings["Browsing"]:"On" == "On")
	    {
		// part of summary
		summary = add (summary, _("<LI>Listenning to IPP broadcasts
to access queues of remote CUSP servers.</LI>"));
	    }
	}
	return Summary::DevicesList (summary);
    }
    /**
     * get list of names of deleted printers.
     * @return List of names.
     */
    global define list DeletedNames () ``{
	return toset (maplist (`i, deleted, ``(lookup (i, "name", ""))));
//	return toset (union (deleted, deleted_classes));
    }

    /**
     * Get type of currently selected printer. Just a shortcut
     * to Printerlib::getUriType (...)
     * @return printer type
     */
    global define string getUriType () ``{
	return Printerlib::getUriType (lookup (printer, "uri", ""));
    }


    /**
     * Constructor only grabs Args
     */
    global define void Printer () ``{
	integer i = 0;
	while (i < size (Args ()))
	{
	    i = i + 1;
	}
	return ;
    }
    /**
     * Prepare detected printer to be configured.
     * @param det map of detected printer
     */
    global define void editDetected (map det) ``{
	index = -1;
	y2debug ("Editing printer %1", det);
	printer = $[
	    "vendor_ieee" : det["vendor"]:"",
	    "device_ieee" : det["device"]:"",
	    "vendor_db" : det["vendor_db"]:"",
	    "device_db" : det["device_db"]:"",
	    "unique_key" : det["unique_key"]:"",
	    "uri" : det["uri"]:"",
	    "info": det["info"]:"",
            "location": det["location"]:"",
	    "vendor_id": det["vendor_id"]:0,
	    "device_id": det["device_id"]:0,
            "accepting": true,
            "state": "idle",
	    "options" : $[],
	    "name" : generateQueueName (nil, det["uri"]:"",
		det["vendor_db"]:"", det["device_db"]:"",
		getForbiddenNames ()),
	    "config" : getAutoPpdFile (
		det["vendor_db"]:"", det["device_db"]:"", nil),
	];
	y2milestone ("Detected printer after editation: %1", printer);
    }
    /**
     * Has the printer been already configured?
     * @param uk unique key of the printer
     * @return true or false
     */
    global define boolean alreadyConfigured (string uk) ``{
	boolean was = false;
	foreach (`i, printcap, ``{
	    if (!was && lookup (i, "unique_key", ".a") == uk)
		was = true;
	});
	return was;
    }

    /**
     * Autoconfigure all printers that haven't been configured yet.
     */
    global define void Propose () ``{
	if (spooler == "cups")
	    Printerlib::setCupsUsbDevicesInfo ();
	// settings are read and hw is detected
	list forbidden_names = getForbiddenNames ();
	symbol page_size = Printerlib::getDefaultPaperSize ();
	foreach (`i, autodetected, ``{
	    if (!alreadyConfigured (i["unique_key"]:""))
	    {
		editDetected (i);
		string vdb = printer["vendor_db"]:"";
		string mdb = printer["device_db"]:"";
		string ppd_file = getAutoPpdFile (vdb, mdb, nil);
		boolean configure
		    = 0 == foomatic[vdb, mdb, `support]:0;
		if (ppd_file != nil && configure)
		{
		    boolean ok = true;
		    printer["name"] = generateQueueName (nil, printer["uri"]:"",
			printer["vendor_ieee"]:"", printer["device_ieee"]:"",
			getForbiddenNames ());
		    printer["config"] = ppd_file;
		    foreach (string paperentry, ["ImageableArea",
			"PageRegion", "PageSize", "PaperDimension"],
		    ``{
			if (page_size == `letter)
			    printer["options", paperentry] = "Letter";
			else
			    printer["options", paperentry] = "A4";
		    });
		    if (ok)
		    {
			printer = assignStates (printer, true);
			y2milestone ("Configuring autodetected printer %1",
			    printer);
			storePrinter ();
		    }
		}
	    }
	});
	assignDefault ();
    }
    /**
     * Check if queue name is OK. Otherwise adds number at the end.
     * @param name printer name
     * @param forbidden_names forbidden names
     * @return new queue name.
     */
    global define string adjustQueueName (string name, list forbidden_names) ``{
	if (!contains (forbidden_names, name))
	    return name;
	name = name + "%1";
	integer i = 1;
	while (contains (forbidden_names, sformat (name, i)))
	{
	    i = i + 1;
	}
	return sformat (name, i);
    }
    /**
     * Get the suffix for the queue name.
     * @param queues list of new queues. Keys are the names of the queues.
     * @return suffix
     */
    global define string getQueueSuffix (list queues) ``{
	integer highest = 0;
	integer work = 0;
	foreach (`v, queues, ``{
	    integer end = size (lookup (v, "name", ""));
	    foreach (`i, printcap, ``{
		if (substring (lookup (i, "name", ""), 0, end) == lookup (v, "name", ""))
		{
		    if (regexpmatch (substring (lookup (i, "name", ""), end),
			"^[0-9]*$"))
		    {
			string workstr = substring (i["name"]:"", end);
			if (workstr != "")
			    work = tointeger (workstr);
			else
			    work = 0;
			if (work + 1 > highest)
			    highest = work + 1;
		    }
		}
	    });
	});
	if (0 == highest)
	    return "";
	return sformat ("%1", highest);
    }
    /**
      * does file exist?
      * @param file string filename to test
      * @return true if exists
      */
    global define boolean isFile (string file) ``{
	integer filesize = SCR::Read (.target.size, file);
	if (filesize < 0)
	    return false;
	return true;
    }
    /**
      * Is file a ppd file?
      * @param file string filename to test
      * @return true if yes
      */
    global define boolean isPpd (string file) ``{
	if (! isFile (file))
	    return false;
	return SCR::Read (.ppd.file.isppd, file);
    }
    /**
      * Get PPD file info
      * @param file string filename to get info from
      * @return map of informations
      */
    global define map ppdInfo (string file) ``{
	return SCR::Read (.ppd.file.ppdinfo, file);
    }
    /**
      * Add unpresent entries into a map
      * @param p map of printer
      * @return modified map
      */
    global define map fixPrinter (map p) ``{
	if (lookup (p, "accepting", true) == true)
	    p = add (p, "accepting", true);
	if (lookup (p, "state", "idle") == "idle")
	    p = add (p, "state", "idle");
	if (lookup (p, "bannerstart", "") == "")
	    p = add (p, "bannerstart", "none");
	if (lookup (p, "bannerend", "") == "")
	    p = add (p, "bannerend", "none");
	return p;
    }

    /**
      * List all available queues (local and remote)
      * @return list of strings all available queues
      */
    global define list(string) GetAvailableQueues () ``{
	list(string) ret = [];
	string state = spooler + "-state";
	list(map) relevant = filter (`e, printcap, ``(e[state]:"" != "void"));
	if (spooler != "cups")
	{
	    list pc = SCR::Read (.etc.printcap);
	    foreach (`e, pc, ``{
		ret = add (ret, e["name"]:"");
		string printcap_part = e["saved", "printcap_part"]:"";
		list l = splitstring (printcap_part, "\n");
		l = maplist (`i, l, ``{
		    integer hash = findfirstof (i, "#");
		    if (hash != nil)
			i = substring (i, 0, hash);
		    if (substring (i, size (i)) == "\\")
			i = substring (i, 0, size (i) - 1);
		    return i;
		});
		printcap_part = mergestring (l, "");
		l = splitstring (printcap_part, ":");
		string names = l[0]:"";
		l = splitstring (names, "|");
		l = filter (`n, l, ``(n != "" && ! issubstring (n, " ")));
		foreach (`n, l, ``{
		    ret = add (ret, n);
		});
	    });
	    ret = toset (filter (string r, ret, ``(r != "")));
	}
	else
	{
	    string hostname = "localhost";
	    if (cupsInstallationType () == `client && server_hostname != "")
		hostname = server_hostname;
	    ret = SCR::Read (.cups.remote, hostname);
	    ret = maplist (string r, ret, ``{
		r = substring (r, 6);
		integer slash = findfirstof (r, "/");
		if (slash != nil)
		    r = substring (r, slash + 1);
		if (substring (r, 0, 9) == "printers/")
		    r = substring (r, 9);
		else if (substring (r, 0, 8) == "classes/")
		    r = substring (r, 0, 8);
		return r;
	    });
	    ret = toset (ret);
	}
	y2error ("Ret: %1", ret);
	return ret;
    }
}
