/**
 * File:
 *  dialogs.ycp
 * Module:
 *  Printer configurator
 * Summary:
 *  Main dialogs.
 * Authors:
 *  Petr Blahos <pblahos@suse.cz>
 *
 * $Id$
 * Main dialogs.
 */
{
    textdomain "printer";

    import "Wizard_hw";
    import "Printerlib";
    import "Printer";
    import "Arch";

    include "printer/misc.ycp";
    include "printer/helps.ycp";
    include "ui/common_popups.ycp";
    include "ui/file_popups.ycp";
    include "wizard/sequencer.ycp";

    include "printer/dialogs-cups.ycp";
    include "printer/dialogs-lprng.ycp";
    include "printer/testpage.ycp";


    /**
      * for temporary storing of printer model
      * because of `back button
      */
    global map tmp_printer_manuf_model = $[];

    /**
      * Casts value type to integer if you know what I am talking about.
      * @param a value
      * @return integer representation of a
      */
    global define integer AnyToInteger (any a) ``{
	integer c = a;
	return c;
    }
    /**
      * Disk file specification
      * @return symbol `next or `back
      */
    global define symbol runPipeDialog () ``{
	//
	// parse Uri
	//
	string file = lookup (Printer::printer, "uri", "");
	if ("" != file && nil != file)
	{
	    // file must start with "file:"
	    if ( "file:" != substring (file, 0, 5) && "pipe:" != substring (file, 0, 5))
	    {
		file = "";
	    }
	    else
	    {
		file = substring (file, 5);
		while ("/" == substring (file, 0, 1))
		{
		    file = substring (file, 1);
		}
		file = "/" + file;
	    }
	}
	term contents = `HBox (
	    `HSpacing (8),
	    `VBox (
		// frame label
		`Frame ( _("Connection"),
			 `VBox (
			     `HBox (
				 `HSpacing (0.7),
				 // text entry label
				 `TextEntry (`id(`name), _("&Program name:"), file),
				 `HSpacing (0.7)
				 ),
			     `VSpacing (0.5)
			     )
		    )
		),
	    `HSpacing (8)
	    );
	// dialog label
	Wizard::SetContentsButtons (_("Printing to pipe"), contents,
	    getDiskFileHelp (), BackButtonLabel (), NextButtonLabel ());

	symbol ret = nil;
	while (true)
	{
	    ret = UI::UserInput ();
	    if (ret == `cancel)
		ret = `abort;
	    if (`next == ret)
	    {   // get the file name
		string name = UI::QueryWidget (`id (`name), `Value);
		if (size (name) > 0)
		{
		    if ( "/" != substring (name, 0, 1))
		    {
			name = "/" + name;
		    }
		    file = "pipe:" + name;
		    Printer::printer = add (Printer::printer, "uri", file);
		    break;
		}
		else
		{
		    UI::MessagePopup (
		    // message box
			_("Enter full path of the program to which to print through pipe."));
		}
	    }
	    else if (`back == ret)
	    {
		break ;
	    }
	    else if (`abort == ret)
	    {
		if (reallyAbort ())
		{
		    break;
		}
	    }
	}
	return ret;
    }
    /**
     * Asks user about settings of selected device (port number, other settings
     * for serial ports). Lets user do test of device. Uses global variable
     * printer.
     * @param type "parallel", "serial", "usb"
     *
     * @return symbol `back, `next, `abort
     */
    global define symbol runDeviceDialog (string type) ``{
	boolean problematic_usb = false;
	string uri = lookup (Printer::printer, "tmpuri", "");
	if ("" == uri)
	    uri = lookup (Printer::printer, "uri", "parallel");
	if ("" == type)
	{
	    type = Printerlib::getUriType ("uri");
	}
	string device = Printerlib::getUriDevice (uri);
	list devices = [];
	path read_devs = "parallel" == type ? .proc.parport.devices : "usb" == type ? .proc.usblp.devices : "irda" == type ? .proc.irlpt.devices : .proc.serial.devices;
	integer baudrate = Printerlib::getUriBaudrate (uri);
	string ser_settings = Printerlib::getUriValue (uri, "ty");
	integer i = find (device, "?");
	if (0 == baudrate && -1 == Printer::index)
	    baudrate = 9600;
	if (nil != i)
	    device = substring (device, 0, i);
	if ("irda" != type)
	    devices = SCR::Read (read_devs);
	else
	    devices = [];

	if (type == "usb" && Printer::spooler == "cups")
	{
	    Printerlib::setCupsUsbDevicesInfo ();
	    devices = Printerlib::getCupsUsbDevices ();
	    if (size (devices) != size (toset (devices)))
	    {
		problematic_usb = true;
		list problematic = Printerlib::getProblematicCupsUsbDevices ();
	        devices = maplist (`d, Printerlib::cups_usb_devices, ``{
		    if (contains (problematic, d))
		    if (true)
		    {
			return d[2]:"";
		    }
		    else
		    {
			return d[0]:"";
		    }
		});
	    }
	}

	if (size (devices) == 0)
	{
	    if (type == "parallel")
	    {
		// popup CAUTION: "device" here means /dev/lp0, /dev/lp1, ...
		UI::MessagePopup (_("No parallel devices (/dev/lp?) found. It seems
that your parallel port is not properly configured.
"));
		devices = add (devices, "/dev/lp0");
	    }
	    else if (type == "usb")
	    {
		// popup CAUTION: "device" here means /dev/usb/lp0, /dev/usb/lp1, ...
		UI::MessagePopup (_("No USB devices (/dev/usb/lp?) found. It seems
that your USB bus is not properly configured.
"));
		devices = add (devices, "/dev/usb/lp0");
	    }
	    else if (type == "serial")
	    {
		// popup CAUTION: "device" here means /dev/ttyS0, /dev/ttyS1, ..
		UI::MessagePopup (_("No serial devices (/dev/ttyS?) found. It seems
that your serial ports are not properly configured.
"));
		devices = add (devices, "/dev/ttyS0");
	    }
	    else if (type == "irda")
	    {
		devices = ["/dev/irlpt0", "/dev/irlpt1", "/dev/irlpt2", "/dev/irlpt3"];
	    }
	}
	if (type != Printerlib::getUriType (device))
	    device = "";
	if (device == "")
	    device = select (devices, 0, "");
	list device_val = getDevicesItems (devices, device);
	term details = `VBox (
	    // PushButton
	    `HBox (`HStretch (), `PushButton (`id (`details), _("&Other...")))
	);

	if ("parallel" == type || "serial" == type)
	{
	    if (!Mode::config)
	    {
		details = add (details,
		    `HBox (`HStretch (), `PushButton (`id ("parallel" == type ? `ppdetails : `spdetails), `opt (`key_F2),
			// PushButton
			"parallel" == type ? _("&Parallel port details...")
			// PushButton
			    : _("&Serial port details..."))));
	    }
	}

	term contents =
	    `VBox (`VSpacing (2),
		   `HBox (`HSpacing (5),
			  // frame
			  `Frame (_("Connection"),
				  `HBox (`HSpacing (0.7),
					 `VBox (`VSpacing (0.2),
						`ReplacePoint (
						    `id (`devicesel_replace),
						    `SelectionBox (
							`id (`devicesel),
							`opt (`notify),
							// Unix device /dev/(lp|usb/lp|ttyS)*
							_("Select the d&evice:"), device_val)
						    ),
						details,
						`VSpacing (0.2)),
					 `VSpacing (6),  // Vert. size of the selection box...
					 `HSpacing (0.7))),
			  `HSpacing (5)),
		   `VStretch (),
		    // pushbutton
		   `PushButton (`id (`test), `opt (`key_F6), _("&Test printer connection")),
		   `VStretch ()
		);
	Wizard::SetContentsButtons (getAskDeviceLabel (type), contents, getAskDeviceHelp (type), BackButtonLabel (), NextButtonLabel ());

	if (problematic_usb)
	{
	    if (Printer::conf_detected)
	    {
		UI::MessagePopup (_("Warning!

USB printer detection found at least two printers
that have the same identification.
You must select and configure them manually.
Do the \"Test\" to make sure which printer is
actually selected.
"));

	    }
	    else
	    {
		UI::MessagePopup (_("Warning!

USB printer detection found at least two printers
that have the same identification.
Do the \"Test\" to make sure which printer is
actually selected.
"));
	    }
	}

	symbol ret = nil;
	repeat {
	    ret = UI::UserInput ();
            if (ret == `cancel)
                ret = `abort;
	    device = UI::QueryWidget (`id (`devicesel), `CurrentItem);

/*	    if (type == "serial")
	    {
		ser_settings = UI::QueryWidget (`id (`ser_settings), `Value);
		string tmp = UI::QueryWidget (`id (`baudent), `Value);
		baudrate = tointeger (tmp);
		if (`next == ret && !testBaudRate (baudrate))
		    ret = nil;
	    }*/

	    if (ret == `test)
	    {
		Printerlib::testDevice (device);
	    }
	    else if (`abort == ret || `cancel == ret)
	    {
		ret = reallyAbort () ? `abort : nil;
	    }
	    else if (`details == ret)
	    {
		string device_temp = getDeviceName (device);
		if ("" != device_temp)
		{
		    device = device_temp;
		    device_val = getDevicesItems (devices, device);
		    UI::ReplaceWidget (
			`id (`devicesel_replace),
			`SelectionBox (
			    `id (`devicesel),
			    `opt (`notify),
			    // Unix device /dev/(lp|usb/lp|ttyS)*
			    _("Select the d&evice:"), device_val)
			);
		}
	    }
	} until (ret == `abort || ret == `back || ret == `next || `ppdetails == ret || `spdetails == ret);
	if (`spdetails == ret)
	{
	    uri = type + ":" + device;
	    if ("serial" == type)
		uri = uri + sformat ("?baudrate=%1+ty=%2", baudrate, ser_settings);
	    Printer::printer = add (Printer::printer, "tmpuri", uri);
	}
	else
	{
	    Printer::printer = filter (`k, `v, Printer::printer, ``(k != "tmpuri"));
	}
	if (`next == ret)
	{
	    uri = type + ":" + device;
	    if ("serial" == type)
		uri = uri + sformat ("?baudrate=%1+ty=%2", baudrate, ser_settings);
	    Printer::printer = add (Printer::printer, "uri", uri);
	}
	return ret;
    }
    /**
     * Asks user about settings of selected type of remote pritner. E.g. hostname,
     * username+password for samba, ncp, ...
     * @param type one of "samba", "novell", "lpd", "ipp", "socket"
     * @return symbol `next, `back, `abort
     */
    global define symbol runRemoteDialog (string type) ``{
	string uri = lookup (Printer::printer, "uri", "");
	string user = "";
	string password = "";
	string queue = type == "ipp" ? "printers/" : "";
	string hostname = "";
	string workgroup = "";
	integer port = 0;

	// check necessary packages
	list packages_to_check = [];
	if (type == "samba")
	{
	    packages_to_check = ["samba-client"];
	}
	else if (type == "novell")
	{
	    packages_to_check = ["ncpfs"];
	}
	if (packages_to_check != [])
	{
	    import "Require";
	    Require::RequireAndConflictTarget (packages_to_check, [],
		"<P>For the selected function, the additional packages<BR>
<TT>%1</TT><BR> must be installed.<BR><BR> Install them now?</P>");
	}

	boolean supported = testSupportedQueue (type);
	if (! supported)
	{
	    return `back;
	}

	boolean has_user_password = (type == "samba" || type == "novell");

	// label
	string hent_str = _("&Host name of the printer server:");
	term uspas = `VSpacing (0.2);

	integer i = findlastof (uri, "/");
	if (nil != i)
	{
	    queue = Printerlib::getUriRemoteQueue (uri);
	    hostname = Printerlib::getUriHost (uri);
	    workgroup = Printerlib::getUriWorkgroup (uri);
	}
	if (has_user_password)
	{
	    list l = Printerlib::getUriUsernamePass (uri);
	    user = select (l, 0, "");
	    password = select (l, 1, "");
	    uspas = `VSquash (`VBox (
		// text entry label
		`TextEntry (`id (`userent), _("&User:"), user),
		// text entry label
		`Password (`id (`passwordent), _("&Password:"), password)));
	}

	// push button label
	term test_button = `PushButton (`id (`test), `opt (`key_F6),
	    _("&Test remote LPD access"));
	term queue_button = `HSpacing (0);
	term queue_entry = `TextEntry (`id (`queueent),
					  // text entry label
					  _("Name of the remote &queue:"),
					  queue);
	// menu button
	term lookup_hosts = `MenuButton (_("&Lookup"), [
			// menuentry
		    `item (`id (`get_hosts_special), _("&LPD servers")),
			// menuentry
		    `item (`id (`get_hosts), _("&All hosts")),
		]);
	if (type == "novell")
	    {
		// menu button
		lookup_hosts = `PushButton (`id (`get_hosts), _("&Lookup"));
		// pushbutton
		test_button = `PushButton (`id (`test), `opt (`key_F6),
		    _("&Test remote Novell access"));
	    }
	if (type == "samba")
	    {
		// pushbutton
		test_button = `PushButton (`id (`test), `opt (`key_F6),
		    _("&Test remote SMB access"));
		queue_entry = `ComboBox (`id (`queueent), `opt (`editable, `hstretch),
					    // text entry label
					    _("Name of the remote &queue:"));
		// pushbutton
		queue_button = `VBox (`VStretch (), `PushButton (`id (`get_printers), _("L&ookup")));
		// menu button
		lookup_hosts = `MenuButton (_("&Lookup"), [
			// menuentry
		    `item (`id (`get_hosts_special), _("&Samba servers")),
			// menuentry
		    `item (`id (`get_hosts), _("&All hosts")),
		]);
	    }
	if (type == "ipp")
	{
	    // pushbutton
	    test_button = `PushButton (`id (`test), `opt (`key_F6), _("&Test remote IPP access"));
	    queue_entry = `ComboBox (`id (`queueent), `opt (`editable, `hstretch),
                                            // text entry label
                                            _("Name of the remote &queue:"));
					    // push button
	    queue_button = `VBox (`VStretch (), `PushButton (`id (`get_printers), _("L&ookup")));
	    // menu button
	    lookup_hosts = `MenuButton (_("&Lookup"), [
		// menu item
                `item (`id (`get_hosts_special), _("&IPP servers")),
		// menu item
                `item (`id (`get_hosts), _("&All hosts")),
            ]);
	}
	if (type == "socket")
	{
	    port = Printerlib::getUriPort (uri);
	    if (port == 0)
		port = 9100;
	    // push button
	    test_button = `PushButton (`id (`test), `opt (`key_F6), _("&Test remote socket access"));
	    // text entry label
	    queue_entry = `VBox (`VStretch (), `TextEntry (`id (`port), _("&TCP port number"), sformat("%1", port)));
	    // menu button
	    lookup_hosts = `MenuButton (_("&Lookup"), [
		// menu item
		`item (`id (`get_hosts_special), _("&Direct socket servers")),
		// menu item
		`item (`id (`get_hosts), _("&All hosts")),
	    ]);
	}

	term contents = `HBox (`HSpacing (8.0),
	      `VBox (`VStretch (),
		     // Frame around hostname, queue, (user, passwd)
		     `Frame (_("Connection information"),
			     `HBox (`HSpacing (0.7),
				    `VSquash (`VBox (
					`HBox (`HSpacing (0.5),
					       `VBox (
						   type != "samba" ? `VSpacing (0) : `TextEntry (`id (`workgroup), _("&Workgroup"), workgroup),
						   `HBox (
						       `ReplacePoint (
							   `id (`hostent_replace),
							   `ComboBox (`id (`hostnameent),
								      `opt (`editable, `hstretch),
								      hent_str)),
							   //Label: Lookup hosts on network
						       `VBox (`VStretch (),
							      lookup_hosts)
						       ),
						   `HBox (
						       `ReplacePoint (
							   `id (`queueent_replace),
							   queue_entry),
						       queue_button))),
							uspas,
					`VSpacing (0.5))),
				    `HSpacing (0.7))),
		     `VStretch (),
		     test_button,
		     `VStretch ()
		     ),
	      `HSpacing (8.0));

	// button label
	Wizard::SetContentsButtons (getAskDeviceLabel (type), contents, getAskRemoteHelp (type), BackButtonLabel (), NextButtonLabel ());

	if (type != "socket")
	    UI::ChangeWidget (`id (`queueent), `Value, queue);
	else
	    UI::ChangeWidget (`id (`port), `ValidChars, "1234567890");
	UI::ChangeWidget (`id (`hostnameent), `Value, hostname);

	symbol ret = nil;
	repeat {
	    ret = UI::UserInput ();
            if (ret == `cancel)
                ret = `abort;
	    hostname = UI::QueryWidget (`id (`hostnameent), `Value);
	    if (type == "samba")
		workgroup = UI::QueryWidget (`id (`workgroup), `Value);
	    if (type != "socket")
		queue = UI::QueryWidget (`id (`queueent), `Value);
	    else
	    {
		string tmp = UI::QueryWidget (`id (`port), `Value);
		while (substring (tmp, 0, 1) == "0")
		    tmp = substring (tmp, 1);
		if (tmp == "")
		    tmp = "9100";
		port = tointeger (tmp);
	    }
	    if (has_user_password)
		{
		    user = UI::QueryWidget (`id (`userent), `Value);
		    password = UI::QueryWidget (`id (`passwordent), `Value);
		}
	    if (`get_hosts == ret || `get_hosts_special == ret)
	    {
		// get remote hosts (we always offer list of hosts)
                list hosts = [];
		string save_type = type;
		if (`get_hosts_special == ret && type == "socket")
		{
		    type = UI::QueryWidget (`id (`port), `Value);
		    if (type == "0" || type == "")
			type = "9100";
		}
                hosts = getHostnames (`get_hosts_special == ret ? type : "");
		type = save_type;
		UI::ReplaceWidget (
		    `id (`hostent_replace),
		    `ComboBox (`id (`hostnameent), `opt (`editable, `hstretch), hent_str, sort (hosts))
		    );
	    }
	    if (`get_printers == ret && checkHostName (hostname))
	    {
		list queues = [];
		if ("samba" == type)
		{
		    queues = SCR::Read (.smb.queues, hostname);
		}
		else if ("ipp" == type)
		{
		    queues = maplist (`i, SCR::Read (.cups.remote, hostname), ``{
			if ("ipp://" == substring (i, 0, 6))
                            i = substring (i, 6);
                        else if ("http://" == substring (i, 0, 7))
                            i = substring (i, 7);
                        while ("/" != substring (i, 0, 1) && size (i) > 0)
                            i = substring (i, 1);
			while ("/" == substring (i, 0, 1) && size (i) > 0)
			    i = substring (i, 1);
                        return i;
                    });
		}
		queue_entry = `ComboBox (`id (`queueent), `opt (`editable, `hstretch),
                    // text entry label
                    _("Name of the remote &queue:"), queues);
                UI::ReplaceWidget (`id (`queueent_replace), queue_entry);
	    }
	    if (ret == `test && checkHostName (hostname) && (type == "socket" || checkQueueName (queue)) && (!has_user_password || ( checkUserName (user) && checkPassword (password))))
	    {
		string test_queue = "";
		if (type == "ipp" && "printers/" == substring (queue, 0, 9))
		    test_queue = substring (queue, 9);
		else
		    test_queue = queue;
		if ("samba" == type || "novell" == type)
		{
		    Printerlib::testRemoteUP (workgroup, hostname, test_queue, user, password, type);
		}
		else
		    Printerlib::testRemote (hostname, test_queue, type, port);
	    }
	    if (`abort == ret || `cancel == ret)
	    {
		ret = reallyAbort () ? `abort : nil;
	    }
	} until (ret == `abort || ret == `back || ret == `next && checkHostName (hostname) && (type == "socket" || checkQueueName (queue))
	     && (!has_user_password || ( checkUserName (user) && checkPassword (password))));
	uri = type + "://";
	uri = uri + (has_user_password ? user + ":" + password + "@" : "");
	if (workgroup != "")
	    uri = uri + workgroup + "/";
	uri = uri + hostname;
	if (type == "ipp" && "printers/" != substring (queue, 0, 9))
	{
	    string tmp = queue;
	    while (substring (tmp, 0, 1) == "/")
		tmp = substring (tmp, 1);
	    if (filterchars (tmp, "/") == "")
		queue = "printers/" + tmp;
	}
	queue = substring (queue, 0, 1) == "/" ? queue : "/" + queue;
	uri = uri + (type == "socket" ? ":" + port : queue);
	if (ret == `next)
	{
	    Printer::printer = add (Printer::printer, "uri", uri);
	}
	return ret;
    }
    /**
     * direct Uri definition
     * @return symbol `next or `back
     */
    global define symbol runUriDialog ()``{
	//
	// parse Uri
	//
	string device = lookup (Printer::printer, "Uri", "");
	term contents = `HBox (
	    `HSpacing (8),
	    `VBox (
		// frame label
		`Frame ( _("Connection"),
			 `VBox (
			     `HBox (
				 `HSpacing (0.7),
				  // textentry label
				 `TextEntry (`id(`name), _("&Uri:"), device),
				 `HSpacing (0.7)
				 ),
			     `VSpacing (0.5)
			     )
		    ),
		`VSpacing (2)
		),
	    `HSpacing (8)
	    );
	// dialog caption
	Wizard::SetContentsButtons (_("Printer device"), contents, getUriHelp (), BackButtonLabel (), NextButtonLabel ());

	symbol ret = nil;
	while (true)
	{
	    ret = UI::UserInput ();
            if (ret == `cancel)
                ret = `abort;
	    if (`next == ret)
	    {   // get the file name
		string name = UI::QueryWidget (`id (`name), `Value);
		Printer::printer = add (Printer::printer, "Uri", name);
		break ;
	    }
	    else if (`back == ret)
	    {
		break ;
	    }
	    else if (`abort == ret)
	    {
		if (reallyAbort ())
		{
		    break;
		}
	    }
	}
	return ret;
    }

    /**
      * Display printer information popup
      * @param info map containing info about printer from SuSE database
      * @param vdb string database key of printer vendor
      * @param mdb string database key of printer model
      */
    global define void DisplayPrinterPopup (map info, string vdb, string mdb)``{

                    string manuf_info = lookup (info, "vendor",
			// richtext
                        _("<P>No information available.</P>"));
                    string model_info = lookup (info, "printer",
                        lookup (info, "config",
			// richtext
                        _("<P>No information available.</P>")));
                    // Manufacturer: ...info... Model: ...info...  1/2
                    string info_text = _("<P><B>Manufacturer:</B></P>")
                       + manuf_info +
                        // Manufacturer: ...info... Model: ...info...  2/2
                        _("<P><B>Model:</B></P>") + model_info;
                    integer type = Printer::foomatic[vdb, mdb, `support]:1;

                    if (type != 2 && size (filter (`k, `v,
                            Printer::foomatic[vdb, mdb]:$[],
                            ``(is (k, string)))) == 0)
                    {
/*                        info_text = _("<p><B>This printer can be configured
with the SuSE database of printers only.</B></P>
") + info_text;*/
                    }
                    else if (type == 2)
                        // part of richtext
                        info_text = _("<p><B>This printer is not supported by SuSE Linux.</B></P>") + info_text;

                    // message box caption
                    UI::LongTextPopup (_("Printer information"),
                        `RichText (info_text), 50, 18);


    }

    /**
     * Ask about the manufacuturer and the model of the printer.
     * Uses global printer
     * @return symbol `back, `next, `abort
     */
    global define symbol runManufModelDialog () ``{
	y2milestone ("Manuf/model dialog started for %1", Printer::printer);
	string manuf_db = lookup (Printer::printer, "vendor_db", "");
	string model_db = lookup (Printer::printer, "device_db", "");
	if (Printer::edit_seq)
	{
	    if (tmp_printer_manuf_model == $[])
	    {
		y2debug ("tmp Storing printer %1", Printer::printer);
		tmp_printer_manuf_model = eval (Printer::printer);
	    }
	}
	map info = $[];
	boolean info_instead_next = false;

	loadFoomaticIfNeeded ();

        // selection box label
	term manufsel = `SelectionBox (`id (`manufsel), `opt (`notify),
	    // selection boc title
	    _("&Select manufacturer:"),
	    maplist (`k, `v, Printer::foomatic, ``(
		`item (`id (k), v[`label]:k))));

	list model_val = [];
	term modelsel = nil;
	term contents = `VBox (`HBox (`HWeight (1, manufsel),
	    `HWeight (1, `ReplacePoint (`id (`modelsel_rep), `HSpacing ()))),
	    `HBox (
		`HStretch (),
		// pushbutton
		`PushButton (`id (`useppd), _("Use non-YaST2 &ppd file")),
		`HStretch (),
		// Button which provides information about selected
		// manufacturer/model
		`PushButton (`id (`infobut), `opt (`key_F2), _("&Info")),
		`HStretch ()
	    ));
	// dialog box label
	Wizard::SetContentsButtons (_("Manufacturer and model of the printer"),
	    contents, getManufModelHelp (), BackButtonLabel (),
	    NextButtonLabel ());

	if (manuf_db == "" || manuf_db == nil)
	{
	    foreach (`k, `v, Printer::foomatic, ``{
		if (manuf_db == "" || manuf_db == nil)
		    manuf_db = k;
	    });
	}
	UI::ChangeWidget (`id (`manufsel), `CurrentItem, manuf_db);

	symbol ret = `manufsel;
	while (`abort != ret && `back != ret && ret != `next && ret != `useppd)
	{
	    if (ret == `infobut)
	    {
		if (model_db == "" || model_db == nil)
	        {
	            // popup
	            UI::MessagePopup (_("Select a printer model."));
		    UI::SetFocus (`id (`modelsel));
	        }
		else
		{
		    DisplayPrinterPopup (info, manuf_db, model_db);
		}
	    }
	    if (ret == `manufsel)
	    {
		y2debug ("Manuf: %1, W: %2", manuf_db,
		    UI::QueryWidget (`id (`manufsel), `CurrentItem));
		if (manuf_db
			!= UI::QueryWidget (`id (`manufsel), `CurrentItem))
		{
		    y2debug ("Setting manuf_db");
		    manuf_db = UI::QueryWidget (`id (`manufsel), `CurrentItem);
		    model_db = "";
		}
		modelsel = `SelectionBox (`id (`modelsel), `opt (`notify),
		    // selection box caption
		    _("Select &model:"),
		    {
			map modelsmap = mapmap (`kk, `vv,
			    filter (`k, `v, Printer::foomatic[manuf_db]:$[],
				``(is (k, string))),
			    ``([kk, vv[`label]:kk]));
			return sortitems (modelsmap);
		    });
		UI::ReplaceWidget (`id (`modelsel_rep), modelsel);
		if (model_db != "")
		    UI::ChangeWidget (`id (`modelsel), `CurrentItem, model_db);
		ret = `modelsel;
	    }
	    if (`modelsel == ret)
	    {
		model_db = UI::QueryWidget (`id (`modelsel), `CurrentItem);
		y2debug ("modelsel changed to %1", model_db);
		info = $[];
		integer type = Printer::foomatic[manuf_db,model_db, `support]:0;
		info_instead_next = ! (2 != type);
	    }
	    ret = UI::UserInput ();
	    if (`abort == ret || `cancel == ret)
            {
                ret = reallyAbort () ? `abort : `cont;
                if (ret == `abort) break;
            }
	    if (ret == `next && (model_db == "" || model_db == nil))
	    {
		// popup
		UI::MessagePopup (_("Select a printer model."));
		UI::SetFocus (`id (`modelsel));
		ret = nil;
	    }
	    else if (ret == `next && size (filter (`k, `v,
		Printer::foomatic[manuf_db, model_db]:$[],
		``(is (k, string)))) <= 0)
	    {
		UI::MessagePopup (_(
		    // message popup
		    "No PPD file available for selected model"));
		ret = nil;
	    }

	    if (ret == `next && info_instead_next)
		ret = `infobut;
	}

	if (ret == `next)
	{
	    string manuf_ieee = Printer::foomatic[manuf_db, `label]:manuf_db;
	    string model_ieee
		    = Printer::foomatic[manuf_db, model_db, `label]:model_db;;
	    Printer::printer = union (Printer::printer, $[
		    "vendor_db" : manuf_db,
		    "device_db" : model_db,
		    "vendor_ieee" : manuf_ieee,
		    "device_ieee" : model_ieee,
		    "database" : "foomatic",
		    "ownppd" : "",
		    "config" : "",
		    ]);
	}
	else if (ret == `back || ret == `abort)
	{
	    if (Printer::edit_seq)
	    {
	        if (tmp_printer_manuf_model != $[])
	        {
		    y2debug ("Setting printer back to %1", tmp_printer_manuf_model);
	            Printer::printer = eval (tmp_printer_manuf_model);
		    tmp_printer_manuf_model = $[];
	        }
	    }

	}
	y2milestone ("Returning %1, printer set to %2", ret, Printer::printer);
	return ret;
    }

    /**
     * Run dialog
     * @return symbol `back, `next, `abort
     */
    global define symbol runInstalledPrinterDialog () ``{
	y2milestone ("running installed printers dialog");
	list(map) printers = getConfiguredPrinters ();
	list items = [];

	integer counter = -1;
	list sel_items= maplist (`p, printers, ``{
	    counter = counter + 1;
	    if (p["ownppd"]:"" != "")
	    {
		string filename = lookup (p, "ownppd", "");
		if (filename != "" && Printer::isPpd (filename))
		{
		    map ppd = Printer::ppdInfo (filename);
		    filename = lookup (ppd, "manufacturer", "") + " : " + lookup (ppd, "model", "");
		}
		y2milestone ("Has own ppd, %1, printer is %2", filename, p);
		// selection box entry: <filename>, Parallel printer on /dev/lp0
		return `item (`id (counter), sformat (_("%1, %2"),
		    filename,
		    Printerlib::getUriNiceName (lookup (p, "uri", ""))));
	    }
		// eg. Epson Stylus Photo 810, Parallel printer on /dev/lp0
	    return `item (`id (counter), sformat (_("%1 %2, %3"),
		lookup (p, "vendor_ieee", ""), lookup (p, "device_ieee", ""),
		Printerlib::getUriNiceName (lookup (p, "uri", ""))));
	});

	term contents = `HBox (`HSpacing (2), `VBox (
	    `VSpacing (2),
		// selection box label
	    `SelectionBox (`id (`printers), `opt (`hstretch), _("&Select Printer:"), sel_items),
	    `VSpacing (2)
	), `HSpacing (2));

	// dialog box label
        Wizard::SetContentsButtons (_("Printers"), contents, getPrintersHelp (), BackButtonLabel (), NextButtonLabel ());
	UI::ChangeWidget (`id (`printers), `CurrentItem, 0);
	symbol ret = UI::UserInput ();
            if (ret == `cancel)
                ret = `abort;

	while (true)
	{
            if (`abort == ret || `cancel == ret)
            {
                ret = reallyAbort () ? `abort : `cont;
                if (ret == `abort) break;
            }
	    else if (`back == ret)
	    {
		break;
	    }
	    else if (`next == ret)
	    {
		integer ind = UI::QueryWidget (`id (`printers), `CurrentItem);
		Printer::printer = eval (printers[ind]:$[]);
		y2milestone ("Selected printer %1", Printer::printer);
		Printer::index = -1;
		Printer::printer["name"] = "";
		Printer::printer["options"] = $[];
		Printer::printer["config"] = "";
		break;
	    }
	    ret = UI::UserInput ();
            if (ret == `cancel)
                ret = `abort;
	}
	return ret;
    }

    /**
     * Dialog for choosing configuration.
     * @param ppd_only boolean true if shall not expand PPD files according
     *   to composite options
     * @return symbol for wizard sequencer
     */
    global define symbol runConfigDialog (boolean ppd_only) ``{
	y2milestone ("Running config dialog, ppd_only: %1", ppd_only);
	string manuf_db = lookup (Printer::printer, "vendor_db", "");
	string model_db = lookup (Printer::printer, "device_db", "");
	string config = lookup (Printer::printer, "config", "");
	map info = $[];
	list cfgs = [];
	map cfgsmap = $[];
	boolean foomatic = ((Printer::printer["vendor_db"]:"" != ""
		&& Printer::printer["device_db"]:"" != "")
	    || Printer::printer["ownppd"]:"" != "");
	y2milestone ("Configuring queue %1", Printer::printer);
	if (foomatic)
	{
	    loadFoomaticIfNeeded ();

	    map opts = Printer::printer["options"]:$[];
	    if (! ppd_only
		&& config != "" && Printer::printer["composite"]:"" != ""
		&& opts[Printer::printer["composite"]:""]:"" != "")
	    {
		config = sformat ("%1__\n__%2__\n__%3",
		    config,
		    Printer::printer["composite"]:"",
		    opts[Printer::printer["composite"]:""]:"");

	    }

	    list ppds = maplist (`k, `v, filter (`kk, `vv, Printer::foomatic[manuf_db, model_db]:$[], ``(is (kk, string))), ``(k));

	    if (Printer::printer["ownppd"]:"" != "")
	    {
		y2milestone ("proposing from custom PPD file");
		ppds = [`ownppd];
	    }
	    else
	    {
		ppds = sortPpds (manuf_db, model_db, ppds);
	    }

	    cfgs = [];
	    foreach (`k, ppds, ``{
		string ppdfile_orig = "";

		if (k == `ownppd && Printer::printer["ownppd"]:"" != "")
		    ppdfile_orig = Printer::printer["ownppd"]:"";
		else if (is (k, string))
		{
		    y2debug ("V: %1, M: %2, K: %3", manuf_db, model_db, k);
		    ppdfile_orig = Printer::foomatic[manuf_db, model_db, k, "filename"]:"";
		}

		if (ppdfile_orig == "")
		    return;

		if (k == `ownppd)
		{
		    cfgs = add (cfgs, `item (`id ("_____default_____"),
                            // selection box item
                            _("Default Configuration")));
		    cfgsmap["_____default_____"] = _("Default Configuration");
		}
		else if (is (k, symbol))
		{
		    return;
		}
		else
		{			// done inside agent
		    string label = k;//sformat ("%1 (%2)", k, ppdfile_orig);
		    cfgs = add (cfgs, `item (`id (k), label));
		    cfgsmap[k] = label;
		}

		if (ppd_only)
		{
		    return;
		}
		if (ppdfile_orig == "")
		{
		    return;
		}
		string ppdfile = SCR::Read (.ppd.file.open,
		    [ppdfile_orig, SCR::Read (.target.tmpdir)]);
		map options = SCR::Read (.ppd.file.options, [ppdfile, ""]);
		list opts = options["data"]:$[];
		integer ind = -1;
		boolean found = true;
		find (`i, opts, ``{
		    ind = ind + 1;
		    found = i["name"]:"" == "PrintoutMode";
		    return found;
		});
		map composite = $[];
		if (found)
		    composite = opts[ind]:$[];
		if (composite == $[])
		{
		    return;
		}

		string ppd_label_part = "";
		if (k != `ownppd)
		    ppd_label_part = k;
		else
		{
		    // selection box item
		    ppd_label_part = _("Custom PPD File");
		}
		if (regexpmatch (k, ".*, .*"))
		{
		    ppd_label_part = select (regexptokenize (k, ".*, (.*)"), 0, k);
		}

                foreach (`v, composite["valorder"]:[], ``{
                    string optname = composite["name"]:"";
		    string complabel = composite["values", v]:v;
		    cfgs = add (cfgs, `item (
			`id (sformat ("%1__\n__%2__\n__%3", k, optname, v)),
			sformat ("    %1", complabel)));
		    cfgsmap[sformat ("%1__\n__%2__\n__%3", k, optname, v)]
			= sformat ("%1", complabel);
                });

	    });
	    Printer::printer["database"] = "foomatic";
	}
	else
	{
	    y2error ("Not foomatic!!!");
	}
	term contents = `HBox (
	    `HSpacing (1),
	    `VBox (
		    `VSpacing (1),
		    // selection box label
		    `SelectionBox (`id (`selection), `opt (`hstretch), _("&Select configuration:"), foomatic ? cfgs : select (cfgs, 1, [])),
		    `VSpacing (1),
		    ppd_only ? `VSpacing (0) : `HBox (
			`HStretch (),
			// pushbutton
			`HWeight (1, `PushButton (`id (`test), `opt (`key_F6), _("&Test printing"))),
			// pushbutton
			-1 == Printer::index ? `HWeight (1, `PushButton (`id (`advanced), `opt (`key_F7), _("Ad&vanced settings"))) : `HSpacing (0),
			`HStretch ()
		    ),
		    `VSpacing (ppd_only ? 0 : 1)
		),
	    `HSpacing (1)
	);
	// dialog box label
	string caption = ppd_only ? _("PPD Files")
		// dialog box label
	    : _("Configurations");
	Wizard::SetContentsButtons (caption, contents, ppd_only ? getPpdSelectHelp () : getConfigHelp (), BackButtonLabel (), OKButtonLabel ());

	if (config != "" && config != nil)
	{
	    UI::ChangeWidget (`id (`selection), `CurrentItem, config);
	}
	if (foomatic && (config == "" || config == nil))
	{
            {
		term item = cfgs[0]:nil;
		if (nil != item)
		{
		    config = select (select (item, 0, nil), 0, "");
		}
            }
	    if (config != "" && config != nil)
	    {
		UI::ChangeWidget (`id (`selection), `CurrentItem, config);
	    }
	}

	any ret = `config;
	while (`abort != ret && ret != `back && ret != `next && `advanced != ret)
	{
	    if (`info == ret)
	    {
		// popup
		string i = lookup (info, "comment", _("<P>No information available.</P>"));
		// popup header
		UI::LongTextPopup (_("Configuration information"), `RichText (i), 50, 18);
	    }
	    if (`abort == ret)
	    {
		ret = reallyAbort () ? `abort : nil;
	    }
	    if (`test == ret)
	    {
		map tmpPrinter = Printer::printer;
		config = UI::QueryWidget (`id (`selection), `CurrentItem);
        // Why this? The new selected configuration cannot be tested
        // before saving:
		if (lookup (tmpPrinter, "config", "") != config)
		    tmpPrinter = add (tmpPrinter, "options", $[]);
		if (foomatic && regexpmatch (config, ".*__\n__.*__\n__.*"))
		{
	            list tokenized
	                = regexptokenize (config, "(.*)__\n__(.*)__\n__(.*)");
	            config = tokenized[0]:"";
	            string key = tokenized[1]:"";
	            string val = tokenized[2]:"";
		    tmpPrinter["composite"] = key;
	            map opts = Printer::printer["options"]:$[];
	            opts[key] = val;
	            tmpPrinter["options"] = opts;
		}
		else if (foomatic && regexpmatch (config, "SuSE___.*"))
		{
		    tmpPrinter["database"] = nil;
		    tmpPrinter["composite"] = "";
		    config = regexpsub (config, "SuSE___(.*)", "\\1");
		}
		else
		{
		    tmpPrinter["composite"] = "";
		}
		tmpPrinter = adjustPaperSize (tmpPrinter);
		tmpPrinter = add (tmpPrinter, "config", config);

		testPrinter (tmpPrinter, `ask);
	    }
	    ret = UI::UserInput ();
            if (ret == `cancel)
                ret = `abort;
	}
	if (ret == `advanced)
	{
	    config = UI::QueryWidget (`id (`selection), `CurrentItem);
	    if (lookup (Printer::printer, "config", "") != config)
		Printer::printer = add (Printer::printer, "options", $[]);
            if (foomatic && regexpmatch (config, ".*__\n__.*__\n__.*"))
            {
		list tokenized
		    = regexptokenize (config, "(.*)__\n__(.*)__\n__(.*)");
		config = tokenized[0]:"";
		string key = tokenized[1]:"";
		Printer::printer["composite"] = key;
		string val = tokenized[2]:"";
		map opts = Printer::printer["options"]:$[];
		opts[key] = val;
		Printer::printer["options"] = opts;
		Printer::printer = adjustPaperSize (Printer::printer);
            }
            else if (foomatic && regexpmatch (config, "SuSE___.*"))
            {
                Printer::printer["database"] = nil;
                Printer::printer["composite"] = "";
                config = regexpsub (config, "SuSE___(.*)", "\\1");
            }
	    else
	    {
		Printer::printer["composite"] = "";
	    }

	    Printer::printer = add (Printer::printer, "config", config);
	    return ret;
	}
	if (ret == `next || ret == `next_x)
	{
	    if (`next == ret)
		config = UI::QueryWidget (`id (`selection), `CurrentItem);
	    if (lookup (Printer::printer, "config", "") != config)
		Printer::printer = add (Printer::printer, "options", $[]);
	    string config_id = config;
            if (foomatic && regexpmatch (config, ".*__\n__.*__\n__.*"))
            {
	        list tokenized
		    = regexptokenize (config, "(.*)__\n__(.*)__\n__(.*)");
	        config = tokenized[0]:"";
	        string key = tokenized[1]:"";
		Printer::printer["composite"] = key;
	        string val = tokenized[2]:"";
	        map opts = Printer::printer["options"]:$[];
	        opts[key] = val;
	        Printer::printer["options"] = opts;
		Printer::printer = adjustPaperSize (Printer::printer);
            }
            else if (foomatic && regexpmatch (config, "SuSE___.*"))
            {
                Printer::printer["database"] = nil;
                Printer::printer["composite"] = "";
                config = regexpsub (config, "SuSE___(.*)", "\\1");
            }
	    else if (config == "___SuSEdb___")
	    {
		Printer::printer["database"] = nil;
		Printer::printer["composite"] = "";
		config = "";
	    }
            else
            {
                Printer::printer["composite"] = "";
            }
	    // add comment
	    Printer::printer["comment"] = cfgsmap[config_id]:config_id;

	    Printer::printer = add (Printer::printer, "config", config);
	    // FIXME: check if it is not necessary to clean options.
	    ret = `next;
	}
	return ret;
    }

    /**
     * Configuration of printer names.
     * @param allow_auto boolean true if should be allowed to omit printer name
     * @return symbol for wizard seq.
     */
    global define symbol runNameDialog (boolean allow_auto) ``{
	y2milestone ("Running name dialog for %1", Printer::printer);
	list forbidden_names = Printer::getForbiddenNames ();
	string name = Printer::printer["name"]:"";
	string old_name = name;
	string info = Printer::printer["info"]:"";
	string loc = Printer::printer["location"]:"";
	string uri = Printer::printer["uri"]:"";
	string uri_type = Printerlib::getUriType (uri);
	boolean raw = Printer::printer["raw"]:nil;
	if (raw == nil)
	{
	    if (uri_type == "lpd" || uri_type == "ipp")
		raw = true;
	    else
		raw = false;
	}
	boolean ff = Printer::printer["ff"]:false;
	boolean is_class = uri_type == "class";
	boolean auto_propose = Printer::printer["auto_propose"]:false;

	if (-1 != Printer::index)
	{
	    // remove me from forbidden names
	    forbidden_names = filter (`i, forbidden_names, ``(i != name));
	}

	if (is_class)
	{
	    if (Printer::printer["options"]:$[] == $[])
		Printer::printer["options"] = $["job-sheets": "none,none"];
	}

	term raw_insert = is_class
	    ? `VSpacing (0)
	    : `CheckBox (`id (`raw), `opt (`hstretch),
		// checkbox
		_("&Do local filtering"), ! raw);

	term ff_insert = "cups" == Printer::spooler ? `VSpacing (0) :
	    // check box
	    `CheckBox (`id (`ff), `opt (`hstretch),
		_("Print &formfeed between jobs"), ff);

	term aa_insert = allow_auto
	    ? `CheckBox (`id (`auto), `opt (`notify, `hstretch),
		_("Automatically &propose multiple queues"), auto_propose)
	    : `VSpacing (0);

	term contents = `VBox (
	    `TextEntry (`id (`name), `opt (`hstretch),
		// text entry
		_("Name for &printing:"), name),
	    `VSpacing (1),
	    `TextEntry (`id (`info), `opt (`hstretch), is_class
		// text entry
		? _("&Description of class")
		// text entry
		: _("&Description of Printer"), info),
	    `TextEntry (`id (`loc), `opt (`hstretch), is_class
		// text entry
		? _("&Location of class")
		// text entry
		: _("&Location of Printer"), loc),
	    `VSpacing (1),
	    raw_insert,
	    ff_insert,
	    `VSpacing (allow_auto ? 1 : 0),
	    aa_insert,
	    `VSpacing (1)
	);
	contents = `HBox (`HSpacing (4),
	    `VBox (
		// frame label
		`Frame (_("Queue name and spooler settings"), contents),
		`VSpacing (is_class ? 0 : 2),
		is_class
		    ? `VSpacing (0)
		    : `PushButton (`id (`test), `opt (`key_F6),
			// push button
			_("&Test printing"))
	    ), `HSpacing (4));

	// dialog box label
	Wizard::SetContentsButtons (
		// dialog caption
		is_class ? _("Class name") : _("Queue name"),
		contents,
		getSpoolInfoHelp (true),
		BackButtonLabel (),
		NextButtonLabel ()
		);
	UI::ChangeWidget (`id (`name), `ValidChars, "_0123456789abcdefghijklmnopqrstuvwxyz");

	if (name == "")
	{
	    if (is_class)
		name = generateClassName (forbidden_names);
	    else
		name = generateQueueName (nil, uri,
		    Printer::printer["vendor_ieee"]:"",
		    Printer::printer["device_ieee"]:"", forbidden_names);
	    UI::ChangeWidget (`id (`name), `Value, name);
	}

	any ret = nil;
	string fwd = "";
	repeat {
	    ret = UI::UserInput ();
            if (ret == `cancel)
                ret = `abort;
	    if (ret == `auto)
	    {
		auto_propose = UI::QueryWidget (`id (`auto), `Value);
		if (auto_propose)
		{
		    name = UI::QueryWidget (`id (`name), `Value);
		    info = UI::QueryWidget (`id (`info), `Value);
		    loc = UI::QueryWidget (`id (`loc), `Value);
                    UI::ChangeWidget (`id (`name), `Enabled, false);
                    UI::ChangeWidget (`id (`name), `Value, "");
                    UI::ChangeWidget (`id (`info), `Enabled, false);
                    UI::ChangeWidget (`id (`info), `Value, "");
                    UI::ChangeWidget (`id (`loc), `Enabled, false);
                    UI::ChangeWidget (`id (`loc), `Value, "");
                    if (! is_class)
                    {
			raw = ! UI::QueryWidget (`id (`raw), `Value);
                        UI::ChangeWidget (`id (`raw), `Enabled, false);
                        UI::ChangeWidget (`id (`raw), `Value, false);
                    }
                    if (Printer::spooler != "cups")
                    {
			ff = UI::QueryWidget (`id (`ff), `Value);
                        UI::ChangeWidget (`id (`ff), `Enabled, false);
                        UI::ChangeWidget (`id (`ff), `Value, false);
                    }
		}
		else
		{
		    UI::ChangeWidget (`id (`name), `Enabled, true);
		    UI::ChangeWidget (`id (`name), `Value, name);
		    UI::ChangeWidget (`id (`info), `Enabled, true);
		    UI::ChangeWidget (`id (`info), `Value, info);
		    UI::ChangeWidget (`id (`loc), `Enabled, true);
		    UI::ChangeWidget (`id (`loc), `Value, loc);
		    if (! is_class)
		    {
			UI::ChangeWidget (`id (`raw), `Enabled, true);
			UI::ChangeWidget (`id (`raw), `Value, ! raw);
		    }
		    if (Printer::spooler != "cups")
		    {
			UI::ChangeWidget (`id (`ff), `Enabled, true);
			UI::ChangeWidget (`id (`ff), `Value, ff);
		    }
		}
	    }
	    else if (ret == `test)
	    {
		raw = ! UI::QueryWidget (`id (`raw), `Value);
		if (! raw)
		{
		    Report::Error (_("Only not filtering queues can
be tested here."));
		}
		else
		{
		    map p = Printer::printer;
		    if (Printer::spooler != "cups")
			p["ff"] = UI::QueryWidget (`id (`ff), `Value);
		    p["name"] = tolower (UI::QueryWidget (`id (`name), `Value));
		    p["raw"] = true;
		    testPrinter (p, `ask);
		}
		ret = nil;
	    }
	    else if (ret == `next)
	    {
		if (! is_class)
		    raw = ! UI::QueryWidget (`id (`raw), `Value);
		if (Printer::spooler != "cups")
		    ff = UI::QueryWidget (`id (`ff), `Value);
		name = tolower (UI::QueryWidget (`id (`name), `Value));
		info = UI::QueryWidget (`id (`info), `Value);
		loc = UI::QueryWidget (`id (`loc), `Value);
		if (allow_auto)
		    auto_propose = UI::QueryWidget (`id (`auto), `Value);
		if (auto_propose || (checkName (forbidden_names, name)
					&& checkLocalQueueName (name)))
		{
		    break;
		}
		ret = nil;
	    }
	    if (`abort == ret || `cancel == ret)
	    {
		ret = reallyAbort () ? `abort : nil;
	    }
	} until (`abort == ret || ret == `back || ret == `next);

	if (ret == `next)
	{
	    Printer::printer["name"] = name;
	    Printer::printer["raw"] = raw;
	    Printer::printer["ff"] = ff;
	    Printer::printer["info"] = info;
	    Printer::printer["location"] = loc;
	    Printer::printer["auto_propose"] = auto_propose;
	    if (raw)
	    {
		ret = `raw;
	    }
	    if (is_class)
		ret = `class;

	    if (old_name != "" && old_name != name)
	    {
		Printer::addToDeleted (
		    old_name, is_class ? "class" : "printer");
	    }
	}
	y2milestone ("Returning %1, printer set to %2", ret, Printer::printer);
	return ret;
    }
    /**
     * Choose one printer from list of printers
     * @return string selected printer
     */
    global define string choosePrinterOrClass () ``{
	list onlyprinters = filter (`e, Printer::printcap, ``(lookup (e, "uri", "class") != "class"));
        list printers =
            flatten ([
		toset (
		    maplist (`i, filter (
			`e, Printer::printcap, ``(
			    lookup (e, "uri", "class") != "class"
			)
		    ), ``{
			return lookup (i, "name", "");
                    })
		)
            ]);

        UI::OpenDialog (
                `HBox (
                    `HSpacing (0.7),
                    `VSpacing (16),
                    `VBox (
                        `VSpacing (0.5),
                        `HSpacing (16),
                        // selection box label
                        `SelectionBox ( `id (`printers), _("Choose &printer:"), maplist (`i, printers, ``{return `item (`id(i),i);})),
                        `HBox (
                            `PushButton (`id (`ok), `opt (`key_F10), OKButtonLabel ()),
                            `PushButton (`id (`cancel), `opt (`key_F9), CancelButtonLabel ())
                            ),
                        `VSpacing (0.3)
                        ),
                    `HSpacing (0.7)
                    )
                );

        string member = "";
        symbol ret = nil;
        while (true)
            {
                ret = UI::UserInput ();
                if (`ok == ret)
                    {
                        member = UI::QueryWidget (`id (`printers), `CurrentItem);
                        break;
                    }
                else if (`cancel == ret)
                    {
                        break;
                    }
            }
        UI::CloseDialog ();
        return member;
    }
    /**
     * Members of class
     * @return symbol `next or `back
     */
    global define symbol runMembersDialog () ``{
        list printers = toset (lookup (Printer::printer, "printers", []));
        term contents =
            `VBox (
                `ReplacePoint (
                    `id (`replace_members),
                    `SelectionBox(
                        `id (`printers),
                        // selection box label
                        _("&Following printers and classes are members of this class"),
                        maplist (`i, printers, ``{
                            return `item (`id (i), i);
                        })
                        )
                    ),
                `HBox(
                    `PushButton(`id(`add), `opt (`key_F3), AddButtonLabel ()),
                    `PushButton(`id(`delete), `opt (`key_F5), DeleteButtonLabel ())
                    )
                );
        // dialog label
        Wizard::SetContentsButtons (_("Members of class"), contents, getMembersHelp (), BackButtonLabel (), NextButtonLabel ());

        symbol ret = nil;
        while (true)
        {
            ret = UI::UserInput ();
            if (ret == `cancel)
                ret = `abort;
            if (`delete == ret)
                {
                    string member_to_delete = UI::QueryWidget (`id (`printers), `CurrentItem);
                    if (nil != member_to_delete)
                        {
                            printers = DeleteItem (printers, member_to_delete);
                            UI::ReplaceWidget (
                                `id (`replace_members),
                                `SelectionBox(
                                    `id (`printers),
                                    // selection box label
                                    _("&Following printers and classes are members of this class"),
                                    maplist (`i, printers, ``{
                                        return `item (`id (i), i);
                                    })));
                        }
                    else
                        {
                            // message box
                            UI::MessagePopup (_("Select printer to delete."));
                        }
                }
            else if (`add == ret)
                {
                    string member_to_add = choosePrinterOrClass ();
		    if (member_to_add != "")
		    {
			printers = toset (add (printers, member_to_add));
			UI::ReplaceWidget (
			    `id (`replace_members),
			    `SelectionBox(
				`id (`printers),
				// selection box label
				_("&Following printers and classes are members of this class"),
				maplist (`i, printers, ``{
				    return `item (`id (i), i);
				})));
		    }
                }
            else if (`next == ret)
                {
                    if (0 != size (printers))
                        {
                            Printer::printer = add (Printer::printer, "printers", printers);
                            break;
                        }
                    else
                        {
                            // message box
                            UI::MessagePopup (_("Class must contain at least one printer."));
                        }
                }
            else if (`back == ret)
                {
                    break;
                }
            else if (`abort == ret)
                {
                    if (reallyAbort ())
                        {
                            break;
                        }
                }
        }
        return ret;
    }




    /**
     * Configuration of the filter. It is quite complicated because there can
     * be depended options so change of value (lower list) can change content
     * of options (upper list).
     * @return symbol for ws
     */
    global define symbol runOptionsDialog () ``{
	boolean foomatic = Printer::printer["database"]:"" == "foomatic";
        if (foomatic)
            loadFoomaticIfNeeded ();
	foomatic = foomatic || Printer::printer["ownppd"]:"" != "";
	string filename = "";
	if (foomatic)
	{
	    string orig_name = Printer::foomatic[Printer::printer["vendor_db"]:"", Printer::printer["device_db"]:"", Printer::printer["config"]:"", "filename"]:"";
	    if (Printer::printer["ownppd"]:"" != "")
		orig_name = Printer::printer["ownppd"]:"";
	    if (orig_name == "")
	    {
		// error report
		Report::Error (_("Unknown PPD file. Select printer model."));
		return `back;
	    }
	    filename = SCR::Read (.ppd.file.open,
		[orig_name, SCR::Read (.target.tmpdir)]);
	    if (filename == "")
	    {
		Report::Error (sformat (
			// error report
		    _("Error occurred while opening PPD file
%1
"),
		    orig_name));
		return `back;
	    }
	}

	Printer::printer = add (Printer::printer, "newer_gs_upp", false);
	map saved = lookup (Printer::printer, "saved", $[]);
	saved = add (saved, "upp_fname", "");
	saved = add (saved, "upp", "");
	Printer::printer = add (Printer::printer, "saved", saved);
	string config = lookup (Printer::printer, "config", "");
	any vals = nil;

	term test_button =`HWeight (1, `PushButton (`id (`test), `opt (`key_F6),
		// pushbutton
		_("&Test")));

	// dialog caption
	Wizard::SetContentsButtons (_("Configuration options"), `VBox (
		`VWeight (1, `ReplacePoint (`id (`upper), `VSpacing (1))),
		`VWeight (1, `ReplacePoint (`id (`lower), `VSpacing (1))),
		`HBox (`HStretch (), test_button, `HStretch ())
		), getFilterHelp (), BackButtonLabel (), NextButtonLabel ());

	map selected = lookup (Printer::printer, "options", $[]);

	list opts = [];
	list optlist = []; // used only for foomatic;
        if (foomatic)
        {
            map options = SCR::Read (.ppd.file.options, [filename, ""]);
            optlist = options["data"]:[];
	    y2debug ("First option: %1", optlist[0]:$[]);
	    optlist = filter (`o, optlist, ``(
		o["name"]:"" != "PageRegion"
		&& o["name"]:"" != "ImageableArea"
		&& o["mame"]:"" != "PaperDimension"));
	    optlist = add (optlist, $[
		"current" : "3",
			// list item
		"gui" : _("Orientation"),
		"name" : "orientation-requested",
		"type" : "PickOne",
		"valorder" : ["3", "4", "5", "6"],
				// list item
		"values" : $["3" : _("Portrait"),
				// list item
			"4" : _("Landscape"),
				// list item
			"5" : _("Reverse"),
				// list item
			"6" : _("Reverse portrait"),
		],
	    ]);
	    optlist = add (optlist, $[
		"current" : "1",
			// list item
		"gui" : _("Pages per sheet"),
		"name" : "number-up",
		"type" : "pick_one",
		"valorder" : ["1", "2", "4"],
		"values" : $[
			"1" : "1",
			"2" : "2",
			"4" : "4",
		],
	    ]);
            opts = maplist (`i, optlist, ``(
                `item (`id (i["name"]:""), i["gui"]:"")
            ));
	}

	symbol ret = `opts;
	// selection box label
	UI::ReplaceWidget (`id (`upper), `SelectionBox (`id (`opts), `opt (`notify), _("&Options"), opts));

	    UI::ChangeWidget (`id (`opts), `CurrentItem,
		lookup (select (lookup (SCR::Read (.ppd.file.options,
			 [filename, ""]),
		    "data", []), 0, $[]), "name", ""));

	while (`next != ret && `back != ret && `abort != ret)
	{
	    if (`test == ret)
	    {
		Printer::printer = add (Printer::printer, "options", selected);

		testPrinter (Printer::printer, `ask);
	    }
	    if (`opts == ret)
	    {
		    string option = UI::QueryWidget (`id (`opts), `CurrentItem);
		    string ppd_default = "";
		    foreach (`i, optlist, ``{
			if (i["name"]:"" == option)
			{
			    vals = maplist (`k, i["valorder"]:$[], ``(
				`item (`id (k), i["values", k]:k)
			    ));
			    ppd_default = i["current"]:"";
			    if (ppd_default == "")
				ppd_default = i["valorder", 0]:"";
			}
		    });
		    UI::ReplaceWidget (`id (`lower), getValuesUI (vals));
		    // FIXME type of option
		    {
			string current = selected[option]:"";
			if (current == "")
			    current = ppd_default;
			UI::ChangeWidget (`id (`vals), `CurrentItem, current);
		    }
	    }
	    else if (`vals == ret || `vals2 == ret)
	    {
		string o = UI::QueryWidget (`id (`opts), `CurrentItem);
		string v = UI::QueryWidget (`id (`vals), `CurrentItem);
	    }
	    ret = UI::UserInput ();
            if (ret == `cancel)
                ret = `abort;
	}
	if (`next == ret)
	{
	    string ps = selected["PageSize"]:nil;
	    if (ps != nil)
	    {
		selected["PageRegion"] = ps;
		selected["ImageableArea"] = ps;
		selected["PaperDimension"] = ps;
	    }
	    map saved = lookup (Printer::printer, "saved", $[]);
	    saved = add (saved, "upp_fname", "");
	    saved = add (saved, "upp", "");
	    Printer::printer = add (Printer::printer, "options", selected);
	    Printer::printer = add (Printer::printer, "saved", saved);
	    if (Printer::spooler == "cups")
		ret = `next_cups;
	}
	return ret;
    }

    global define symbol runConnectionTypeDialog () ``{
	symbol selected = nil;// FIXME
	boolean add_queue = true;// FIXME
	term items = `VBox (
	    `Left (`RadioButton (`id (`local),
		// radio button
		_("Print on a local &printer"),
		selected == `local)),
	    `Left (`RadioButton (`id (`cups),
		// radio button
		_("Print via C&UPS network server"),
		selected == `cups)),
	    `Left (`RadioButton (`id (`lpd),
		// radio button
		_("Print via &LPD-style network server"),
		selected == `lpd)),
	    `Left (`RadioButton (`id (`smb),
		// radio button
		_("Print via &SMB network server"),
		selected == `smb)),
	    `Left (`RadioButton (`id (`ipx),
		// radio button
		_("Print via &IPX network server"),
		selected == `ipx)),
	    `Left (`RadioButton (`id (`tcp),
		// radio button
		_("Print &directly on a network printer"),
		selected == `direct))
	);
	if (add_queue)
	    items = add (items, `Left (`RadioButton (`id (`queue),
		// radio button
		_("Create a new &queue to  an existint printer"),
		selected == `queue)));
	items = add (items, `Left (`RadioButton (`id (`other),
		// radio button
		_("&Other kind of setup"),
		selected == `other)));
	return runGenericConnectionTypeDialog (items,
	    getConnectionTypeHelp (add_queue), `connection_type);
    }

    global define symbol runGenericConnectionTypeDialog (term items,
	string help, symbol what)
     ``{

	term contents = `VBox (
	    `VSpacing (2),
	    `HBox (
		`HSpacing (5),
		`Frame (
		    // label of the frame
		    _("Select your printer type:"),
		    `VBox (
			`RadioButtonGroup (`id (`connection_type), items),
			`VSpacing (1)
		    )
		),
		`HSpacing (5)
	    ), `VSpacing (2)
	);
	// dialog caption
	Wizard::SetContentsButtons (_("Printer Type"), contents,
	    help, BackButtonLabel (), NextButtonLabel ());
	symbol ret = nil;

	while (ret == nil)
	{
	    ret = UI::UserInput ();
	    if (ret == `next)
	    {
		ret = UI::QueryWidget (`id (`connection_type), `CurrentButton);
		if (ret == nil)
		{
		    UI::MessagePopup (_("Select printer type"));
		}
	    }
	}
	return ret;
    }

    /**
     * Choose one of remote printer (fwd queues).
     * @return symbol for ws
     */
    global define symbol runConnectionDialog () ``{
	y2milestone ("Connection dialog, confmode: %1", Printer::confmode);
	boolean show_all = -1 == Printer::index || lookup (Printer::printer, "type", "yast2") != "yast2";
	string uritype = Printer::getUriType ();
	if ("" == uritype)
	    uritype = "parallel";
	term contents =
	    `VBox (
		`HBox (
		    `HSpacing (5),
		    `Frame (
			// label of the frame
			_("Select the printer type:"),
			`VBox (
			    `RadioButtonGroup (`id (`connections), connectionsRadioButtons (uritype, show_all, Printer::confmode == `adm)),
			    `VSpacing (1))
			),
		    `HSpacing (5)),
		`VSpacing (2));

	boolean new_queue = false;
	if (size (getConfiguredPrinters ()) != 0 && Printer::confmode == `adm)
	    new_queue = true;
	//label of the dialog
	Wizard::SetContentsButtons (_("Connection for printer:"), contents, show_all ? getConnectionHelp (new_queue) : getLocalConnectionHelp (), BackButtonLabel (), NextButtonLabel ());
	Wizard::RestoreBackButton ();
	symbol ret = nil;
	symbol type = nil;

	repeat {
	    ret = UI::UserInput ();
            if (ret == `cancel)
                ret = `abort;
	    type = UI::QueryWidget (`id (`connections), `CurrentButton);
	    if (`abort == ret || `cancel == ret)
		{
		    ret = reallyAbort () ? `abort : nil;
		}
	} until (`abort == ret || ret == `back || (type != nil && ret == `next));

	if (`next == ret)
	{
	    ret = type;
	    Printer::printer = add (Printer::printer, "type", "yast2");
	    if (type == `class)
		Printer::printer = add (Printer::printer, "uri", "class");
	}
	return ret;
    }

    /**
     * Choose one of remote printer (fwd queues).
     * @return symbol for ws
     */
    global define symbol runAdvancedConnectionDialog () ``{
        string uritype = Printer::getUriType ();
        if ("" == uritype)
            uritype = "parallel";
        term contents =
            `VBox (
                `HBox (
                    `HSpacing (5),
                    `Frame (
                        // label of the frame
                        _("Select the printer type:"),
                        `VBox (
                            `RadioButtonGroup (`id (`connections), advancedConnectionsRadioButtons (uritype, Arch::s390 && Printer::confmode == `adm)),
                            `VSpacing (1))
                        ),
                    `HSpacing (5)),
                `VSpacing (2));

	symbol helptype = `all;
	if (Printer::spooler == "cups")
	    helptype = `cups;
	if (Printer::spooler == "lprng")
	    helptype = `lprng;
        boolean new_queue = false;
        if (size (getConfiguredPrinters ()) != 0 && Printer::confmode == `adm && Arch::s390)
            new_queue = true;

	//label of the dialog
        Wizard::SetContentsButtons (_("Connection for printer:"), contents, getAdvancedConnectionHelp (helptype, new_queue), BackButtonLabel (), NextButtonLabel ());
        symbol ret = nil;
        symbol type = nil;

        repeat {
            ret = UI::UserInput ();
            if (ret == `cancel)
                ret = `abort;
            type = UI::QueryWidget (`id (`connections), `CurrentButton);
            if (`abort == ret || `cancel == ret)
                {
                    ret = reallyAbort () ? `abort : nil;
                }
        } until (`abort == ret || ret == `back || (type != nil && ret == `next));

        if (`next == ret)
        {
            ret = type;
            Printer::printer = add (Printer::printer, "type", "yast2");
            if (type == `class)
                Printer::printer = add (Printer::printer, "uri", "class");
        }
        return ret;
    }


    /**
     * Create contents for edit dialog. Calls Setwizardcontents at the end.
     */
    global define void createEditDialog () ``{
	string help_text = "";
	// determine printer type ...
	//
	string uri = lookup (Printer::printer, "uri", "");
	string uri_type = Printerlib::getUriType (uri);
	boolean conf_type = lookup (Printer::printer, "type", "yast2") == "yast2";
	boolean know = conf_type || lookup (Printer::printer, "type", "yast2") == "non-yast-now";
	boolean raw = lookup (Printer::printer, "raw", false);
	boolean foomatic = Printer::printer["database"]:"" == "foomatic";
	string model = lookup (Printer::printer, "device", "");

	//
	// texts
	//
	string model_text = sformat ("%1 %2", Printer::printer["vendor_ieee"]:"",
		Printer::printer["device_ieee"]:"");
	string config_text = "";
	    config_text = Printer::printer["config"]:"";
	    if (Printer::printer["composite"]:"" != "")
	    {
		string composite = Printer::printer["composite"]:"";
		if (composite != "")
		{
		    config_text = Printer::printer["comment"]:"";
		}
	    }
	string name_text = lookup (Printer::printer, "name", "");
	string connection_text = "";
	list items = [];
	string rich = "";

	// table entry
	items = add (items, `item (`id (`name), _("Name and basic settings"), lookup (Printer::printer, "name", "")));
	if ("class" != uri_type)
	{
            if (! lookup (Printer::printer, "raw", false))
            {
                if (lookup (Printer::printer, "ownppd", "") != "")
                {
                    string filename = lookup (Printer::printer, "ownppd", "");
                    if (filename != "" && Printer::isPpd (filename))
                    {
                        map ppd = Printer::ppdInfo (filename);
                        filename = lookup (ppd, "manufacturer", "") + " : " + lookup (ppd, "model", "");
                    }
                    else
                    {
                        filename = "";
                    }
			// table entry
                    items = add (items, `item (`id (`ppd), _("PPD file"), know ? filename : _("unknown")));

                }
                else
                {
			// table entry
                    items = add (items, `item (`id (`model), _("Printer model"), know ? model_text : _("unknown")));
			// table entry
                    items = add (items, `item (`id (`config), _("Printer configuration"), config_text));
                }
            }
		// table entry
	    items = add (items, `item (`id (`connection), _("Connection"), know ? Printerlib::getUriNiceName (uri) : _("unknown")));
	}
	if ("class" == uri_type)
	{
	// table entry
	    items = add (items, `item (`id (`class_members), _("Class members"), ""));
	// table entry
	    items = add (items, `item (`id (`perm), _("Restrictions settings"), ""));
	// table entry
	    items = add (items, `item (`id (`state), _("State and banners settings"), ""));
	}
	else
	{
	    if (! lookup (Printer::printer, "raw", false))
	    {
	// table entry
		items = add (items, `item (`id (`settings), _("Printing filter settings"), ""));
		if (Printer::spooler != "cups")
		{
	// table entry
		    items = add (items, `item (`id (`ascii), _("ASCII printing settings"), ""));
		}
		if (Printer::spooler != "lprng")
		{
	// table entry
		    items = add (items, `item (`id (`perm), _("Restrictions settings"), ""));
	// table entry
		    items = add (items, `item (`id (`state), _("State and banners settings"), ""));
		}
	    }
	}

	term contents = `VBox (
	    `VSpacing (1),
	    `HBox (
		`HSpacing (1),
		`VBox (
			// check box
		    `Left (`CheckBox (`id (`yast), `opt (`notify), _("&Allow editing of this queue"), conf_type)),
		    `VSpacing (1),
			// table header
		    `Table (`id (`options), `opt(`keepSorting, `notify), `header ( _("Option area"),
			// table header
			 _("Current values")), items),
		    `HBox (
			// push button
			`PushButton (`id (`edit), `opt (`key_F4), EditButtonLabel ()),
			`HStretch (),
			// push button
			"class" == uri_type ? `HSpacing (0.1) : `PushButton (`id (`test), `opt (`key_F6), _("&Test"))
		    )
		),
		`HSpacing (1)
	    ),
	    `VSpacing (1)
	);

	// dialog caption
	Wizard::SetContentsButtons (_("Edit configuration"), contents, getEditHelp (uri_type, raw, lookup (Printer::printer, "ownppd", "") != ""),
	    BackButtonLabel (), OKButtonLabel ());
	Wizard::RestoreBackButton ();
    }

    /**
     * Complex edit dialog for printer...
     * @return symbol for wizard seq.
     */
    global define symbol runEditDialog () ``{
	Printer::edit_seq = true;
	tmp_printer_manuf_model = $[];
	any ret = nil;
	createEditDialog ();
	if (lookup (Printer::printer, "type", "yast2") == "yast2")
	{
	    UI::ChangeWidget (`id (`test), `Enabled, true);
	    UI::ChangeWidget (`id (`edit), `Enabled, true);
	}
	else
	{
	    UI::ChangeWidget (`id (`test), `Enabled, false);
	    UI::ChangeWidget (`id (`edit), `Enabled, false);
	}

	while (nil == ret)
	    {
		ret = UI::UserInput ();
		if (ret == `options)
		{
		    ret = `edit;
		}
		if (`edit == ret)
		{
		    ret = UI::QueryWidget (`id (`options), `CurrentItem);
		}
		if (`test == ret)
		{
		    ret = nil;
		    testPrinter (Printer::printer, `ask);
		}
		else if (`abort == ret || `cancel == ret)
		{
		    ret = reallyAbort () ? `abort : nil;
		}
		else if (`yast == ret)
		{
		    boolean state = UI::QueryWidget (`id (`yast), `Value);
		    if (! state)
		    {
			// popup
			if (UI::YesNoPopup (_("If you forbid editing this queue,\nyou will not be able to change its settings\nusing YaST2. Continue?")))
			{
			    Printer::printer = add (Printer::printer, "type", "non-yast-now");
			    ret = `update;
			}
			else
			{
			    UI::ChangeWidget (`id (`yast), `Value, true);
			    ret = nil;
			}
		    }
		    else if (lookup (Printer::printer, "type", "yast2") == "non-yast-now"
			|| lookup (Printer::printer, "type", "yast2") == "yast2")
		    {
			Printer::printer = add (Printer::printer, "type", "yast2");
			ret = `update;
		    }
		    else
		    {
			// popup
			if (UI::YesNoPopup (_("The selected queue was not configured 
using YaST2. Do you want to add a printer 
with a prefilled name?
")))
			    ret = `add;
			else
			    ret = nil;
		    }
		}
		else if (`connection == ret)
		{
		    string uri = lookup (Printer::printer, "uri", "");
		    string uri_type = Printerlib::getUriType (uri);
		    ret = lookup ($["samba": `con_samba, "novell": `con_novell, "lpd": `con_lpd,
			"ipp": `con_ipp, "socket": `con_socket, "pipe" : `con_pipe ], uri_type, `connection);
		}
		else if (`perm == ret)
                {
                    break;
                }
		else if (`state == ret)
                {
		    break;
                }
		else if (`ascii == ret)
		{
		    break;
		}
		else if (`config == ret)
		{
		    break;
		}
		else if (`ppd == ret)
		{
		    break;
		}
		if (`update == ret)
		{
		    if (lookup (Printer::printer, "type", "yast2") == "yast2")
		    {
			UI::ChangeWidget (`id (`test), `Enabled, true);
			UI::ChangeWidget (`id (`edit), `Enabled, true);
		    }
		    else
		    {
			UI::ChangeWidget (`id (`test), `Enabled, false);
			UI::ChangeWidget (`id (`edit), `Enabled, false);
		    }
		    ret = nil;
		}
	    }
	if (ret == `back || ret == `next || ret == `abort)
	    Printer::edit_seq = false;
	return ret;
    }

    /**
      * Start dialog with advanced spooler settings
      * @return symbol for wizzard seq
      */
    global define symbol runAdvancedDialog () ``{
	string new_spooler = Printer::spooler;
	if (new_spooler == "cups"
	    && Printer::cupsInstallationType () == `client)
	{
	    new_spooler = "cups-client";
	}

	term contents = `VBox (
	    `VSpacing (1),
	    `HBox (
		`HSpacing (1),
		`VBox (
		    `VStretch (),
		    `HBox (
			`HStretch (),
			// frame
			`Frame (_("Spooler"),
			    getSpoolerItems (new_spooler, false)
		        ),
			`HStretch ()
		    ),
		    `VStretch (),
		    // checkbox
		    `CheckBox (`id (`save), _("&Force saving everything"),
			Printer::save_all),
		    `VStretch (),
		    `HBox (`HWeight (999, `HStretch ()), `VBox (
			// pushbutton
			`PushButton (`id (`reinstall), `opt (`hstretch),
			    _("Re&install printing packages")),
			`VStretch (),
			// pushbutton
			`PushButton (`id (`scratch), `opt (`hstretch),
				_("Cl&ear current configuration")),
			Printer::spooler == "cups" && `server == Printer::cupsInstallationType () ? `VStretch () :`VSpacing (0),
			// pushbutton
			Printer::spooler == "cups" && `server == Printer::cupsInstallationType () ? `PushButton (`id (`cupsd), `opt (`hstretch), _("CUPS server se&ttings")) : `VSpacing (0),
			Printer::spooler == "cups" && `server == Printer::cupsInstallationType () ? `VStretch () :`VSpacing (0),
			// pushbutton
			Printer::spooler == "cups" && `server == Printer::cupsInstallationType () ? `PushButton (`id (`cupsusb), `opt (`hstretch), _("CUPS &USB Device Settings")) : `VSpacing (0),
			`VStretch ()
		    ), `HWeight (999, `HStretch ()))
		),
		`HSpacing (1)
	    ),
	    `VSpacing (1)
	);

	// dialog caption
        Wizard::SetContentsButtons (_("Edit configuration"), contents,
	    getAdvancedHelp (Printer::spooler == "cups"
		&& `server == Printer::cupsInstallationType ()),
	    BackButtonLabel (), AcceptButtonLabel ());
	Wizard::RestoreBackButton ();
	symbol ret = nil;
	while (nil == ret)
	{
	    ret = UI::UserInput ();
            if (ret == `cancel)
                ret = `abort;
	    if (ret == `scratch || ret == `reinstall || ret == `cupsusb
		|| ret == `cupsd)
	    {
		if (Mode::config)
	        {
	            DisplayUnavailableAIPopup ();
	            ret = nil;
	        }
	    }
	    if (`scratch == ret)
	    {
		// popup
		if (! UI::AnyQuestionPopup (WarningMsg(),
		    _("Really discard your configuration?"),
		    YesButtonLabel(), NoButtonLabel (), `focus_no))
		{
		    ret = nil;
		    continue;
		}
		Printer::Reset ();
		ret = `next;
		break;
	    }
	    else if (`reinstall == ret)
	    {
		if (Mode::cont)
		{
		    DisplayUnavailableAIPopup ();
		    continue;
		}
		// popup
		if (! UI::AnyQuestionPopup(WarningMsg(),
		    _("Really reinstall your printing system? 
All your changes will be lost.
"),
		    // pushbutton
		    _("&Reinstall"), CancelButtonLabel (), `focus_no))
		{
		    ret = nil;
		    continue;
		}
		boolean success = reinstallAll ();
		break;
	    }
	    else if (`cups_server == ret
		|| `cups_client == ret || `lprng == ret)
	    {
		symbol spooler = UI::QueryWidget (`id (`spooler), `CurrentButton);
		string spoolerstring = spooler == `lprng ? "lprng" : (spooler == `cups_client ? "cups-client" : "cups");
	    }
	    else if (`back == ret)
		break;
	    else if (`next == ret)
		break;
	    else if (`abort == ret)
	    {
		if (reallyAbort ())
		    break;
	    }
	    else if (`cupsd == ret)
		break;
	    else if (`cupsusb == ret)
	    {
		break;
	    }
	    ret = nil;

	}
	if (`next == ret)
	{
	    Printer::save_all = UI::QueryWidget (`id (`save), `Value);
	    symbol spooler = UI::QueryWidget (`id (`spooler), `CurrentButton);
	    if (`cups_server == spooler)
	    {
                Printer::server_hostname = "";
                if (Printerlib::getSpoolSystem () != 2)
                {
                    Printer::saveClientHostName ();
                    ret = `switch;
                    Printer::cups_installation = -1;
		    restartSpoolerIfNeeded (true);
                }
                if (Printer::read_done == false)
                {
                    if (!Printer::Read ())
                    {
                        // message box
                        UI::MessagePopup (_("ERROR: Unable to read
the current configuration.
"));
                    }
                }
		Printer::cups_installation = `server;
		Printer::saveClientHostName ();
		restartSpoolerIfNeeded (true);
		ret = `cups;
		new_spooler = "cups";
	    }
	    else if (`cups_client == spooler)
	    {
		 Printer::cups_installation = `client;
		 ret = `cups;
		 new_spooler = "cups";
	    }
	    else if (`lprng == spooler)
	    {
		new_spooler = "lprng";
	    }
	    else
	    {
		new_spooler = Printer::spooler;
	    }
	    if (Printer::spooler != new_spooler)
	    {
		Printer::save_all = true;
		Printer::reread = false;
		Printerlib::switchTo (new_spooler);
		return `switch;
	    }
	}
	return ret;
    }

    /**
      * Dialog for choosing what kind of devices to use
      * @return wizard sequencer symbol
      */
    global define symbol runCupsUsbDeviceTypeDialog () ``{
        term contents = `HBox (`HStretch (), `VBox (
            `VStretch (),
            `RadioButtonGroup (`id (`devtype),
			// frame
                `Frame (_("Use CUPS-Like USB Device Names"),`HBox (
                    `HSpacing (3),
                    `VBox (
                        `VSpacing (3),
				// radiobutton
                        `Left (`RadioButton (`id (`always), _("&Always"))),
                        `Left (`RadioButton (`id (`serial),
				// radiobutton
                            _("If &Serial Number is Known"))),
			// radiobutton
                        `Left (`RadioButton (`id (`never), _("&Never"))),
                        `VSpacing (3)
                    ),
                    `HSpacing (3)
                )
            )),
            `VStretch ()
        ), `HStretch ());
	// dialog caption
	Wizard::SetContentsButtons (_("CUPS USB Device Name Type"), contents,
	    getCupsUsbDeviceTypeHelp (), BackButtonLabel (), OKButtonLabel ());

	UI::ChangeWidget (`id (`devtype), `CurrentButton,
	    Printer::cups_usb_dev_names);
	ret = nil;
	while (ret == nil)
	{
	    ret = UI::UserInput ();
            if (ret == `cancel)
                ret = `abort;
	    if (ret == `abort)
	    {
		if (! reallyAbort ())
		    ret = nil;
	    }
	    else if (ret == `next)
	    {
		Printer::cups_usb_dev_names
		    = UI::QueryWidget (`id (`devtype), `CurrentButton);
	    }
	}
	return ret;
    }

    /**
      * Decide how to configure autodetected printer
      * @retrun symbol for ws
      */
    global define symbol detectConfigType () ``{
	symbol ret = nil;
	// new queue to existing printer
	if (runAutoprobedListDialog__current == -2)
	{
	    y2milestone ("Configuring queue for isntalled printer");
	    return `installed_printer;
	}
	// not detected printer
	else if (runAutoprobedListDialog__current == -1)
	{
	    y2milestone ("Other undetected printer chosen");
	    ret = `connection;
	}
	// improperly set device/uri
	else if ((Printer::printer["bus"]:"" == ""
		|| Printer::printer["dev_name"]:"" == "")
	    && (Printer::printer["uri"]:"" == ""
		|| Printer::printer["uri"]:"" == "parallel:"))
        {
	    y2milestone ("Printer device not known");
            ret = `connection;
        }
	// unsupported spooler
	else if (Printer::spooler != "cups" && Printer::spooler != "lprng")
	{
	    y2milestone ("Unknown spooler");
	    ret = `connection;
	}
	else if (Printer::confmode == `adm)
	{
	    y2milestone ("Administration, nothing detected");
	    ret = `connection;
	}
	// S390 doesn't have any local interfaces
	if (ret == `connection)
	{
	    if (Arch::s390)
		return `remote_connection;
	    return `connection;
	}

	integer support
	    = Printer::foomatic[Printer::printer["vendor_db"]:"",
		Printer::printer["device_db"]:"", `support]:0;

	// check for existence of at least one PPD file
	map PPDs = Printer::foomatic[
	    Printer::printer["vendor_db"]:"",
	    Printer::printer["device_db"]:""]:$[];
	PPDs = filter (`k, `v, PPDs, ``(is (k, string)));
	if (size (PPDs) < 1)
	{
	    y2milestone ("No PPD file available");
	    ret = `name;
	}
	// check for support status
	else if (support != 0)
	{
	    y2milestone ("Support status isn't fully supported");
	    ret = `name;
	}
	// no reason to ask too much
	else
	{
	    y2milestone ("Supported printer detected");
	    ret = `quick;
	}

	// check CUPS USB device
	if (Printer::spooler == "cups")
	{
	    Printerlib::setCupsUsbDevicesInfo ();
	    list problematic = Printerlib::getProblematicCupsUsbDevices ();
	    string device = Printerlib::getUriDevice (
		Printer::printer["uri"]:"");
	    if (contains (problematic, device))
	    {
		y2milestone ("Problematic CUPS device detected");
		ret = `connection;
	    }
	}
	return ret;
    }

    /**
     * Popup wanting device name.
     * @param pre_filled TextEntry is pre-set by this value.
     * @return string new device or ""
     */
    global define string getDeviceName (string pre_filled)``{
	symbol ret = `ok;
	UI::OpenDialog (
	    `opt (`decorated),
	    `VBox (
		`TextEntry (`id (`text),
			    // textentry label
			    _("&Enter device:"),
			    pre_filled),
		`HBox (
		    `PushButton (`id (`ok), `opt (`key_F10), OKButtonLabel ()),
		    `PushButton (`id (`cancel), `opt (`key_F9), CancelButtonLabel ())
		    )
		)
	    );
	ret = UI::UserInput ();
	pre_filled = UI::QueryWidget (`id (`text), `Value);
	UI::CloseDialog ();
	if (`cancel == ret)
	    {
		return "";
	    }
	return pre_filled;
    }



    /**
      * Backup list of print queues. See description of map printer
      */
    global list printcap_backup = nil;
    /**
      * Backup detected printer map
      */
    global map printer_backup = nil;
    /**
      * Newely created queue
      */
    global map new_added_queue = $[];
    /**
      * Backup of printer URI
      */
    global string uri_backup = nil;
    /**
      * The dialog is running again for repropose
      */
    global boolean running_again = false;
    /**
      * Just to store the foomatici variable between two runs
      */
    global boolean foomatic_save = nil;

    /**
     * Show printer details in one window
     * @return symbol `back `next `abort
     */
    global define symbol runSinglePrinterDialog () ``{
	list forbidden_names = Printer::getForbiddenNames ();
	list new_queues = [];
	list queues = [];
	string first_queue = nil;
	string default_queue = nil;
	string uri = Printer::printer["uri"]:"";

	y2debug ("Single printer dialog: cap: %1,\nter: %2\nuri: %3\nagain: %4", printcap_backup, printer_backup, uri_backup, running_again);
	y2debug ("Single printer dialog: Real: cap: %1\nter: %2\n", Printer::printcap, Printer::printer);

	list mb_items = [
		// menubutton item
	    `item (`id (`clear), _("&Remove Everything")),
		// menubutton item
	    `item (`id (`again), _("Re&propose")),
	];
	boolean foomatic = false;
	if (Printer::printer["database"]:"unknown" != "unknown")
	    foomatic = Printer::printer["database"]:"" == "foomatic";
	else
	    foomatic = true;
	if (foomatic_save != nil)
	{
	    foomatic = foomatic_save;
	    foomatic_save = nil;
	}
	y2milestone ("Single printer dialog: foomatic: %1", foomatic);

	if (Printer::printer["vendor_db"]:"" != ""
	    && Printer::printer["device_db"]:"" != "")
	{
	    mb_items = add (mb_items, `item (`id (`choose_ppd),
		// menubutton item
		_("&Choose PPD File")));
	}

	mb_items = add (mb_items, `item (`id (`choose_model),
	    // menubutton item
	    _("Choose &Model")));

        if (uri_backup != nil)
        {
            uri = uri_backup;
            uri_backup = nil;
        }

	list tmp_printcap = [];
	if (running_again)
	{
	    tmp_printcap = Printer::printcap;
	    Printer::printcap = [];
	}
	else
	{
	    Printer::additional_forbidden_names = [];
	}

	if (foomatic)
	{
	    string vendor = Printer::printer["vendor_db"]:"";
	    string model = Printer::printer["device_db"]:"";
	    string config = Printer::printer["config"]:nil;
	    y2debug ("Gettinq queues for %1", Printer::printer);
	    if (Printer::printer["ownppd"]:"" != "")
	    {
		model = Printer::printer["ownppd"]:"";
		vendor = "__ownppd__";
	    }
	    new_queues = getFoomaticAutoQueues (vendor, model, config);
	    default_queue = getFoomaticDefaultQueue (new_queues);
	}
	else
	{
	    string device = lookup (Printer::printer, "device", "");
	    new_queues = [];
	}

	if (running_again)
	{
	    Printer::printcap = tmp_printcap;
	}

	Printer::additional_forbidden_names = [];

	if (printcap_backup == nil)
	{
	    queues = getQueuesOfPrinter (uri, vendor, device);
	    new_queues = maplist (`q, new_queues, ``{
		q["new"] = true;
		return q;
	    });
	    if (size (queues) == 0 || nil == queues || running_again)
	    {
		queues = new_queues;
	    }
	}
	else
	{
	    queues = Printer::printcap;
	    Printer::printcap = printcap_backup;
	    printcap_backup = nil;
	}

	if (printer_backup != nil)
	{
	    Printer::printer = printer_backup;
	    printer_backup = nil;
	}

	if (new_added_queue != $[])
	{
	    queues = add (queues, new_added_queue);
	    new_added_queue = $[];
	}

	first_queue = nil;
	foreach (`q, queues, ``{
	    if (first_queue == nil)
	    {
		first_queue = q["name"]:nil;
	    }
	});

	running_again = false;

	// in-dialog text: To print, use: lpr QueueName filename
	term contents = `VBox (
	    `VSpacing (0.7),
	    `HBox (
		`HSpacing (2),
		// frame label
		`VBox (
		    `Heading (
			// heading label
			_("The following print queues have been configured:")
		    ),
		    `HBox (
			`HSpacing (1),
			`VBox (
			    `VSpacing (0.5),
			    `Table (
				// table header
				`id (`table), `opt (`notify), `header (_("Queue name"),
				// table header
				 _("Comment"),
				// table header
				_("New")),
				maplist (`v, queues, ``(`item (`id (v["name"]:""), v["name"]:"", v["comment"]:"", v["new"]:false ?
					// tabel entry
					_("Yes") :
					// table entry
					_("No"))))
				),
			    `VSpacing (0.5),
			    `HBox (
				`PushButton (`id (`add), `opt (`key_F3), AddButtonLabel ()),
				`PushButton (`id (`edit), `opt (`key_F4), EditButtonLabel ()),
				`PushButton (`id (`delete), `opt (`key_F5),
				    DeleteButtonLabel ()),
				`HStretch (),
				// pushbutton
				`PushButton (`id (`test), `opt (`key_F6), _("T&est Printing"))
			    ),
			    `VSpacing (0.5)
			    ),
			`HSpacing (1)
			)
		    ),
		    `HSpacing (2)
	        ),
	        `VSpacing (1),
                `HBox (
                    `HStretch (),
                    // menubutton
		    `MenuButton (_("E&xpert Settings"), mb_items),
		    `HStretch ()
                ),
	        `VSpacing (1)
	    );
	// label of the dialog
	Wizard::SetContentsButtons (_("Printer overview"), contents, getShowPrinterHelp (), UI::BackButtonLabel (), UI::OKButtonLabel ());

	UI::ChangeWidget (`id (`table), `CurrentItem, first_queue);

	symbol ret = nil;
	while (true)
	{
	    ret = UI::UserInput ();
	    if (ret == `table)
	    {
		ret = `edit;
	    }
	    if (`abort == ret || `cancel == ret)
	    {
		ret = `abort;
		if (reallyAbort ())
		{
		    break;
		}
	    }
	    else if (`test == ret)
	    {
		string i = UI::QueryWidget (`id (`table), `CurrentItem);
		foreach (`e, queues, ``{
		    if (lookup (e, "name", "") == i)
			testPrinter (e, `ask);
		});
	    }
	    else if (ret == `clear || ret == `again || ret == `choose_ppd
		|| ret == `choose_model)
	    {
		// yes-no popup 1/3
		string warning = _("Warning:

All listed queues will be removed.
");
		if (ret == `again)
			// yes-no popup 2/3, optional
		    warning = warning + _("\nDefault PPD file will be used
for proposing new queues.");
		// yes-no popup 3/3
		warning = warning + _("\nContinue?");
		if (! UI::YesNoPopup (warning))
		{
		    ret = nil;
		    continue;
		}
		if (ret == `clear)
		{
		    queues = [];
		    UI::ChangeWidget (`id (`table), `Items, []);
		}
		else
		{
		    break;
		}
	    }
	    else if (ret == `edit)
	    {
		string i = UI::QueryWidget (`id (`table), `CurrentItem);
                if (i == nil)
                    continue;
		else
		    break;
	    }
	    else if (ret == `delete)
	    {
                string i = UI::QueryWidget (`id (`table), `CurrentItem);
		if (i == nil)
		    continue;
		if (UI::YesNoPopup (sformat (
		    // yes-no popup, %1 is replaced by printer name
		    _("Really delete the \"%1\" printer?"), i)))
		{
		    queues = filter (`q, queues, ``(
			q["name"]:"" != i
		    ));
		    UI::ChangeWidget (`id (`table), `Items, maplist (`v, queues, ``(`item (`id (v["name"]:""), v["name"]:"", v["comment"]:"",
			// table entry
			v["new"]:false ? _("Yes")
			// table entry
			: _("No")))));
// TODO		    UI::ChangeWidget (`id (`table), `CurrentItem,
		}
	    }
	    else
	    {
		break;
	    }
	}
	if (`next == ret)
	{
	    list(string) queue_names = maplist (`q, queues, ``(q["name"]:""));
	    list(string) orig_names = maplist (`q,
		getQueuesOfPrinter (uri, vendor, device),
		``(q["name"]:""));
	    Printer::printcap = filter (`p, Printer::printcap, ``(
		contains (queue_names, p["name"]:"")
		|| ! contains (orig_names, p["name"]:"")
	    ));
	    boolean set_default = Printer::default == ""
		|| Printer::default == nil;
	    // add queues...
	    foreach (`v, queues, ``{
		    Printer::selectPrinterByName (v["name"]:"");
		    Printer::printer = v;
		    Printer::storePrinter ();
		});
	    if (foomatic && set_default
		&& default_queue != nil && default_queue != "")
	    {
		Printer::default = default_queue;
	    }
	}
	else if (ret == `add || ret == `edit)
	{
	    foomatic_save = foomatic;
	    Printer::additional_forbidden_names = Printer::getForbiddenNames ();
	    printer_backup = Printer::printer;
	    printcap_backup = Printer::printcap;
	    Printer::printcap = queues;
	    uri_backup = uri;
	    if (ret == `add)
	    {
		Printer::index = -1;
		Printer::printer["new"] = true;
		if (haskey (Printer::printer, "name"))
		    Printer::printer = remove (Printer::printer, "name");
		return `add;
	    }
	    else // edit
	    {
		string i = UI::QueryWidget (`id (`table), `CurrentItem);
		Printer::selectPrinterByName (i);
		return `edit;
	    }

	}
	else if (ret == `choose_ppd || ret == `again || ret == `choose_model)
	{
	    if (ret != `choose_model && ret != `choose_ppd)
		foomatic_save = foomatic;
	    list tmp_printcap = Printer::printcap;
	    list deleted_queues = maplist (`q, queues, ``(q["name"]:""));
	    Printer::printcap = filter (`p, Printer::printcap, ``(
		! contains (deleted_queues, p["name"]:"")));
	    Printer::additional_forbidden_names = Printer::getForbiddenNames ();
	    Printer::additional_forbidden_names = filter (`n,
		Printer::additional_forbidden_names,
		``( ! contains (Printer::sys_forbidden_names, n)
	    ));
	    Printer::printcap = tmp_printcap;
	    if (ret == `again && haskey (Printer::printer, "config"))
		Printer::printer = remove (Printer::printer, "config");
	    running_again = true;
	}
	return ret;
    }

    /**
     * Create contents of table of autodetected printers.
     * @param current_sel currently selected item
     * @return list list of items, `ids are indexes to autoprobed_printers list
     */
    global define list getAutoprobedSelectionBox (integer current_sel) ``{
	integer current = -1;
	boolean selected = false;
	list items = maplist (`i, Printer::autodetected, ``{
	    current = current + 1;
	    if (current == current_sel)
	    {
		selected = true;
	    }
	    if (isPrinterConfigured (i))
	    {
		return nil;
	    }
	    else
		return `item (`id (current), sformat (_("%1 %2 on %3"),
		    i["vendor"]:"", i["device"]:"",
		    Printerlib::getDeviceNiceName (i["dev_name"]:"", true)),
			  current == current_sel);
	});
	items = filter (`i, items, ``(i != nil));
	if (size (getConfiguredPrinters ()) > 0)
	{
	    items = add (items, `item (`id (-2),
		// selection box entry
		_("New queue for already configured printer")));
	}
	// selection box entry
	return add (items, `item (`id (-1), _("Other (not detected)"),
	    !selected));
    }

    /**
     * Restart detection of printers.
     * @return symbol always `next
     */
    global define symbol runProbeDialog () ``{
	Printer::Detect ();
	return `next;
    }

    /**
     * Common detected hardware dialog.
     * @return symbol for ws
     */
    global define symbol runDetectedDialog () ``{
	Printer::confmode = `det;
	term contents = Wizard_hw::DetectedContent (
	    // Selectionbox caption
	    _("Printers to configure"),
	    getAutoprobedSelectionBox (runAutoprobedListDialog__current),
	    true,
	    // richtext caption
	    _("<P>Already installed printers and queues:</P>")
	    + Printer::Summary ([`nonew, `test, `state])
	    );
	// dialog label
	Wizard::SetContentsButtons (_("Printer setup: Autodetected printers"), contents, getDetectedHelp (), BackButtonLabel (), FinishButtonLabel ());
//	Wizard::ReplaceBackButton(`VSpacing (0));
	any ret = nil;
	while (true)
	{
	    ret = UI::UserInput ();
            if (ret == `cancel)
                ret = `abort;
	    if (is (ret, string))
	    {
		// request for testing printer...
		Printer::selectPrinterByName (ret);
		testPrinter (Printer::printer, `ask);
		continue ;
	    }
	    if (`abort == ret)
	    {
		ret = `abort;
		if (reallyAbort ())
		{
		    break;
		}
		continue;
	    }
	    if (`back == ret || `cancel == ret)
	    {
		ret = `back;
		if (reallyExit ())
		    break;
		continue;
	    }
	    else if (`next == ret) // finish
	    {
		// message box
		if (Printer::warn_finish && ! Mode::config &&
		  !UI::ContinueCancelPopup (_("Now the changes to your printing 
system will be saved.")))
		{
		    continue;
		}
	    }
	    else if (`configure_button == ret)
	    {
		Printer::conf_detected = true;
		runAutoprobedListDialog__current
		    = UI::QueryWidget (`id (`detected_selbox), `CurrentItem);
		if (runAutoprobedListDialog__current >= 0)
		{
		    // comments added to go with other printer through
		    // the same sequence
		    Printer::editDetected (
			Printer::autodetected[
			    runAutoprobedListDialog__current]:$[]);
		}
		else
		    Printer::printer = $[];
	    }
	    break;
	}
	return ret;
    }
    /**
     * Complex dialog.
     * @return symbol for ws
     */
    global define symbol runComplexDialog () ``{
	Printer::confmode = `adm;
	string spoolerlabel = "";
	if (Printer::spooler == "cups")
	{
	    spoolerlabel = "CUPS";
	}
	else if (Printer::spooler == "lprng")
	{
	    spoolerlabel = "LPRng";
	}
	else
	    spoolerlabel = "any spooler";
	Wizard::SetContentsButtons (
	// Header of the dilag with all the printers
	    sformat (_("Printer administration for %1"), spoolerlabel),
	    Wizard_hw::ConfiguredContent (
		(Printer::spooler == "cups" || Printer::spooler == "lprng")
		?
			// table header
		    `header (_("Default"),
			// table header
			 _("Name"),
			// table header
			 _("Type"),
			// table header
			 `Center(_("Ready")))
		:
			// table header
		    `header (_("Default"),
			// table header
			 _("Name"),
			// table header
			 _("Type"),
			// table header
			 `Center(_("CUPS")),
			// table header
			 `Center(_("LPRng"))),
		printcapTable (),
		nil, nil,
		`HBox (
		    `HStretch (),
		// push button
		`PushButton (`id (`setdefault), _("&Set as default")),
		// push button
		`PushButton (`id (`advanced), `opt (`key_F7), _("Ad&vanced")),

		    `HStretch ()
		),
		nil
	    ),
	    getComplexHelp (),
	    BackButtonLabel (),
	    FinishButtonLabel ()
	);
	if (Printer::detection)
	{
	    Wizard::RestoreBackButton ();
	}
	else
	{
//	    Wizard::ReplaceBackButton (`VSpacing (0));
	}
	UI::ChangeWidget (`id (`table), `CurrentItem, -1 == Printer::index ? 0 : Printer::index);
	symbol ret = nil;
	while (true)
	    {
		ret = UI::UserInput ();
		if (ret == `table)
		{
		    ret = `edit_button;
		}
	        if (ret == `cancel)
		    ret = `abort;

		if (ret == `add_button)
		{
		    Printer::selectPrinter (-1);
		    Printer::conf_detected = false;
		    return `add;
		}
		else if (ret == `edit_button || ret == `delete_button || ret == `setdefault)
		{
		    Printer::selectPrinter (AnyToInteger (UI::QueryWidget (`id (`table), `CurrentItem)));
		    if (-1 != Printer::index)
		    {
			if (ret == `edit_button)
			{
			    return `edit;
			}
			else if (`delete_button == ret)
			{
			    // message box, %1 is replaced by printer name
			    if (UI::YesNoPopup (sformat (_("Really delete the \"%1\" printer?
"), lookup (Printer::printer, "name", ""))))
				Printer::deletePrinter ();
			    UI::ChangeWidget (`id (`table), `Items, printcapTable ());
			    UI::ChangeWidget (`id (`table), `CurrentItem, Printer::index);
			}
			else
			{
			    Printer::setDefaultPrinter ();
			    UI::ChangeWidget (`id (`table), `Items, printcapTable ());
			    UI::ChangeWidget (`id (`table), `CurrentItem, Printer::index);
			}
		    }
		    else
		    {
			// message box
			UI::MessagePopup (_("Select a printer."));
		    }
		}
		else if (`advanced == ret)
		{
		    break;
		}
		else if (`cancel == ret || `abort == ret)
		{
		    ret = `abort;
		    if (reallyAbort ())
		    {
			break;
		    }
		}
		if (`back == ret)
		{
		    if (Printer::detection || reallyExit())
			break;
		}
		if (`next == ret)
		{
		    // message box
		    if (!Printer::warn_finish || Mode::config || UI::ContinueCancelPopup (Printer::save_all ? _("Now the configuration of the printing 
system will be saved
")
			// message box
			: _("Now the changes to your printing \nsystem will be saved.")))
		    {
			break;
		    }
		}
		if (`scratch == ret)
		{
			// message box
		    if (! UI::AnyQuestionPopup(WarningMsg(), _("Really reinstall your printing system? 
All your changes will be lost.
"),
			// push button
			_("&Reinstall"), CancelButtonLabel (), `focus_no))
			    continue;
		    boolean success = reinstallAll ();
			break;
		}
	    }
	return ret;
    }
    /**
      * Detect installation type
      * @return symbol `server or `client
      */
    global define symbol getInstType () ``{
	if (Printer::spooler != "cups")
	    return `server;
	return Printer::cupsInstallationType ();
    }
    /**
      * Detect current queue configuration type (class/database/ppd)
      * @return symbol `class or `db or `ppd
      */
    global define symbol getQueueConfType () ``{
	if (Printer::printer["ownppd"]:"" != "")
	    return `ppd;
	if (Printer::printer["uri"]:"" == "class")
	    return `class;
	return `db;
    }

    /**
     * Change parallel port settings. This function must be called when
     * wizard dialog has been set up. Hence it suppose Wizard library to
     * be imported.
     * @return symbol for wizard sequencer
     */
    global define symbol editParallelPort () ``{
        map params = SCR::Read (.modules.options, "parport_pc");
        // dialog caption
        Wizard::SetContentsButtons (_("Parallel port settings"), `VBox (
                    `VStretch (),
                    // textentry label
                    `TextEntry (`id (`io), _("IO &Ports of parallel ports:"), lookup (params, "io", "")),
                    `VSpacing (2),
                    `VStretch ()
                    ),
                textEditParallelPort (), BackButtonLabel (), OKButtonLabel ());
        symbol r = UI::UserInput (); 
        if (`next == r)
        {
            string s = UI::QueryWidget (`id (`io), `Value);
            if (nil == s || "" == s)
            {
                params = filter (`k, `v, params, ``("io" != k));
            }
            else
            {
                params = add (params, "io", s);
            }
            SCR::Write (.modules.options, 0 == size (params) ? nil : params, "parport_pc");
        }
        return r;
    }

    /**
     * Change serial port settings. This function must be called when
     * wizard dialog has been set up. Hence it suppose Wizard library to
     * be imported.
     * @return symbol for wizard sequencer
     */
    global define symbol editSerialPort () ``{
        string uri = lookup (Printer::printer, "tmpuri", "parallel");
        integer baudrate = Printerlib::getUriBaudrate (uri);
        string ser_settings = Printerlib::getUriValue (uri, "ty");

        term contents = `VBox (
                                // combobox label
                                `ComboBox (`id (`baudent), `opt (`editable, `hstretch), _("Baud &rate:"),
                                      [ sformat ("%1", baudrate),
                                      "1200","2400", "4800", "9600", "19200", "38400", "57600", "115200"
                                      ]),
                                // textentry label
                                `TextEntry (`id (`ser_settings), `opt (`hstretch), _("Serial Port &Settings"), ser_settings)
                        );

        // dialog caption
        Wizard::SetContentsButtons (_("Other settings"), contents,  textEditSerialPort (), BackButtonLabel (), NextButtonLabel ());
        symbol r = nil;
        while (r != `back && r != `abort)
        {
            r = UI::UserInput ();

            ser_settings = UI::QueryWidget (`id (`ser_settings), `Value);
            string tmp = UI::QueryWidget (`id (`baudent), `Value);
            baudrate = tointeger (tmp);
            if (`next == ret && !testBaudRate (baudrate))
                ret = nil;

            if (`next == r)
            {
                uri = "serial:" + getUriDevice (uri) + sformat ("?baudrate=%1+ty=%2", baudrate, ser_settings);
                Printer::printer = add (Printer::printer, "tmpuri", uri);
                return r;
            }
            if (`abort == r && ! reallyAbort ())
                r = nil;
        }
        return r;
    }

    /**
      * Store queue to temporary storage
      * @return symbol for wizard sequencer
      */
    global define symbol storeQueue () ``{
	new_added_queue = Printer::printer;
	return `next;
    }

    /**
      * Test whether at least one queue will be proposed
      * Get data from internal structures
      * @return symbol `yes or `no
      */
    global define symbol hasPrinterAutoQueue () ``{
	string uri = Printer::printer["uri"]:"";
	string vendor = Printer::printer["vendor_db"]:"";
	string model = Printer::printer["device_db"]:"";
	string config = Printer::printer["config"]:nil;
	y2debug ("Gettinq queues for %1", Printer::printer);
	if (Printer::printer["ownppd"]:"" != "")
	{
	    model = Printer::printer["ownppd"]:"";
	    vendor = "__ownppd__";
	}
	list new_queues = getFoomaticAutoQueues (vendor, model, config);
	if (size (new_queues) > 0)
	{
	    return `yes;
	}
	return `no;
    }

    /**
     * Get map of aliases for wizard sequencer.
     * @return aliases
     */
    global define map getAliases () ``{
	 return $[
	    // switchers, no dialogs
	    "detectconftype" :	[ ``(detectConfigType ()), true],
	    "config_type" :	[ ``(getInstType ()), true, ],
	    "queue_conf_type" :	[ ``(getQueueConfType ()), true, ],
	    "has_auto_queue" :	[ ``(hasPrinterAutoQueue ()), true ],

	    // real dialogs
	    "name_auto" :	``(runNameDialog (true)),
	    "name" :		``(runNameDialog (false)),
	    "connection_type" :	``(runConnectionTypeDialog ()),

	    // sequences


	    "complex" :		``(runComplexDialog ()),
	    "advanced" :	``(runAdvancedDialog ()),
	    "cupsd" :		``(runCupsServerDialog ()),
            "cupsaclroot" :	``(runCupsAclDialog (`root)),
            "cupsacladmin" :	``(runCupsAclDialog (`admin)),
            "cupsaclprinters" :	``(runCupsAclDialog (`printers)),
            "cupsaclclasses" :	``(runCupsAclDialog (`classes)),
	    "cups_client" :	``(runClientDialog ()),
	    "connection" :	``(runConnectionDialog ()),
	    "advconnection" :	``(runAdvancedConnectionDialog ()),
	    "parallel" :	``(runDeviceDialog ("parallel")),
	    "pipe" :		``(runPipeDialog ()),
	    "serial" :		``(runDeviceDialog ("serial")),
	    "usb" :		``(runDeviceDialog ("usb")),
	    "irda" :		``(runDeviceDialog ("irda")),
	    "samba" :		``(runRemoteDialog ("samba")),
	    "novell" :		``(runRemoteDialog ("novell")),
	    "lpd" :		``(runRemoteDialog ("lpd")),
	    "ipp" :		``(runRemoteDialog ("ipp")),
	    "socket" :		``(runRemoteDialog ("socket")),
	    "other" :		``(runUriDialog()),
	    "model" :		``(runManufModelDialog ()),
	    "inst_printer" :	``(runInstalledPrinterDialog ()),
	    "useppd" :		``(runSelectPpdFile ()),
	    "config" :		``(runConfigDialog (false)),
	    "ppdselect" :	``(runConfigDialog (true)),
	    "members" :		``(runMembersDialog ()),
	    "filter" :		``(runOptionsDialog ()),
	    "features" :	``(runFeaturesDialog ()),
	    "users" :		``(runUsersDialog ()),
	    "state" :		``(runStateDialog ()),
	    "edit" :		``(runEditDialog ()),
	    "detected" :	``(runDetectedDialog ()),
	    "single" :		``(runSinglePrinterDialog ()),
	    "redetect" :	[ ``(runProbeDialog ()), true ],
	    "storeprinter" :	[ ``(storePrinter ()) , true ],
	    "storequeue" :	[ ``(storeQueue ()), true ],
	    "ppdetails" :	``(editParallelPort ()),
	    "spdetails" :	``(editSerialPort ()),
	    "main_wz" :		``(WizardSequencer (getAliases (), main_sequence)),
	    "add_printer_wz" :	``(WizardSequencer (getAliases (), add_printer_sequence)),
	    "edit_printer_wz" :	``(WizardSequencer (getAliases (), edit_printer_sequence)),
	    "cups_wz" :		``(WizardSequencer (getAliases (), cups_sequence)),
	    "add_queue_wz":	``(WizardSequencer (getAliases (), add_queue_sequence)),
	    "add_queue_wz_1":	[ ``(WizardSequencer (getAliases (), add_queue_sequence)), true],
	    "single_printer_wz":``(WizardSequencer (getAliases (), single_printer_sequence)),
	    "cups_usb" :	``(runCupsUsbDeviceTypeDialog ()),
	    ];
    }
    /**
     * Show all dialogs with some fake data...
     */
    global define void testDialogs () ``{
	Printer::printcap = [
	    $["conf":$[], "config":"gs-stp-canon-bjc-6100-color-high", "device":"canon-bjc-6100", "device_ieee":"BJC-6100", "name":"best", "options":$["papersize-all-inkjet":1], "type":"yast2", "unique_key":"Kns9.VeHHAhw8MvA", "uri":"usb:/dev/usb/lp0", "vendor":"canon", "vendor_ieee":"Canon"],
	    $["conf":$[], "config":"gs-stp-canon-bjc-6100-color-low", "device":"canon-bjc-6100", "device_ieee":"BJC-6100", "name":"color", "options":$["papersize-all-inkjet":1], "type":"yast2", "unique_key":"Kns9.VeHHAhw8MvA", "uri":"usb:/dev/usb/lp0", "vendor":"canon", "vendor_ieee":"Canon"],
	    $["conf":$[], "config":"gs-stp-canon-bjc-6100-color-medium", "device":"canon-bjc-6100", "device_ieee":"BJC-6100", "name":"high", "options":$["papersize-all-inkjet":1], "type":"yast2", "unique_key":"Kns9.VeHHAhw8MvA", "uri":"usb:/dev/usb/lp0", "vendor":"canon", "vendor_ieee":"Canon"],
	    $["conf":$[], "config":"gs-stp-canon-bjc-6100-mono-low", "device":"canon-bjc-6100", "device_ieee":"BJC-6100", "name":"lp", "options":$["papersize-all-inkjet":1], "type":"yast2", "unique_key":"Kns9.VeHHAhw8MvA", "uri":"usb:/dev/usb/lp0", "vendor":"canon", "vendor_ieee":"Canon"],
	    $["conf":$[], "ff":false, "name":"rem", "raw":false, "type":"yast2", "uri":"lpd://printer.suse.de/lp"],
	];
	Printer::autodetected = [
	    $["bus":"usb", "dev_name":"/dev/usb/lp0", "device":"BJC-6100", "unique_key":"Kns9.VeHHAhw8MvA", "uri":"usb:/dev/usb/lp0", "vendor":"Canon"],
	];
	Printer::default = "lp";
	Printer::selectPrinter (3);
	list seq = [ "detected", "configdetected", "quick", "complex", "connection", "usb", "name", "model", "config", "filter", "featues", "edit", ];
	foreach (`i, seq, ``{
	    eval (lookup (getAliases (), i, nil));
	});
	Printer::index = -1;									runConnectionDialog ();
	Printer::printer = add (Printer::printer, "uri", "parallel:/dev/lp0");		runDeviceDialog ("parallel");
	Printer::printer = add (Printer::printer, "uri", "serial:/dev/ttyS0");		runDeviceDialog ("serial");
	Printer::printer = add (Printer::printer, "uri", "file:/tmp/printer.ps");		runPipeDialog ();
	Printer::printer = add (Printer::printer, "uri", "samba://user@smb.suse.de/lp");	runRemoteDialog ("samba");
	Printer::printer = add (Printer::printer, "uri", "novell://user@novell.suse.de/lp");runRemoteDialog ("novell");
	Printer::printer = add (Printer::printer, "uri", "lpr://printer.suse.de/lp");	runRemoteDialog ("lpd");
    }
    /**
     * Run configuratin wizard.
     * @param skip_detection true if detection is skipped
     * @return `next, `back, `abort. If `next, then save settings.
     */
    global define symbol runWizard (boolean skip_detection) ``{
	map detected_sequence = $[
	    "ws_start" : "config_type",
	    "config_type" : $[`server : "detected", `client : "main_wz"],
	    "redetect" : $[`next : "detected", ],
	    "detected" : $[
		`next : `next,
		`abort : `abort,
		`configure_button : "add_printer_wz",
		`restart_button : "redetect",
		`edit_button : "main_wz",
		],
	    "add_printer_wz" : $[
		`abort : `abort,
		`next : "detected",
		],
	    "main_wz" : $[
		`next : `next,
		`abort : `abort,
		`switch : `switch,
		`reinstall : `reinstall,
		],
	    ];
	map main_sequence = $[
	    "ws_start" : "config_type",
	    "config_type" : $[`server : "complex", `client : "cups_client"],
	    "complex"  : $[
		`next : `next,
		`add  : "add_printer_wz",
		`edit : "edit_printer_wz",
		`abort : `abort,
		`client : "cups_client",
		`advanced : "advanced",
		],
	    "advanced" : $[
		`next : "config_type",
		`this : "advanced",
		`cups : "config_type",
		`cupsd : "cupsd",
		`cupsusb : "cups_usb",
		`reinstall : `reinstall,
		`switch : `switch,
		`abort : `abort,
		],
	    "cups_usb" : $[
		`next : "advanced",
		`abort : `abort,
	    ],
	    "cupsd" : $[
		`next : "advanced",
		`abort : `abort,
		`root : "cupsaclroot",
		`admin : "cupsacladmin",
		`printers : "cupsaclprinters",
		`classes : "cupsaclclasses",
	    ],
	    "cupsaclroot" : $[
		`next : "cupsd",
		`abort : `abort,
	    ],
            "cupsacladmin" : $[
                `next : "cupsd",
                `abort : `abort,
            ],
            "cupsaclprinters" : $[
                `next : "cupsd",
                `abort : `abort,
            ],
            "cupsaclclasses" : $[
                `next : "cupsd",
                `abort : `abort,
            ],
	    "add_printer_wz" : $[
		`next: "complex",
		`abort : `abort,
		],
	    "edit_printer_wz": $[
		`next: "complex",
		`abort : `abort,
		],
	    "cups_client" : $[
		`next : `next,
		`abort : `abort,
		`advanced : "advanced",
		`switch : `switch,
		],
	    ];
	map single_printer_sequence = $[
	    "ws_start" : "has_auto_queue",
	    "has_auto_queue" : $[`yes : "single", `no : "add_queue_wz_1"],
	    "single" : $[
		`abort : `abort,
		`next : `next,
		`edit : "edit_printer_wz",
		`add : "add_queue_wz",
		`again : "single",
		`choose_ppd : "ppdselect",
		`choose_model : "model",
	    ],
	    "edit_printer_wz" : $[ `abort : `abort, `next : "single"],
	    "add_queue_wz" : $[ `abort : `abort, `next : "single"],
	    "add_queue_wz_1" : $[ `abort : `abort, `next : "single"],
	    "ppdselect" : $[ `abort : `abort, `next : "single", ],
	    "model":$[ `abort : `abort, `next : "single", `useppd : "useppd", ],
            "useppd" : $[ `abort : `abort, `db : "model", `next: "ppdselect" ],

	];
	map add_printer_sequence = $[
	    "ws_start"   : "detectconftype",
	    "detectconftype" : $[
                `abort : `abort,
                `quick : "edit_printer_wz",
                `name : "name_auto",
		`queue : "add_queue_wz",
		`installed_printer : "inst_printer",
		`connection : "connection_type",
		`remote_connection : "advconnection",
	    ],
	    "connection_type" : $[
		`next : "connection",
		`abort : `abort,
	    ],
	    "connection" : $[
		`parallel : "parallel",
		`serial: "serial",
		`usb: "usb",
		`irda: "irda",
		`more: "advconnection",
		`existing : "inst_printer",
		`abort : `abort,
		],
	    "advconnection" : $[
		`samba: "samba",
		`novell: "novell",
		`lpd: "lpd",
		`ipp: "ipp",
		`socket: "socket",
		`pipe: "pipe",
		`other: "other",
		`class : "add_queue_wz",
		`existing : "inst_printer",
		`abort : `abort,
	    ],
	    // single connection types
	    "parallel" : $[ `next : "name_auto", `abort : `abort, `ppdetails : "ppdetails", ],
	    "pipe" : $[ `next : "name_auto", `abort : `abort, ],
	    "serial" : $[ `next : "name_auto", `abort : `abort,  `spdetails : "spdetails", ],
	    "usb" : $[ `next : "name_auto", `abort : `abort, ],
	    "irda" : $[ `next : "name_auto", `abort : `abort, ],
	    "samba" : $[ `next : "name_auto", `abort : `abort, ],
	    "novell" : $[ `next : "name_auto", `abort : `abort, ],
	    "lpd" : $[ `next : "name_auto", `abort : `abort, ],
	    "ipp" : $[ `next : "name_auto", `abort : `abort, ],
	    "socket" : $[ `next : "name_auto", `abort : `abort, ],
	    "other" : $[ `next : "name_auto", `abort : `abort, ],
	    // end of connection types

	    "name_auto" : $[
		`abort : `abort,
		`next : "model",
		`raw : "storeprinter",
		`class : "edit_printer_wz",// FIXME
	    ],
	    "model" : $[
		`abort : `abort,
		`next : "edit_printer_wz",
		`useppd : "useppd",
	    ],
	    "useppd" : $[
		`abort : `abort,
		`db : "model",
		`next: "edit_printer_wz",
	    ],
	    "edit_printer_wz" : $[ `abort : `abort, `next : `next ],
	    "single_printer_wz" : $[ `abort : `abort, `next : `next ],

	    "ppdetails" : $[ `abort : `abort, `next : "parallel", ],
	    "spdetails" : $[ `abort : `abort, `next : "serial", ],
	    "storeprinter" : $[`next : `next, ],

            "inst_printer" : $[ `next : "add_queue_wz", `abort : `abort, ],
            "add_queue_wz" : $[ `next : "storeprinter", `abort : `abort, ],


	    ];


	map add_queue_sequence = $[
	    "ws_start" : "name",
            "name" : $[
		`abort : `abort,
		`next : "config",
		`raw : "storequeue",
		`class : "members",
	    ],
            "config" : $[
		`abort : `abort,
		`advanced : "filter",
		`next: "storequeue",
	    ],
            "filter" : $[
		`abort : `abort,
		`next_cups : "cups_wz",
		`next : "features",
	    ],
            "features" : $[
		`abort : `abort,
		`next_cups : "cups_wz",
		`next : "config",
	    ],
            "cups_wz" : $[
		`abort : `abort,
		`next : "queue_conf_type",
	    ],
            "queue_conf_type" : $[
		`db : "config",
		`class : "members",
		`ppd : "config",
	    ],
	    "members" : $[
		`abort : `abort,
		`advanced : "cups_wz",
		`next : "storequeue",
	    ],
	    "storequeue" : $[
		`abort: `abort,
		`next: `next
	    ],
	];

	map edit_printer_sequence = $[
	    "ws_start"   : "edit",
	    "edit" : $[
		`con_samba : "samba",
		`con_novell : "novell",
		`con_lpd: "lpd",
		`con_pipe: "pipe",
		`con_ipp : "ipp",
		`con_socket: "socket",
		`connection : "connection",
		`name : "name",
		`model : "model",
		`config : "config",
		`settings : "filter",
		`ascii : "features",
		`state : "state",
		`perm : "users",
		`indep : "features",
		`ppd : "useppd",
		`cups: "cups_wz",
		`class_members : "members",
		`class : "cups_wz",
		`add : "add_printer_wz",
		`next : "storeprinter",
		`abort : `abort,
		],
	    "features" : $[ `next : "edit", `next_cups : "edit", `abort : `abort, ],
	    "state" : $[ `next : "edit", `abort : `abort, ],
	    "users" : $[ `next : "edit", `abort : `abort, ],
	    "add_printer_wz" : $[ `next : "edit", `abort : `abort ],
	    "samba" : $[ `next : "edit", `abort : `abort, ],
	    "novell" : $[ `next : "edit", `abort : `abort, ],
	    "ipp" : $[ `next : "edit", `abort : `abort, ],
	    "socket" : $[ `next : "edit", `abort : `abort, ],
	    "connection" : $[
		`parallel: "parallel",
		`serial : "serial",
		`usb : "usb",
		`irda : "irda",
		`abort : `abort,
		],
	    "parallel" : $[ `abort : `abort, `next : "edit", `ppdetails : "ppdetails", ],
	    "ppdetails" : $[ `abort : `abort, `next : "parallel", ],
	    "serial" : $[ `abort : `abort, `next : "edit", `spdetails : "spdetails",],
	    "usb" : $[ `abort : `abort, `next : "edit", ],
	    "irda" : $[ `next : "edit", `abort : `abort, ],
	    "lpd" : $[ `abort: `abort, `next: "edit", ],
	    "pipe" : $[ `abort : `abort, `next : "edit", ],
	    "model" : $[ `abort : `abort, `next : "config", `useppd: "useppd",],
	    "config" : $[ `abort : `abort, `advanced : "filter", `next: "edit", ],
	    "name" : $[ `abort : `abort, `next : "edit", `raw : "edit", `class : "edit" ],
	    "filter" : $[ `abort : `abort, `next : "edit", `next_cups : "edit", ],
	    "useppd" : $[ `abort : `abort, `db : "model", `next: "edit" ],
	    "members" : $[ `abort : `abort, `next : "edit", ],
	    "cups_wz" : $[ `abort : `abort, `next : "edit", ],
	    "ppdetails" : $[ `abort : `abort, `next : "parallel", ],
	    "spdetails" : $[ `abort : `abort, `next : "serial", ],
	    "storeprinter" : $[`next : `next, ],
	    ];
	map cups_sequence = $[
	    "ws_start" : "users",
	    "users" : $[ `abot : `abort, `next : "state", ],
	    "state" : $[ `abort : `abort, `next : `next, `next_ppd : `next_ppd, ],
	    ];

	Printer::detection = !skip_detection;
	return WizardSequencer (getAliases (), skip_detection ? main_sequence : detected_sequence);
    }
}
