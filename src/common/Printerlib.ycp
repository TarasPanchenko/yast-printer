/**
 * File:
 *   modules/Printerlib.ycp
 *
 * Package:
 *   Printer library.
 *
 * Summary:
 *   Some utility functions for printer conf. tools.
 *
 * Authors:
 *   Petr Blahos <pblahos@suse.cz>
 *
 * $Id$
 *
 * Printer library exported functions. What else?!?
 */

{
    module "Printerlib";
    textdomain "printer";
    import "Printer";
    include "printer/texts.ycp";
    include "ui/common_messages.ycp";
    include "printer/misc.ycp";
    import "Mode";

    /**
     * set to true after function Read had been called.
     */
    global boolean proposal_valid = false;
    /**
     * System paper size, taken from system locales. 0 for a4 and 1 for
     * letter. -1 for unknown. Use function Printerlib::getDefaultPaperSize
     * for accessing this function.
     */
    integer paper_size = -1;
    /**
      * true id Pkg::target_init was already called
      */
    boolean taregt_inited = false;

    /**
      * Base directory of printconf's data files
      */
    global string baseDataDir = "/usr/share/YaST2/data/printer";

    /**
      * Initialize package manager target
      */
    global define void initTarget () ``{
	if (! taregt_inited)
	{
	    Pkg::TargetInit ("/", false);
	    taregt_inited = true;
	}
    };
    /**
     * Returns haxadecimal value of input number
     * @param i number to be converted
     * @return string number
     */
    define string tohexWithout0x4digits (integer i) ``{
	string hex = substring (tohexstring (i), 2);
	if (size (hex) < 4)
	    hex = "0000" + hex;
	if (size (hex) > 4)
	    hex = substring (hex, size (hex) - 4);
	return hex;
    }
    /**
     * Sends sequence to wake up Epson stylus usb printers.
     * @see <a href="http://sdb.suse.de/en/sdb/html/jsmeix_print-stcXXXusb.html">Installing an Epson Stylus Color Printer on USB</a>
     * @param device Device to send sequence to. Should be /dev/usblp? (or /dev/usb/lp?)
     */
    define void wakeUpEpson (string device) ``{
	string sequence =
	    "\"\\000\\000\\000\\033\\001\\100\\105\\112\\114\\040\\061\\062\\070\\064\\056\\064\\012\\100\\105\\112\\114\\040\\040\\040\\040\\040\\012\"";
	if (haskey (SCR::Read (.proc.modules), "printer"))
	    SCR::Execute (.target.bash, sformat ("
MAIN_PID=$$
{/bin/echo -en %1 > %2 ; kill MAIN_PID} &
ECHO_PID=$!
{sleep 2s ; kill $ECHO_PID &>/dev/null ; } &", sequence, device));
    }

    /**
      * List of CUPS USB device names
      * Contains lists of [<cups_device>, <model_name>, <unix_device>]
      */
    global list(list(string)) cups_usb_devices = [];

    /**
      * Set list of CUPS USB devices
      */
    global define void setCupsUsbDevicesInfo () ``{
	cups_usb_devices = [];
	if (SCR::Read (.target.size, "/usr/lib/cups/backend/usb") <= 0)
	    return;
	map out = SCR::Execute (.target.bash_output,
	    "/usr/lib/cups/backend/usb");
	list(string) lines = splitstring (out["stdout"]:"", "\n");
	lines = filter (`l, lines, ``(l != "" && l != nil));
	integer counter = 0;
	foreach (`l, lines, ``{
	    string model = regexpsub (l, "[^\"]*\"([^\"]*)\".*", "\\1");
	    string c_dev = regexpsub (l, "direct usb:([^ ]*) .*", "\\1");
	    string u_dev = sformat ("/dev/usb/lp%1", counter);
	    if (Printer::cups_usb_dev_names == `never
		|| (Printer::cups_usb_dev_names == `serial
		    && ! issubstring (c_dev, "serial")))
		c_dev = u_dev;
	    cups_usb_devices = add (cups_usb_devices,
		[c_dev, model, u_dev]);
	    counter = counter + 1;
	});
    }

    /**
      * Get problematic CUPS USB devices names
      * @return a list of strings with problematic device names
      */
    global define list(string) getProblematicCupsUsbDevices () ``{
	list c_devs = maplist (`e, cups_usb_devices, ``(e[0]:""));
	c_devs = filter (`d, c_devs, ``(d != ""));
	if (size (c_devs) == size (toset (c_devs)))
	    return [];
	list tested = [];
	list problematic = [];
	foreach (`d, c_devs, ``{
	    if (contains (tested, d))
		problematic = add (problematic, d);
	    tested = add (tested, d);
	});
	return toset (problematic);
    }

    /**
      * Get info about device connected to USB port from CUPS backed
      * @param device string USB device to examine
      * @return a list containing CUPS device name, Printer model and
      *   UNIX-like device
      */
    global define list(string) getCupsUsbDeviceInfo (string device) ``{
        if (SCR::Read (.target.size, "/usr/lib/cups/backend/usb") > 0)
        {
            integer pos = find (device, "lp");
            string dev_num = substring (device, pos + 2);
            if (dev_num != "")
            {
		setCupsUsbDevicesInfo ();
                integer num = tointeger (dev_num);
		y2milestone ("USB backend for device: %1", cups_usb_devices[num]:[]);
		return cups_usb_devices[num]:[];
            }
        }
	return [];
    }

    /**
      * Get all CUPS-like USB device names
      * @return a list of CUPS USB device names
      */
    global define list(string) getCupsUsbDevices () ``{
	setCupsUsbDevicesInfo ();
	list ret = maplist (`e, cups_usb_devices, ``(e[0]:""));
	return ret;
    }

    /**
     * Calls escputil to find out exact model of Epson stylus printer.
     * @param device USB Device to examine.
     * @return string Printer model. If unsuccessful, returns "Stylus".
     */
    define string getEpsonUsbModel (string device) ``{
	// we must wake Epson first
	wakeUpEpson (device);
	// now we can run escputil

	string model = select (getCupsUsbDeviceInfo (device), 1, "");
	if (model != "")
	{
	    if (substring (model, 0, 6) == "EPSON ")
		model = substring (model, 6);
	    return model;
	}

	map esc = SCR::Execute (.target.bash_output, sformat ("/usr/bin/escputil -q -u -r %1 -d & export PID=$! ; sleep 10s ; kill $PID 2>/dev/null || exit 0 && exit 1", device));
	if (0 != lookup (esc, "exit", ""))
	    {
		return "";
	    }
	// get model from output
	string out = lookup (esc, "stdout", "");
	integer i = 0;
	integer len = size (out);
	while (i < len)
	    {
		if (substring (out, 0, 10) == "DES:EPSON ")
		    {
			out = substring (out, 10);
			integer x = findfirstof (out, ";");
			if (nil != x)
			    {
				out = substring (out, 0, x);
			    }
			return out;
		    }
		i = i + 1;
		out = substring (out, 1);
	    }
	return "";
    }

    /**
     * Returns special device string for cups in form:
     * /dev/usb/lp?vendor=04a9&prod_id=1052
     * @param device_id device_id from hwinfo
     * @param vendor_id vendor_id from hwinfo
     * @param orig_device Device file the printer is connected to (/dev/usblp0). Used in case device_id or vendor_id are 0.
     * @return string device uri as specified
     */
    global define string getCupsUsbDevice (integer device_id, integer vendor_id, string orig_device)``{
/*	device_id = device_id & 0xFFFF;
	vendor_id = vendor_id & 0xFFFF;
	if (0 == device_id || 0 == vendor_id)
	    {*/
		return orig_device;
/*	    }
	return sformat ("/dev/usb/lp?vendor=%1&prod_id=%2", tohexWithout0x4digits (device_id), tohexWithout0x4digits (vendor_id));*/
    }

    /**
     * Finally detection of hardware
     * @param cups true if usb devices should be in form /dev/usb/lp?vendor=04a9&prod_id=1052
     * @return list Detected printers. See example.
     * @example
     *  Return:
     *   [
     *       $[
     *           "vendor"       : "...",
     *           "device"       : "...",
     *           "unique_key"   : "...",
     *           "dev_name"     : "...", // "/dev/lp0", "/dev/usblp0", ...
     *           "bus"          : "...", // "usb", "parallel"
     *       ], ...
     *   ]
     */
    global define list Detect (boolean cups) ``{
	boolean have_usb = false;
	if (Mode::config)
	{
	    DisplayUnavailableAIPopup ();
	    return [];
	}
	// load hotplug if it is not (there is no way to find out whether hotplug is runing so just start it)
	if (0 != SCR::Execute (.target.bash, "/etc/init.d/hotplug status"))
	    SCR::Execute (.target.bash, "/etc/init.d/hotplug start");
	list aprobe = SCR::Read (.probe.printer);
/*		aprobe = [
		    $[ "bus" : "Parallel",      // recognized, found in db
		     "dev_name" : "/dev/lp0",
		     "vendor" : "Hewlett-Packard",
		     "device" : "HP LaSerJeT 4050",
		     "unique_key"   : "lp0_hp" ],
		    $[ "bus" : "USB",      // not found in db
		     "dev_name" : "/dev/usblp1",
		     "sub_vendor" : "Epson",
		     "sub_device" : "BJC-6100x",
		     "unique_key"   : "usb_canon" ],
		    $["bus" : "Parallel",	// in db, GDI, but supported
		    "dev_name" : "/dev/lp1",
		    "vendor" : "HEWLETT-PACKARD",
		    "device" : "DeskJet 820C",
		    "unique_key" : "lp1_hp_gdi",
		    ],
		    $[ "bus" : "Parallel",      // found in db but GDI, so not configurable
		     "dev_name" : "/dev/lp2",
		     "vendor" : "Lexmark",
		     "device" : "Lexmark Z12",
		     "unique_key" : "lp2_canon" ],
		    ];*/
/*		aprobe = [
		    $[ "bus" : "Parallel",
		    "dev_name" : "/dev/lp0",
		    "vendor" : "Hewlett-Packard",
		    "device" : "DeS-kJeT-990C",]
		];*/
	if (0 == size (aprobe))
	    {
		return [];
	    }
	list ret = maplist (`pr, aprobe, ``{
	    map record = $[];
	    string bus = lookup (pr, "bus", "");
	    string unique_key = "";

	    if ("Parallel" == bus)
	    {
		record = $[
		    "vendor" : lookup (pr, "vendor", ""),
		    "device" : lookup (pr, "device", ""),
		    "unique_key": lookup (pr,"unique_key",""),
		    "bus" : "parallel",
		    "dev_name": lookup (pr, "dev_name", ""), // device <dev>
		    ];
	    }
	    else if  ("USB" == bus)
	    {
		have_usb = true;
		if (0 !=  SCR::Execute (.target.bash, "grep '^printer ' /proc/modules"))
//		if (! haskey (SCR::Read (.proc.modules), "printer"))
		    return $[];
		if ("epson" == tolower (lookup (pr, "sub_vendor", "")))
		{
			string sub_dev = getEpsonUsbModel (lookup (pr, "dev_name", ""));
			if (sub_dev == "")
			    sub_dev = lookup (pr, "sub_device", "");
			pr = add (pr, "sub_device", sub_dev);
//			pr = add (pr, "sub_device", lookup (pr, "dev_name", "")));
		}
		string class_dev = lookup (pr, "dev_name", "");
		string dev_name = class_dev;

		if (Printer::spooler == "cups")
		{

		    dev_name = select (getCupsUsbDeviceInfo (class_dev), 0, "");
		    if (dev_name == "" || Mode::autoinst)
		    {
			dev_name = class_dev;
		    }
		}
		record = $[
		    "vendor" : lookup (pr, "sub_vendor", ""),
		    "device" : lookup (pr, "sub_device", ""),
		    "unique_key": lookup (pr,"unique_key",""),
		    "bus" : "usb",
		    "vendor_id": lookup (pr, "vendor_id",0),
		    "device_id": lookup (pr, "device_id",0),
//		    "cups_dev_name" : getCupsUsbDevice (lookup (pr, "vendor_id",0), lookup (pr, "device_id",0), lookup (pr, "dev_name", "")),
		    "dev_name": dev_name,
		];
	    }
	    return record;
	});
	if (have_usb)
	{
	    if (0 !=  SCR::Execute (.target.bash, "grep '^printer ' /proc/modules"))
	    {
		y2error ("USB printer found and printer module not loaded, loading it");
		boolean probe_success = SCR::Execute(.target.modprobe, "printer", "");
		string hotplug
		    = SCR::Read (.sysconfig.hotplug.HOTPLUG_USB_STATIC_MODULES);
		y2debug ("Current hotplug: %1", hotplug);
		list(string) hplist = splitstring (hotplug, " ");
		if (! contains (hplist, "printer"))
		{
		    hplist = add (hplist, "printer");
		    hotplug = mergestring (hplist, " ");
		    y2debug ("Final hotplug: %1", hotplug);
		    SCR::Write (.sysconfig.hotplug.HOTPLUG_USB_STATIC_MODULES,
			hotplug);
		    SCR::Write (.sysconfig.hotplug, nil);
		}
		sleep (100);
		if (probe_success)
		{
		    probe_success = 0 == SCR::Execute (.target.bash, "grep '^printer ' /proc/modules");
		}
		if (probe_success)
		{
		    y2milestone ("Restarting detection");
		    ret = Printerlib::Detect (cups);
		    y2debug ("Redetection done");
		}
		else
		{
		    y2error ("Error occured while loading printer.o module");
		}
	    }
	}
	return ret;
    }
    /**
     * Prepare ascii test page. Insert localized string into it.
     * @return string path+filename to updated test page.
     */
    global define string prepareAsciiTestPage () ``{
	// TRANSLATORS:
	// You may add some text to ascii test page if you want.
	// Fill in your encoding here! (e.g. iso-8859-2 for czech)
	string encoding = UI (_("!!!  YOUR  ENCODING  !!!"));
	// TRANSLATORS:
	// This text will be added at the end of your test-page if
	// user chooses your language. Write anything you want here.
	// Long multiline text can be here, please break your lines
	// at 80 characters.
	// This text will be visible only if user chooses your
	// language!!! If you want some text to be added in common
	// section, send me an e-mail to <pblahos@suse.cz>. Your
	// text must contain encoding and text. e.g.:
	// ISO-8859-1: Some text in your language.
	// ONLY ONE LINE PLEASE
	string special_text = UI (_("!!!  YOUR  TEXT  !!!"));
	// TRANSLATORS:
	// Ascii Test Page now contains only English explanation:
	// Following lines contain characters in various encodings.  You can check if your
	// selection works properly.
	// If you are English, do not translate it!
	// If you translate it, it must be in encoding "!!!  YOUR  ENCODING !!!".
	// Please break lines at 80 characters. DO NOT USE DIACRITICS (UMLAUTS/ACCENTS).
	// It is possible, that proper encoding is not chosen when printing the
	// test page.
	// ONLY ONE LINE PLEASE. IF YOU WANT MORE LINES, PLEASE USE \\n
	string common_text = UI (_("!!! COMMON  EXPLANATION !!!"));


	string out_file = SCR::Read (.target.tmpdir) + "/testpg.ascii";
	string c_text = "";
	string s_text = "";
	if ("!!!  YOUR  ENCODING  !!!" != encoding && "" != encoding)
	    {
		if ("!!!  YOUR  TEXT  !!!" != special_text && "" != special_text)
		    {
			s_text = UI::Recode ("utf-8", encoding, special_text);
			s_text = mergestring (splitstring (s_text, "\n"), " ");
		    }
		if ("!!! COMMON  EXPLANATION !!!" != common_text && "" != common_text)
		    {
			c_text = UI::Recode ("utf-8", encoding, common_text);
			c_text = mergestring (splitstring (c_text, "\n"), " ");
		    }
	    }
    // test the distribution
    // could be done by
    // if (Product::baseproduct == "UnitedLinux")
    string path_to_testpage = "";
    if (SCR::Read(.target.stat, baseDataDir + "/ul_testpg.ascii") == $[])
        path_to_testpage = baseDataDir + "/suse_testpg.ascii";
    else
        path_to_testpage = baseDataDir + "/ul_testpg.ascii";

	// now we have texts to replace.
	SCR::Execute (
	    .target.bash,
	    sformat (
		"/bin/cat %1 | /bin/sed -e \"s/~common~explanation~/%2/\" -e \"s/~special~text~/%3/\" > %4",
        path_to_testpage, c_text, s_text, out_file));
	return out_file;
    }
    /**
     * Prepare test page
     * @param queue queue name
     * @param opt_file file with options got from printerdb agent, Write (.testpg_options, ...)
     * @param PS_printer is the tested printer PS? Do not print image there.
     * @return filename of the test page
     */
    global define string preparePsTestPage (string queue, string opt_file, boolean PS_printer) ``{
	string out_file = SCR::Read (.target.tmpdir) + "/testpg.ps";
    // test the distribution
    string path_to_testpage = "";

    if (SCR::Read(.target.stat, baseDataDir + "/ul_testpg.ps") == $[])
        path_to_testpage = baseDataDir + "/suse_testpg.ps";
    else
        path_to_testpage = baseDataDir + "/ul_testpg.ps";

    y2debug("template test file to print: %1", path_to_testpage);

	SCR::Execute (.target.bash, sformat (
"/bin/awk -v SKIPPICTURE=\"%5\" '
      BEGIN { COPY = 1 }
      /^----X-VENDOR:/		{ $1 = \"\"; ARRAY[\"vendor\"] = $0; 	next;	}
      /^----X-QUEUE-L:/		{ $1 = \"\"; ARRAY[\"queue\"] = $0; 	next;	}
      /^----X-PRINTER-L:/ 	{ $1 = \"\"; ARRAY[\"printer\"] = $0; 	next;	}
      /^----X-CONFIG-L:/ 	{ $1 = \"\"; ARRAY[\"configl\"] = $0;	next;	}
      /^----X-OPTION-L:/ 	{ $1 = \"\"; ARRAY[\"option\"] = $0; 	next;	}
      /^----X-HEAD:/ 		{ $1 = \"\"; ARRAY[\"head\"] = $0;	next;	}
      /^----X-ENCODING:/ 	{ $1 = \"\"; ARRAY[\"encoding\"] = $0;	next;	}
      /^----X-CONFIG:/ 		{ $1 = \"\"; ARRAY[\"config\"] = $0; 	next;	}
 
      // { if (FILENAME !~ /suse_testpg.ps$/ && FILENAME !~ /ul_testpg.ps$/)
      		next;
      }
      /\~\~BEGIN\~\~OPTIONAL\~\~PICTURE\~\~/ { COPY=0 }
      /\~\~END\~\~OPTIONAL\~\~PICTURE\~\~/   { COPY=1 }
      COPY == 0 && SKIPPICTURE == \"true\"   { next } 

      /\~\~QUEUE\~\~/ { sub (/\~\~QUEUE\~\~/, \"%1\", $0); print $0; next; }
      /\~\~MODEL\~\~/ {
      		if (length (ARRAY[\"vendor\"]) > 0)	print ARRAY[\"vendor\"];
		else					print $0;
		next;
      }
      /\~\~QUEUE\~L\~\~/ {
      		if (length (ARRAY[\"queue\"]) > 0)	print ARRAY[\"queue\"];
		else					print $0;
		next;
      }
      /\~\~PRINTER\~L\~\~/ {
      		if (length (ARRAY[\"printer\"]) > 0)	print ARRAY[\"printer\"];
		else					print $0;
		next;
      }
      /\~\~CONFIG\~L\~\~/ {
      		if (length (ARRAY[\"configl\"]) > 0)	print ARRAY[\"configl\"];
		else					print $0;
		next;
      }
      /\~\~OPTIONS\~L\~\~/ {
      		if (length (ARRAY[\"option\"]) > 0)	print ARRAY[\"option\"];
		else					print $0;
		next;
      }
      /\~\~Y2TP\~L\~\~/ {
      		if (length (ARRAY[\"head\"]) > 0)	print ARRAY[\"head\"];
		else					print $0;
		next;
      }
      /\~\~CHANGE\~ENCODING\~\~/ {
      		if (length (ARRAY[\"encoding\"]) > 0)	print ARRAY[\"encoding\"];
		else					print $0;
		next;
      }
      /\~\~CONFIG\~\~/ {
      		if (length (ARRAY[\"config\"]) > 0)	print ARRAY[\"config\"];
		else					print $0;
		next;
      }
      /\~\~\~PASTE\~OPTIONS\~HERE\~\~\~/ {
          system (\"/usr/bin/grep -v -e ^----X- %2\");
          next;
      }
      { print $0; }
' %2 %3 > %4", queue, opt_file, path_to_testpage, out_file, PS_printer));
	return out_file;
    }

    /**
     * Return true if user id is 0 (user is root).
     * @return true if yast2 was run by root.
     */
    global define boolean amIRoot () ``{
/*	map ret = SCR::Execute (.target.bash_output, "/usr/bin/whoami");
	if (0 == lookup (ret,"exit", 0))
	    {
		return lookup (ret, "stdout", "") == "root\n";
	    }*/

	map ret = SCR::Execute (.target.bash_output, "/usr/bin/id");
	if (0 == ret["exit"]:0)
	{
	    string out = ret["stdout"]:"";
	    return issubstring (out, "uid=0(");
	}

	// otherwise there was a trouble running whoami so we assume we are root
	// so user can continue
	return true;
    }

    /**
     * Test device by sending hello world to it. See test_device for details.
     * @param dev device to test (/dev/lp0)
     */
    global define void testDevice (string dev) ``{
        if (Mode::config)
        {
            DisplayUnavailableAIPopup ();
            return;
        }
	UI::MessagePopup (sformat (textTestDevice (), 10));
	integer tst = SCR::Execute (.target.bash,
				   sformat ("/usr/lib/YaST2/bin/test_device \"\\rHello, world\\r\\f\" %1 %2", dev, 10));

	UI::MessagePopup (textTestDeviceResult (tst));
    };
    /**
      * Test remote queue accessibility if username and password needed
      * @param hname string hostname of remote host
      * @param rname string name of remote queue
      * @param user string username to access remote queue
      * @param pass string password to access remote queue
      * @param type string "samba" or "novell"
      */
    global define void testRemoteUP (string hname, string rname, string user, string pass, string type) ``{
	if (Mode::config)
	{
	    DisplayUnavailableAIPopup ();
	    return;
	}
	UI::OpenDialog (`opt (`decorated), `Label (sformat (textTestRemotePrinter (false), hname)));
	map test_return = $[];
	if ("samba" == type)
	    test_return = SCR::Execute (.target.bash_output, sformat ("/usr/lib/YaST2/bin/test_remote_smb \"%1\" \"%2\" \"%3\" \"%4\" 5", hname, rname, user, pass));
	else if ("novell" == type)
	    test_return = SCR::Execute (.target.bash_output, sformat ("/usr/lib/YaST2/bin/test_remote_novell \"%1\" \"%2\" \"%3\" \"%4\" 5", hname, rname, user, pass));
	integer tst = lookup (test_return, "exit", 0);
	string message = textTestRemotePrinterResult (tst);
	if (4 == tst)
	{
	    message = message + lookup (test_return, "stdout", "");
	}
	UI::CloseDialog ();
	UI::MessagePopup (message);
    };

    /**
     * Test of the connection. See test_remote_lpd for details.
     * @param hname host name
     * @param rname name of remote queue
     * @param type queue type
     * @param port TCP port
     */
    global define void testRemote (string hname, string rname, string type, integer port) ``{
        if (Mode::config)
        {
	    DisplayUnavailableAIPopup ();
            return;
        }
	boolean ping_only = "filtering" != type && "lpd" != type && "prefilter" != type && "ipp" != type && "socket" != type && "ipp_server" != type;
	UI::OpenDialog (`opt (`decorated), `Label (sformat (textTestRemotePrinter (ping_only), hname)));

	string test_command = sformat ("/bin/ping -c 1 \"%1\"", hname);
	if (!ping_only)
	{
	    if (type == "ipp_server")
		test_command = sformat ("/usr/lib/YaST2/bin/test_remote_ipp \"%1\" \"%2\" 5", hname, "unexistent");
	    else if (type == "ipp")
		test_command = sformat ("/usr/lib/YaST2/bin/test_remote_ipp \"%1\" \"%2\" 5", hname, rname);
	    else if (type == "socket")
		test_command = sformat ("/usr/lib/YaST2/bin/test_remote_socket \"%1\" %2 5", hname, port);
	    else
		test_command = sformat ("/usr/lib/YaST2/bin/test_remote_lpd \"%1\" \"%2\" 5", hname, rname);
	}

	map test_return = SCR::Execute (.target.bash_output, test_command);
	integer tst = lookup (test_return, "exit", 0);
	if (4 == tst && type == "ipp_server")
	    tst = 0;
	string message = textTestRemotePrinterResult (tst);
	if (4 == tst)
	    {
		message = message + lookup (test_return, "stdout", "");
	    }
	UI::CloseDialog ();
	UI::MessagePopup (message);
    }

    /**
     * Test which spooling system is most probably used.
     * @return integer with some bits set:<br>
     *    1 if lpd is installed<br>
     *    2 if cups is installed<br>
     *      (therefore 0 if none is installed)<br>
     *      (therefore 3 if both are installed)<br>
     *  256 is added if the instalation doesn't seem to be complete
     */
    global define integer getSpoolSystem () ``{
	initTarget ();
	// first try if some of the systems exists.
	boolean cups_exists = Pkg::IsProvided ("cups-client");
	// for lpd we need to check the file because
	boolean lpd_exists = (SCR::Read(.target.size, "/etc/init.d/lpd")!=-1);
	boolean cups_complete = Pkg::IsProvided ("cups-drivers")
	    && Pkg::IsProvided ("cups-libs")
	    && Pkg::IsProvided ("cups")
	    && Pkg::IsProvided ("cups-client");
	boolean lpd_complete = Pkg::IsProvided ("lpdfilter")
            && Pkg::IsProvided ("filters");

	if (cups_exists && !lpd_exists)
	    {
		if (cups_complete)
		    return 2;
		else
		{
		    boolean cups_client = Pkg::IsProvided ("cups-libs") && ! Pkg::IsProvided ("cups");
		    if (cups_client)
			return 512 + 2;
		    else
			return 256 + 2;
		}
	    }
	if (!cups_exists && lpd_exists)
	    {
		if (lpd_complete)
		    return 1;
		else
		    return 256 + 1;
	    }
	if (cups_exists && lpd_exists)
	    {
		return 3;
	    }
	return 0;
    }
    /**
      * stop currently running printer spooler service
      */
    global define void stopServices () ``{
	if (Mode::config)
	    return;
	if (Pkg::IsProvided ("plp"))
	    SCR::Execute (.target.bash, "test -f /etc/init.d/lpd && /etc/init.d/lpd stop");
	if (Pkg::IsProvided ("lprold"))
	    SCR::Execute (.target.bash, "test -f /etc/init.d/lpd && /etc/init.d/lpd stop");
	if (Pkg::IsProvided ("lprng"))
	    SCR::Execute (.target.bash, "test -f /etc/init.d/lpd && /etc/init.d/lpd stop");
	if (Pkg::IsProvided ("cups"))
	    SCR::Execute (.target.bash, "test -f /etc/init.d/cups && /etc/init.d/cups stop");
    }

    /**
     * Uninstalls print spoolers and installs selected one.
     * Stops all spoolers before installation.
     * @param to Spooler to install. Should be one of "cups" "lprold" "plrng "plp"
     */
    global define void switchTo (string to) ``{
	list del = ["plp", "lprold", "lprng", "cups", "cups-client",
            "cups-drivers", "cups-drivers-cs", "cups-drivers-de",
            "cups-drivers-stp", "lpdfilter", "filters"];
	list inst = [];

        if ("cups" == to)
        {
            inst = [ "cups", "cups-drivers", "cups-client", "cups-drivers-stp",
		"filters"];
        }
        else if ("cups_client" == to)
        {
            inst = [ "cups-client"];
        }
        else
        {
            inst = [ to, "filters", "lpdfilter"];
        }
	del = filter (`e, del, ``(! contains (inst, e)));

	if (Mode::config)
	{
	    Printer::spooler = to;
	    import "Require";
	    Require::RequireAndConflictTarget (inst, del, "");
	    if (Printer::spooler == "cups" && Printer::db == "foomatic")
		Require::RequireAndConflict (inst, del, _("For the selected function, the additional packages
%1
must be installed.

Install them now?"));
	    return;
	}
	stopServices ();
	Runlevel::ServiceAdjust ("lpd", "disable");
	Runlevel::ServiceAdjust ("cups", "disable");
	del = filter (`e, del, ``(Pkg::IsProvided (e) == true));
	import "PackageCallbacks";
	y2milestone("-------- deleting = %1", del);
	foreach (`e, del, ``{Pkg::PkgDelete (e);});
	y2milestone("-------- installing = %1", inst);
	foreach (`e, inst, ``{Pkg::PkgInstall (e);});
	Pkg::PkgSolve ();
	Pkg::PkgCommit (0);
	WFM::CallModule("inst_suseconfig", []);
    }
    /**
     * Printer uri = type://device
     * where type is one of parallel, serial, usb, file, lpd, prefilter, novell,
     *   samba, ipp, socket, http
     * and device is depending on the type. For parallel, serial, usb, file
     * it is file name. For lpd it is server/queue. For prefilter it is queue.
     * For socket it is server, for ipp, http it is server/path_to_queue, for
     * samba, novell it is user:pass@server/queuename (user, pass is
     * optional).
     *
     * Get type of printer from uri. (First part of uri before colon)
     * @param uri printer uri (file://tmp/pr.tmp, lpd://d11.suse.de)
     * @return string type of printer or ""
     */
    global define string getUriType (string uri) ``{
	if ("" == uri || nil == uri)
	    return "";
	string s = select (splitstring (uri, ":"), 0, "");
	if ("http" == s)
	    s = "ipp";
	return s;
    }
    /**
     * Get printer device from its uri.
     * @param uri printer uri
     * @return string device
     * @see getUriType
     */
    global define string getUriDevice (string uri) ``{
	if ("" == uri || nil == uri || nil == findfirstof (uri, ":"))
	    return "";
	string uri_type = getUriType (uri);
	integer i = findfirstof (uri, ":");
	if (nil == i)
	    return "";
	uri = substring (uri, i + 1);
	if (uri_type != "usb")
	    while ("//" == substring (uri, 0, 2))
		uri = substring (uri, 1);
	i = findfirstof (uri, "?");
	if (nil != i && uri_type != "usb")
	    uri = substring (uri, 0, i);
	return uri;
    }
    /**
     * Get printer remote queue. Input to this function must be valid
     * because it just takes the part of uri after the last slash.
     * Should be used for: lpd, prefilter, novell, samba, http/ipp.
     * For prefilter it works, but is misnamed.
     * @param uri printer uri
     * @return remote queue
     * @see getUriType
     */
    global define string getUriRemoteQueue (string uri) ``{
	if (nil == uri || "" == uri)
	    return "";
	integer i = findfirstof (uri, "/");
	if (nil == i)
		return "";
	string s = substring (uri, i + 1);
        if (substring (s, 0, 1) == "/")
            s = substring (s, 1);
        i = findfirstof (s, "/");
        if (nil == i)
            return s;
        return substring (s, i + 1);
    }
    /**
      * Get port number from URI.
      * @param uri printer uri
      * @return integer port
      */
    global define integer getUriPort (string uri) ``{
	integer port = 0;
        string dev = getUriDevice (uri);
        if ("" == dev)
            return 0;
        dev = substring (dev, 1);
        // is there a user@pass?
        integer i = findfirstof (dev, "@");
        if (nil != i)
            dev = substring (dev, i + 1);
        i = findfirstof (dev, "/");
        if (nil != i)
            dev = substring (dev, 0, i);
        i = findfirstof (dev, ":");
        if (nil != i)
	{
            dev = substring (dev, i + 1);
	    while ("0" == substring (dev, 0, 1))
		dev = substring (dev, 1);
	    if (dev == "")
		dev = 0;
	    port = tointeger (dev);
	}
        return port;


    }
    /**
     * Get printer baud rate from uri. Applies to serial printers only.
     * Does not check if passed uri belongs to serial printer.
     * @param uri printer uri
     * @return baud rate
     * @see getUriType
     */
    global define integer getUriBaudrate (string uri) ``{
	return tointeger (getUriValue (uri, "baudrate"));// not defined for ""
    }
    /**
     * Get any parameter from uri. Suppose uri has form:
     * method://user:pass@address/path?key=value+key=value+key=value
     * @param uri printer uri
     * @param key key to extract
     * @return value
     */
    global define string getUriValue (string uri, string key) ``{
	key = key + "=";
	integer i = find (uri, "+" + key);
	if (-1 == i)
	    i = find (uri, "?" + key);
	if (-1 == i)
	    return "";
	string val = substring (uri, i + size (key) + 1);
	i = findfirstof (val, "+");
	if (nil != i)
	    val = substring (val, 0, i);
	return val;
    }
    /**
     * Get host name from uri. Applies to lpd, novell, samba, ipp/http,
     *   socket
     * @param uri printer uri
     * @return hostname
     * @see getUriType
     */
    global define string getUriHost (string uri) ``{
	string dev = getUriDevice (uri);
	if ("" == dev)
	    return "";
	dev = substring (dev, 1);
	// is there a user@pass?
	integer i = findfirstof (dev, "@");
	if (nil != i)
	    dev = substring (dev, i + 1);
	i = findfirstof (dev, "/");
	if (nil != i)
	    dev = substring (dev, 0, i);
	i = findfirstof (dev, ":");
        if (nil != i)
            dev = substring (dev, 0, i);

	return dev;
    }
    /**
     * Get uri user name and password. Applies to samba, novell.
     * @param uri printer uri
     * @return [ username, password ]
     * @see getUriType
     */
    global define list getUriUsernamePass (string uri) ``{
	if (size (uri) < 8)
	    return [ "", "" ];
	uri = substring (uri, 8);
	while ("/" == substring (uri, 0, 1))
	    uri = substring (uri, 1);
	integer len = findfirstof (uri, "@");
	if (nil == len)
	    return [ "", "" ];
	string user = substring (uri, 0, len);
	string pass = "";
	len = findfirstof (user, ":");
	if (nil != len)
	{
	    pass = substring (user, len + 1);
	    user = substring (user, 0, len);
	}
	return [ user, pass, ];
    }
    /**
     * Get nice name for printer uri
     * @param uri printer uri
     * @return nice name of printer uri (device, network printer...)
     */
    global define string getUriNiceName (string uri) ``{
	string type = getUriType (uri);
	if ("parallel" == type)
	    // Parallel printer on /dev/lp0
	    return sformat (_("Parallel printer on %1"), getUriDevice (uri));
	if ("serial" == type)
	{
	    string dev = getUriDevice (uri);
	    integer i = findfirstof (dev, "?");
	    if (nil != i)
		dev = substring (dev, 0, i);
	    // Serial printer on /dev/lp0
	    return sformat (_("Serial printer on %1"), dev);
	}
	if ("usb" == type)
	{
	    string dev = getUriDevice (uri);
	    integer i = findfirstof (dev, "?");
	    if (nil != i)
		dev = substring (dev, 0, i);
	    // USB printer on /dev/lp0
	    return sformat (_("USB printer on %1"), getUriDevice (uri));
	}
	if ("file" == type)
	    // Disk file /tmp/printer.pdf
	    return sformat (_("Disk file %1"), getUriDevice (uri));
	if ("pipe" == type)
	    // Prograam to get job on stdin
	    return sformat (_("Program %1"), getUriDevice (uri));
	if ("lpd" == type)
	    // Forwarding queue to QUEUENAME on LPD server SERVERNAME
	    return sformat (_("Forwarding queue to %1 on LPD server %2"), getUriRemoteQueue (uri), getUriHost (uri));
	if ("irda" == type)
            // Forwarding queue to QUEUENAME on LPD server SERVERNAME
            return sformat (_("IrDA printer on %1"), getUriDevice (uri));
	if ("prefilter" == type)
	    // Prefilter queue for QUEUENAME
	    return sformat (_("Prefilter queue for %1"), getUriRemoteQueue (uri));
        if ("filtering" == type)
            // Prefilter queue for QUEUENAME
            return sformat (_("Filtering forwarding queue to %1 on LPD server %2"), getUriRemoteQueue (uri), getUriHost (uri));
	if ("novell" == type)
	    // Queue QUEUENAME on novell server SERVERNAME
	    return sformat (_("Queue %1 on Novell server %2"), getUriRemoteQueue (uri), getUriHost (uri));
	if ("samba" == type)
	    // Queue QUEUENAME on SMB server SERVERNAME
	    return sformat (_("Queue %1 on SMB server %2"), getUriRemoteQueue (uri), getUriHost (uri));
	if ("ipp" == type || "http" == type)
	    // Queue QUEUENAME on IPP server SERVERNAME
	    return sformat (_("Queue %1 on IPP server %2"), getUriRemoteQueue (uri), getUriHost (uri));
	if ("socket" == type)
	    // Network printer HOSTNAME
	    return sformat (_("Direct TCP port printer %1"), getUriHost (uri));
	if ("class" == type)
	    // CUPS class
	    return _("CUPS class");
	// Unknown printer AnYtHiNg
	return sformat (_("Unknown printer %1"), uri);
    }
    /**
     * Get nice name of some device.
     * @param dev device
     * @param detected boolean set to true if displaying detected dialog
     * @return device nice name
     */
    global define string getDeviceNiceName (string dev, boolean detected) ``{
	if (regexpmatch (dev, "//.*?serial=.*")
	    && SCR::Read (.target.size, "/usr/lib/cups/backend/usb") > 0)
	{
	    y2milestone ("USB printer %1", dev);
	    setCupsUsbDevicesInfo ();
/*	    string serial = regexpsub (dev, ".*?(serial=.*)", "\\1");
	    y2milestone ("Serial: %1", serial);
	    if (serial != nil && serial != "")
	    {
		return sformat (_("USB port (%1)"), serial);
	    }*/
	    string ret = "";
	    foreach (`e, cups_usb_devices, ``{
		if (e[0]:"" == dev)
		    ret = e[1]:"";
	    });
	    if (detected)
		ret = "USB";
	    if (ret != "" && ret != nil)
		return sformat ("%1 (%2)", ret, dev);
	}
	return lookup ($[
	    // Names of devices. Labels in dialog
	    "/dev/lp0" : _("First Parallel Port (/dev/lp0)"),
	    // Names of devices. Labels in dialog
	    "/dev/lp1" : _("Second Parallel Port (/dev/lp1)"),
	    // Names of devices. Labels in dialog
	    "/dev/lp2" : _("Third Parallel Port (/dev/lp2)"),
	    // Names of devices. Labels in dialog
	    "/dev/lp3" : _("Fourth Parallel Port (/dev/lp3)"),

	    // Names of devices. Labels in dialog
	    "/dev/ttyS0" : _("First Serial Port (/dev/ttyS0)"),
	    // Names of devices. Labels in dialog
	    "/dev/ttyS1" : _("Second Serial Port (/dev/ttyS1)"),
	    // Names of devices. Labels in dialog
	    "/dev/ttyS2" : _("Third Serial Port (/dev/ttyS2)"),
	    // Names of devices. Labels in dialog
	    "/dev/ttyS3" : _("Fourth Serial Port (/dev/ttyS3)"),

	    // Names of devices. Labels in dialog
	    "/dev/usb/lp0" : _("First USB Printer (/dev/usb/lp0)"),
	    // Names of devices. Labels in dialog
	    "/dev/usb/lp1" : _("Second USB Printer (/dev/usb/lp1)"),
	    // Names of devices. Labels in dialog
	    "/dev/usb/lp2" : _("Third USB Printer (/dev/usb/lp2)"),
	    // Names of devices. Labels in dialog
	    "/dev/usb/lp3" : _("Fourth USB Printer (/dev/usb/lp3)"),
	    // Names of devices. Labels in dialog
	    "/dev/usb/lp4" : _("Fifth USB Printer (/dev/usb/lp4)"),
	    // Names of devices. Labels in dialog
	    "/dev/usb/lp5" : _("Sixth USB Printer (/dev/usb/lp5)"),
	    // Names of devices. Labels in dialog
	    "/dev/usb/lp6" : _("Seventh USB Printer (/dev/usb/lp6)"),
	    // Names of devices. Labels in dialog
	    "/dev/usb/lp7" : _("Eighth USB Printer (/dev/usb/lp7)"),
            // Names of devices. Labels in dialog
            "/dev/usb/lp8" : _("Ninth USB Printer (/dev/usb/lp8)"),
            // Names of devices. Labels in dialog
            "/dev/usb/lp9" : _("Tenth USB Printer (/dev/usb/lp9)"),
            // Names of devices. Labels in dialog
            "/dev/usb/lp10" : _("Eleventh USB Printer (/dev/usb/lp10)"),
            // Names of devices. Labels in dialog
            "/dev/usb/lp11" : _("Twelfth USB Printer (/dev/usb/lp11)"),
            // Names of devices. Labels in dialog
            "/dev/usb/lp12" : _("Thirteenth USB Printer (/dev/usb/lp12)"),
            // Names of devices. Labels in dialog
            "/dev/usb/lp13" : _("Forteenth USB Printer (/dev/usb/lp13)"),
            // Names of devices. Labels in dialog
            "/dev/usb/lp14" : _("Fifteenth USB Printer (/dev/usb/lp14)"),
            // Names of devices. Labels in dialog
            "/dev/usb/lp15" : _("Sixteenth USB Printer (/dev/usb/lp15)"),
	    ], dev, dev);
    }
    /**
     * Change parallel port settings. This function must be called when
     * wizard dialog has been set up. Hence it suppose Wizard library to
     * be imported.
     * @return symbol for wizard sequencer
     */
    global define symbol editParallelPort () ``{
	map params = SCR::Read (.modules.options, "parport_pc");
	// dialog caption
	Wizard::SetContentsButtons (_("Parallel port settings"), `VBox (
		    `VStretch (),
		    // textentry label
		    `TextEntry (`id (`io), _("IO &Ports of parallel ports:"), lookup (params, "io", "")),
		    `VSpacing (2),
		    `VStretch ()
		    ),
		textEditParallelPort (), BackButtonLabel (), OKButtonLabel ());
	symbol r = UI::UserInput ();
	if (`next == r)
	{
	    string s = UI::QueryWidget (`id (`io), `Value);
	    if (nil == s || "" == s)
	    {
		params = filter (`k, `v, params, ``("io" != k));
	    }
	    else
	    {
		params = add (params, "io", s);
	    }
	    SCR::Write (.modules.options, 0 == size (params) ? nil : params, "parport_pc");
	}
	return r;
    }
    /**
     * Change serial port settings. This function must be called when
     * wizard dialog has been set up. Hence it suppose Wizard library to
     * be imported.
     * @return symbol for wizard sequencer
     */
    global define symbol editSerialPort () ``{
	string uri = lookup (Printer::printer, "tmpuri", "parallel");
	integer baudrate = Printerlib::getUriBaudrate (uri);
	string ser_settings = Printerlib::getUriValue (uri, "ty");

	term contents = `VBox (
				// combobox label
                                `ComboBox (`id (`baudent), `opt (`editable, `hstretch), _("Baud &rate:"),
                                      [ sformat ("%1", baudrate),
                                      "1200","2400", "4800", "9600", "19200", "38400", "57600", "115200"
                                      ]),
				// textentry label
                                `TextEntry (`id (`ser_settings), `opt (`hstretch), _("Serial Port &Settings"), ser_settings)
                        );

	// dialog caption
        Wizard::SetContentsButtons (_("Other settings"), contents,  textEditSerialPort (), BackButtonLabel (), NextButtonLabel ());
	symbol r = nil;
	while (r != `back && r != `abort)
	{
            r = UI::UserInput ();

	    ser_settings = UI::QueryWidget (`id (`ser_settings), `Value);
	    string tmp = UI::QueryWidget (`id (`baudent), `Value);
	    baudrate = tointeger (tmp);
	    if (`next == ret && !testBaudRate (baudrate))
		ret = nil;

            if (`next == r)
            {
		uri = "serial:" + getUriDevice (uri) + sformat ("?baudrate=%1+ty=%2", baudrate, ser_settings);
		Printer::printer = add (Printer::printer, "tmpuri", uri);
		return r;
	    }
	    if (`abort == r && ! reallyAbort ())
		r = nil;
        }
	return r;
    }
    /**
     * get paper size from system and returns 0 for a4 or 1 for letter
     * @return integer 0 for a4, 1 for letter
     */
    global define integer getDefaultPaperSize () ``{
	if (-1 != paper_size)
	    return paper_size;
	paper_size = SCR::Execute (.target.bash, "/usr/bin/locale -k LC_PAPER | /usr/bin/grep width=210");
	if (paper_size != 0 && paper_size != 1)
	    paper_size = 0;
	return paper_size;
    }
}
