/**
 * File:
 *   modules/Printerlib.ycp
 *
 * Package:
 *   Printer library.
 *
 * Summary:
 *   Some utility functions for printer conf. tools.
 *
 * Authors:
 *   Petr Blahos <pblahos@suse.cz>
 *
 * $Id$
 *
 * Printer library exported functions. What else?!?
 */

{
    module "Printerlib";
    textdomain "printer";
    import "Printer";
    include "printer/texts.ycp";
    import "Label";
    import "Popup";
    import "Runlevel";
    import "Require";
    include "printer/misc.ycp";
    import "Mode";
    import "Report";

    /**
     * set to true after function Read had been called.
     */
    global boolean proposal_valid = false;
    /**
     * System paper size, taken from system locales. 0 for a4 and 1 for
     * letter. -1 for unknown. Use function Printerlib::getDefaultPaperSize
     * for accessing this function.
     */
    symbol paper_size = nil;
    /**
      * true id Pkg::target_init was already called
      */
    boolean target_inited = false;

    /**
      * Base directory of printconf's data files
      */
    global string baseDataDir = "/usr/share/YaST2/data/printer";

    /**
      * Initialize package manager target
      */
    global define void initTarget () ``{
	if (! target_inited)
	{
	    Pkg::TargetInit ("/", false);
	    target_inited = true;
	}
    };
    /**
     * Sends sequence to wake up Epson stylus usb printers.
     * @see <a href="http://sdb.suse.de/en/sdb/html/jsmeix_print-stcXXXusb.html">Installing an Epson Stylus Color Printer on USB</a>
     * @param device Device to send sequence to. Should be /dev/usblp? (or /dev/usb/lp?)
     */
    define void wakeUpEpson (string device) ``{
	string sequence =
	    "\"\\000\\000\\000\\033\\001\\100\\105\\112\\114\\040\\061\\062\\070\\064\\056\\064\\012\\100\\105\\112\\114\\040\\040\\040\\040\\040\\012\"";
	if (haskey (SCR::Read (.proc.modules), "printer"))
	    SCR::Execute (.target.bash, sformat ("
MAIN_PID=$$
{/bin/echo -en %1 > %2 ; kill MAIN_PID} &
ECHO_PID=$!
{sleep 2s ; kill $ECHO_PID &>/dev/null ; } &", sequence, device));
    }

    /**
      * List of CUPS USB device names
      * Contains lists of [<cups_device>, <model_name>, <unix_device>]
      */
    global list(list(string)) cups_usb_devices = [];

    /**
      * Set list of CUPS USB devices
      */
    global define void setCupsUsbDevicesInfo () ``{
	cups_usb_devices = [];
	if (SCR::Read (.target.size, "/usr/lib/cups/backend/usb") <= 0)
	    return;
	map out = SCR::Execute (.target.bash_output,
	    "/usr/lib/cups/backend/usb");
	list(string) lines = splitstring (out["stdout"]:"", "\n");
	lines = filter (`l, lines, ``(l != "" && l != nil));
	integer counter = 0;
	foreach (`l, lines, ``{
	    string model = regexpsub (l, "[^\"]*\"([^\"]*)\".*", "\\1");
	    string c_dev = regexpsub (l, "direct usb:([^ ]*) .*", "\\1");
	    string u_dev = sformat ("/dev/usb/lp%1", counter);
	    if (Printer::cups_usb_dev_names == `never
		|| (Printer::cups_usb_dev_names == `serial
		    && ! issubstring (c_dev, "serial")))
		c_dev = u_dev;
	    cups_usb_devices = add (cups_usb_devices,
		[c_dev, model, u_dev]);
	    counter = counter + 1;
	});
    }

    /**
      * Get problematic CUPS USB devices names
      * @return a list of strings with problematic device names
      */
    global define list(string) getProblematicCupsUsbDevices () ``{
	list c_devs = maplist (`e, cups_usb_devices, ``(e[0]:""));
	c_devs = filter (`d, c_devs, ``(d != ""));
	if (size (c_devs) == size (toset (c_devs)))
	    return [];
	list tested = [];
	list problematic = [];
	foreach (`d, c_devs, ``{
	    if (contains (tested, d))
		problematic = add (problematic, d);
	    tested = add (tested, d);
	});
	return toset (problematic);
    }

    /**
      * Get info about device connected to USB port from CUPS backed
      * @param device string USB device to examine
      * @return a list containing CUPS device name, Printer model and
      *   UNIX-like device
      */
    global define list(string) getCupsUsbDeviceInfo (string device) ``{
        if (SCR::Read (.target.size, "/usr/lib/cups/backend/usb") > 0)
        {
            integer pos = find (device, "lp");
            string dev_num = substring (device, pos + 2);
            if (dev_num != "")
            {
		setCupsUsbDevicesInfo ();
                integer num = tointeger (dev_num);
		y2milestone ("USB backend for device: %1", cups_usb_devices[num]:[]);
		return cups_usb_devices[num]:[];
            }
        }
	return [];
    }

    /**
      * Get URI of ptal device
      * @param model string device model identification
      * @return ptal uri or nil if no ptal device found
      */
    global define string getPtalUri (string model) ``{
	list(list(string)) devices = getPtalDevices ();
	string ret = nil;
	foreach (`d, devices, ``{
	    if (d[1]:"" == model)
		ret = sformat ("ptal:%1", d[0]:"");
        });
	return ret;
    }

    /**
      * Get list of all PTAL devices
      * @return list of PTAL devices
      */
    global define list getPtalDevices () ``{
	SCR::Execute (.target.bash, "test -f /usr/sbin/ptal-init && /usr/sbin/ptal-init setup-usb >/dev/null 2>&1");
        if (SCR::Read (.target.size, "/usr/lib/cups/backend/ptal") <= 0)
            return [];
        map out = SCR::Execute (.target.bash_output,
            "/usr/lib/cups/backend/ptal");
        list(string) lines = splitstring (out["stdout"]:"", "\n");
        lines = filter (`l, lines, ``(l != "" && l != nil));
	list ptal_devs = maplist (`l, lines, ``{
            string ptal_model = regexpsub (l, "[^\"]*\"([^\"]*)\".*", "\\1");
            string ptal_dev = regexpsub (l, "direct ptal:([^ ]*) .*", "\\1");
	    if (ptal_dev != nil && ptal_model != nil)
		return [ptal_dev, ptal_model];
	    else
		return nil;
	});
	ptal_devs = filter (`pd, ptal_devs, ``(pd != nil));
	y2milestone ("ptal devices: %1", ptal_devs);
	return ptal_devs;
    }

    /**
      * Get all CUPS-like USB device names
      * @return a list of CUPS USB device names
      */
    global define list(string) getCupsUsbDevices () ``{
	setCupsUsbDevicesInfo ();
	list ret = maplist (`e, cups_usb_devices, ``(e[0]:""));
	return ret;
    }

    /**
     * Calls escputil to find out exact model of Epson stylus printer.
     * @param device USB Device to examine.
     * @return string Printer model. If unsuccessful, returns "Stylus".
     */
    define string getEpsonUsbModel (string device) ``{
	// we must wake Epson first
	wakeUpEpson (device);
	// now we can run escputil

	string model = select (getCupsUsbDeviceInfo (device), 1, "");
	if (substring (model, 0, 6) == "EPSON ")
	    model = substring (model, 6);
	return model;
    }

    /**
     * Finally detection of hardware
     * @param cups true if usb devices should be in form /dev/usb/lp?vendor=04a9&prod_id=1052
     * @return list Detected printers. See example.
     * @example
     *  Return:
     *   [
     *       $[
     *           "vendor"       : "...",
     *           "device"       : "...",
     *           "unique_key"   : "...",
     *           "dev_name"     : "...", // "/dev/lp0", "/dev/usblp0", ...
     *           "bus"          : "...", // "usb", "parallel"
     *       ], ...
     *   ]
     */
    global define list Detect (boolean cups) ``{
	boolean have_usb = false;
	if (Mode::config)
	{
	    DisplayUnavailableAIPopup ();
	    return [];
	}
	// load hotplug_usb if it is not (there is no way to find out whether hotplug_usb is runing so just start it)
	SCR::Execute (.target.bash,
	    "test -f /etc/init.d/hotplug_usb && (test -d proc/bus/usb/001 || /etc/init.d/hotplug_usb start)");
	list aprobe = SCR::Read (.probe.printer);
/*		aprobe = [
		    $[ "bus" : "Parallel",      // recognized, found in db
		     "dev_name" : "/dev/lp0",
		     "vendor" : "Hewlett-Packard",
		     "device" : "HP LaSerJeT 4050",
		     "unique_key"   : "lp0_hp" ],
		    $[ "bus" : "USB",      // not found in db
		     "dev_name" : "/dev/usblp1",
		     "sub_vendor" : "Epson",
		     "sub_device" : "BJC-6100x",
		     "unique_key"   : "usb_canon" ],
		    $["bus" : "Parallel",	// in db, GDI, but supported
		    "dev_name" : "/dev/lp1",
		    "vendor" : "HEWLETT-PACKARD",
		    "device" : "DeskJet 820C",
		    "unique_key" : "lp1_hp_gdi",
		    ],
		    $[ "bus" : "Parallel",      // found in db but GDI, so not configurable
		     "dev_name" : "/dev/lp2",
		     "vendor" : "Lexmark",
		     "device" : "Lexmark Z12",
		     "unique_key" : "lp2_canon" ],
		    ];*/
/*		aprobe = [
		    $[ "bus" : "Parallel",
		    "dev_name" : "/dev/lp0",
		    "vendor" : "Hewlett-Packard",
		    "device" : "DeS-kJeT-990C",]
		];*/
	if (0 == size (aprobe))
	    {
		return [];
	    }
	list ret = maplist (`pr, aprobe, ``{
	    map record = $[];
	    string bus = lookup (pr, "bus", "");
	    string unique_key = "";

	    if ("Parallel" == bus)
	    {
		record = $[
		    "vendor" : lookup (pr, "vendor", ""),
		    "device" : lookup (pr, "device", ""),
		    "unique_key": lookup (pr,"unique_key",""),
		    "bus" : "parallel",
		    "dev_name": lookup (pr, "dev_name", ""), // device <dev>
		    ];
	    }
	    else if  ("USB" == bus)
	    {
		have_usb = true;
		if (0 !=  SCR::Execute (.target.bash, "grep '^printer ' /proc/modules"))
		    return $[];
		if ("epson" == tolower (lookup (pr, "sub_vendor", "")))
		{
			string sub_dev = getEpsonUsbModel (lookup (pr, "dev_name", ""));
			if (sub_dev != "")
			    pr["sub_device"] = sub_dev;
		}
		string class_dev = lookup (pr, "dev_name", "");
		string dev_name = class_dev;

		if (Printer::spooler == "cups")
		{

		    dev_name = select (getCupsUsbDeviceInfo (class_dev), 0, "");
		    if (dev_name == nil || dev_name == "" || Mode::autoinst)
		    {
			dev_name = class_dev;
		    }
		}
		record = $[
		    "vendor" : lookup (pr, "sub_vendor", ""),
		    "device" : lookup (pr, "sub_device", ""),
		    "unique_key": lookup (pr,"unique_key",""),
		    "bus" : "usb",
		    "vendor_id": lookup (pr, "vendor_id",0),
		    "device_id": lookup (pr, "device_id",0),
		    "dev_name": dev_name,
		];
		if (Printer::spooler == "cups")
		{
		    if (contains (pr["requires"]:[], "hp-officeJet"))
		    {
			y2milestone ("PTAL device found");
			boolean req_ret = Require::RequireAndConflict (
			    ["hp-officeJet"],
			    [],
			    // question, %1 is package name
			    _("HP all-in-one device has been detected. For
using it as both printer and scanner,
package %1 must be installed.

Install it now?"));
			if (! req_ret && ! Require::LastOperationCanceled ())
			{
			    // error report
			    Report::Error (_("Failed to isntalled required package."));
			}
			string ptal_uri = getPtalUri (pr["model"]:"");
			if (ptal_uri != nil)
			{
			    record["uri"] = ptal_uri;
			    record["dev_name"] = substring (ptal_uri, 5);
			}
		    }
		}
	    }
	    return record;
	});
	// FIXME is this really needed?
	// if yes, hp-officeJet package should be installed
	// as it isn't in default installation, skipping this part of
	// detection and hoping hwinfo will make its job
/*	if (Printer::spooler == "cups")
	{
	    list uris = maplist (`r, ret, ``{
		return r["uri"]:nil;
	    });
	    uris = filter (string u, uris, ``(u != nil));
	    list(list(string)) ptal_devs = getPtalDevices ();
	    ptal_devs = filter (map pd, ptal_devs, ``(
		! contains (uris, sformat ("ptal:%1", pd[0]:""))
	    ));
	    foreach (map r, ptal_devs, ``{
		ret = add (ret, $[
		    "vendor" : "HP",
		    "device" : "All-in-one device",
		    "uri" : sformat ("ptal:%1", r[0]:""),
		]);
	    });
	}*/
	if (have_usb)
	{
	    if (0 !=  SCR::Execute (.target.bash, "grep '^printer ' /proc/modules"))
	    {
		y2error ("USB printer found and printer module not loaded, loading it");
		boolean probe_success = SCR::Execute(.target.modprobe, "printer", "");
		string hotplug
		    = SCR::Read (.sysconfig.hotplug.HOTPLUG_USB_STATIC_MODULES);
		y2debug ("Current hotplug: %1", hotplug);
		list(string) hplist = splitstring (hotplug, " ");
		if (! contains (hplist, "printer"))
		{
		    hplist = add (hplist, "printer");
		    hotplug = mergestring (hplist, " ");
		    y2debug ("Final hotplug: %1", hotplug);
		    SCR::Write (.sysconfig.hotplug.HOTPLUG_USB_STATIC_MODULES,
			hotplug);
		    SCR::Write (.sysconfig.hotplug, nil);
		}
		sleep (100);
		if (probe_success)
		{
		    probe_success = 0 == SCR::Execute (.target.bash, "grep '^printer ' /proc/modules");
		}
		if (probe_success)
		{
		    y2milestone ("Restarting detection");
		    ret = Detect (cups);
		    y2debug ("Redetection done");
		}
		else
		{
		    y2error ("Error occured while loading printer.o module");
		}
	    }
	}
	return ret;
    }

    /**
     * Return true if user id is 0 (user is root).
     * @return true if yast2 was run by root.
     */
    global define boolean amIRoot () ``{
	map ret = SCR::Execute (.target.bash_output, "/usr/bin/id");
	if (0 == ret["exit"]:0)
	{
	    string out = ret["stdout"]:"";
	    return issubstring (out, "uid=0(");
	}
	// otherwise there was a trouble running whoami so we assume we are root
	// so user can continue
	return true;
    }

    /**
     * Test device by sending hello world to it. See test_device for details.
     * @param dev device to test (/dev/lp0)
     */
    global define void testDevice (string dev) ``{
        if (Mode::config)
        {
            DisplayUnavailableAIPopup ();
            return;
        }
	Popup::Message (sformat (textTestDevice (), 10));
	integer tst = SCR::Execute (.target.bash,
				   sformat ("/usr/lib/YaST2/bin/test_device \"\\rHello, world\\r\\f\" %1 %2", dev, 10));

	Popup::Message (textTestDeviceResult (tst));
    };
    /**
      * Test remote queue accessibility if username and password needed
      * @param wg string workgroup for samba test
      * @param hname string hostname of remote host
      * @param rname string name of remote queue
      * @param user string username to access remote queue
      * @param pass string password to access remote queue
      * @param type string "samba" or "novell"
      */
    global define void testRemoteUP (string wg, string hname, string rname, string user, string pass, string type) ``{
	if (Mode::config)
	{
	    DisplayUnavailableAIPopup ();
	    return;
	}
	UI::OpenDialog (`opt (`decorated), `Label (sformat (textTestRemotePrinter (false), hname)));
	map test_return = $[];
	if ("samba" == type)
	    test_return = SCR::Execute (.target.bash_output, sformat ("/usr/lib/YaST2/bin/test_remote_smb \"%1\" \"%2\" \"%3\" \"%4\" \"%5\" 5", wg, hname, rname, user, pass));
	else if ("novell" == type)
	    test_return = SCR::Execute (.target.bash_output, sformat ("/usr/lib/YaST2/bin/test_remote_novell \"%1\" \"%2\" \"%3\" \"%4\" 5", hname, rname, user, pass));
	integer tst = lookup (test_return, "exit", 0);
	string message = textTestRemotePrinterResult (tst);
	if (4 == tst)
	{
	    message = message + lookup (test_return, "stdout", "");
	}
	UI::CloseDialog ();
	Popup::Message (message);
    };

    /**
     * Test of the connection. See test_remote_lpd for details.
     * @param hname host name
     * @param rname name of remote queue
     * @param type queue type
     * @param port TCP port
     */
    global define void testRemote (string hname, string rname, string type, integer port) ``{
        if (Mode::config)
        {
	    DisplayUnavailableAIPopup ();
            return;
        }
	boolean ping_only = "lpd" != type && "ipp" != type && "socket" != type && "ipp_server" != type;
	UI::OpenDialog (`opt (`decorated), `Label (sformat (textTestRemotePrinter (ping_only), hname)));

	string test_command = sformat ("/bin/ping -c 1 \"%1\"", hname);
	if (!ping_only)
	{
	    if (type == "ipp_server")
		test_command = sformat ("/usr/lib/YaST2/bin/test_remote_ipp \"%1\" \"%2\" 5", hname, "unexistent");
	    else if (type == "ipp")
		test_command = sformat ("/usr/lib/YaST2/bin/test_remote_ipp \"%1\" \"%2\" 5", hname, rname);
	    else if (type == "socket")
		test_command = sformat ("/usr/lib/YaST2/bin/test_remote_socket \"%1\" %2 5", hname, port);
	    else
		test_command = sformat ("/usr/lib/YaST2/bin/test_remote_lpd \"%1\" \"%2\" 5", hname, rname);
	}

	map test_return = SCR::Execute (.target.bash_output, test_command);
	integer tst = lookup (test_return, "exit", 0);
	if (4 == tst && type == "ipp_server")
	    tst = 0;
	string message = textTestRemotePrinterResult (tst);
	if (4 == tst)
	    {
		message = message + lookup (test_return, "stdout", "");
	    }
	UI::CloseDialog ();
	Popup::Message (message);
    }

    /**
     * Test which spooling system is most probably used.
     * @return integer with some bits set:<br>
     *    1 if lpd is installed<br>
     *    2 if cups is installed<br>
     *      (therefore 0 if none is installed)<br>
     *      (therefore 3 if both are installed)<br>
     *  256 is added if the instalation doesn't seem to be complete
     */
    global define integer getSpoolSystem () ``{
	initTarget ();
	// first try if some of the systems exists.
	boolean cups_exists = Pkg::IsProvided ("cups-client");
	// for lpd we need to check the file because
	boolean lpd_exists = (SCR::Read(.target.size, "/etc/init.d/lpd")!=-1);
	y2milestone ("CUPS exists: %1, LPD exists: %2",
	    cups_exists, lpd_exists);
	boolean cups_complete = Pkg::IsProvided ("cups-drivers")
	    && Pkg::IsProvided ("cups-libs")
	    && Pkg::IsProvided ("cups")
	    && Pkg::IsProvided ("cups-client")
	    && Pkg::IsProvided ("filters")
	    && Pkg::IsProvided ("foomatic-filters");
	boolean lpd_complete = Pkg::IsProvided ("lpdfilter")
            && Pkg::IsProvided ("filters")
	    && Pkg::IsProvided ("cups-drivers")
	    && Pkg::IsProvided ("foomatic-filters");


	if (cups_exists && !lpd_exists)
	    {
		if (cups_complete)
		    return 2;
		else
		{
		    boolean cups_client = Pkg::IsProvided ("cups-libs") && ! Pkg::IsProvided ("cups");
		    if (cups_client)
			return 512 + 2;
		    else
			return 256 + 2;
		}
	    }
	if (!cups_exists && lpd_exists)
	    {
		if (lpd_complete)
		    return 1;
		else
		    return 256 + 1;
	    }
	if (cups_exists && lpd_exists)
	    {
		return 3;
	    }
	return 0;
    }
    /**
      * stop currently running printer spooler service
      */
    global define void stopServices () ``{
	if (Mode::config)
	    return;
	SCR::Execute (.target.bash, "test -f /etc/init.d/lpd && /etc/init.d/lpd stop");
	SCR::Execute (.target.bash, "test -f /etc/init.d/cups && /etc/init.d/cups stop");
    }

    /**
     * Uninstalls print spoolers and installs selected one.
     * Stops all spoolers before installation.
     * @param to Spooler to install. Should be one of "cups" "lprold" "plrng "plp"
     */
    global define void switchTo (string to) ``{
	Printer::foomatic = nil;
	initTarget ();
	list del = ["plp", "lprold", "lprng", "cups", "cups-client",
            "cups-drivers", "cups-drivers-cs", "cups-drivers-de",
            "cups-drivers-stp", "lpdfilter", "filters", "foomatic-filters"];
	list inst = [];

	list inst_cups = [ "cups", "cups-drivers", "cups-client",
	    "cups-drivers-stp", "filters", "foomatic-filters"];
	list inst_cups_client = [ "cups-client"];
	list inst_other = [ to, "filters", "lpdfilter", "foomatic-filters",
	    "cups-drivers"];

        if ("cups" == to)
        {
            inst = inst_cups;
        }
        else if ("cups_client" == to)
        {
            inst = inst_cups_client;
	    del = filter (string d, del, ``(! contains (inst_cups, d)));
        }
        else
        {
	    inst = inst_other;
        }
	del = filter (`e, del, ``(! contains (inst, e)));

	if (Mode::config)
	{
	    Printer::spooler = to;
	    Require::RequireAndConflictTarget (inst, del, "");
	    if (Printer::spooler == "cups")
		// question popup
		Require::RequireAndConflict (inst, del, _("For the selected function, the additional packages
%1
must be installed.

Install them now?"));
	    return;
	}
	stopServices ();
	Runlevel::ServiceAdjust ("lpd", "disable");
	Runlevel::ServiceAdjust ("cups", "disable");
	del = filter (`e, del, ``(Pkg::IsProvided (e) == true));
	inst = filter (`i, inst, ``(! Pkg::IsProvided (i)));
	import "PackageCallbacks";
	y2milestone("-------- deleting = %1", del);
	foreach (`e, del, ``{Pkg::PkgDelete (e);});
	y2milestone("-------- installing = %1", inst);
	foreach (`e, inst, ``{Pkg::PkgInstall (e);});
	Pkg::PkgSolve ();
	Pkg::PkgCommit (0);
	WFM::CallModule("inst_suseconfig", []);



	Require::DoInstallAndRemove (inst, del);
	Printer::save_all = true;
	Printer::reread = true;
	Printer::sys_forbidden_names = nil;

    }
    /**
     * Printer uri = type://device
     * where type is one of parallel, serial, usb, file, lpd, novell,
     *   samba, ipp, socket, http
     * and device is depending on the type. For parallel, serial, usb, file
     * it is file name. For lpd it is server/queue.
     * For socket it is server, for ipp, http it is server/path_to_queue, for
     * samba, novell it is user:pass@server/queuename (user, pass is
     * optional).
     *
     * Get type of printer from uri. (First part of uri before colon)
     * @param uri printer uri (file://tmp/pr.tmp, lpd://d11.suse.de)
     * @return string type of printer or ""
     */
    global define string getUriType (string uri) ``{
	if ("" == uri || nil == uri)
	    return "";
	string ss = select (splitstring (uri, ":"), 0, "");
	if ("http" == ss)
	    ss = "ipp";
	return ss;
    }
    /**
     * Get printer device from its uri.
     * @param uri printer uri
     * @return string device
     * @see getUriType
     */
    global define string getUriDevice (string uri) ``{
	if ("" == uri || nil == uri || nil == findfirstof (uri, ":"))
	    return "";
	string uri_type = getUriType (uri);
	integer i = findfirstof (uri, ":");
	if (nil == i)
	    return "";
	uri = substring (uri, i + 1);
	if (uri_type != "usb")
	    while ("//" == substring (uri, 0, 2))
		uri = substring (uri, 1);
	i = findfirstof (uri, "?");
	if (nil != i && uri_type != "usb")
	    uri = substring (uri, 0, i);
	return uri;
    }
    /**
     * Get printer remote queue. Input to this function must be valid
     * because it just takes the part of uri after the last slash.
     * Should be used for: lpd, novell, samba, http/ipp.
     * @param uri printer uri
     * @return remote queue
     * @see getUriType
     */
    global define string getUriRemoteQueue (string uri) ``{
	if (nil == uri || "" == uri)
	    return "";
	integer i = findfirstof (uri, "/");
	if (nil == i)
		return "";
	string s = substring (uri, i + 1);
        if (substring (s, 0, 1) == "/")
            s = substring (s, 1);
        i = findfirstof (s, "/");
        if (nil == i)
            return s;
	s = substring (s, i + 1);
	i = findfirstof (s, "/");
	if (getUriType (uri) == "samba" && i != nil)
	{
	    s = substring (s, i + 1);
	}
        return s;
    }
    /**
      * Get port number from URI.
      * @param uri printer uri
      * @return integer port
      */
    global define integer getUriPort (string uri) ``{
	integer port = 0;
        string dev = getUriDevice (uri);
        if ("" == dev)
            return 0;
        dev = substring (dev, 1);
        // is there a user@pass?
        integer i = findfirstof (dev, "@");
        if (nil != i)
            dev = substring (dev, i + 1);
        i = findfirstof (dev, "/");
        if (nil != i)
            dev = substring (dev, 0, i);
        i = findfirstof (dev, ":");
        if (nil != i)
	{
            dev = substring (dev, i + 1);
	    while ("0" == substring (dev, 0, 1))
		dev = substring (dev, 1);
	    if (dev == "")
		dev = 0;
	    port = tointeger (dev);
	}
        return port;


    }
    /**
     * Get printer baud rate from uri. Applies to serial printers only.
     * Does not check if passed uri belongs to serial printer.
     * @param uri printer uri
     * @return baud rate
     * @see getUriType
     */
    global define integer getUriBaudrate (string uri) ``{
	string br = getUriValue (uri, "baudrate");
	if (br == "" || br != filterchars (br, "0123456789"))
	    return 0;
	return tointeger (br);
    }
    /**
     * Get any parameter from uri. Suppose uri has form:
     * method://user:pass@address/path?key=value+key=value+key=value
     * @param uri printer uri
     * @param key key to extract
     * @return value
     */
    global define string getUriValue (string uri, string key) ``{
	key = key + "=";
	integer i = find (uri, "+" + key);
	if (-1 == i)
	    i = find (uri, "?" + key);
	if (-1 == i)
	    return "";
	string val = substring (uri, i + size (key) + 1);
	i = findfirstof (val, "+");
	if (nil != i)
	    val = substring (val, 0, i);
	return val;
    }
    /**
     * Get host name from uri. Applies to lpd, novell, samba, ipp/http,
     *   socket
     * @param uri printer uri
     * @return hostname
     * @see getUriType
     */
    global define string getUriHost (string uri) ``{
	string dev = getUriDevice (uri);
	if ("" == dev)
	    return "";
	dev = substring (dev, 1);
	// is there a user@pass?
	integer i = findfirstof (dev, "@");
	if (nil != i)
	    dev = substring (dev, i + 1);
	if (getUriType (uri) == "samba")
	{
	    list uri_list = splitstring (dev, "/");
	    if (size (uri_list) >= 3)
		return uri_list[1]:"";
	}
	i = findfirstof (dev, "/");
	if (nil != i)
	    dev = substring (dev, 0, i);
	i = findfirstof (dev, ":");
        if (nil != i)
            dev = substring (dev, 0, i);

	return dev;
    }

    /**
      * Get workgroup from URI
      * @param uri string
      * @return string workgroup
      */
    global define string getUriWorkgroup (string uri) ``{
	if (getUriType (uri) != "samba")
	    return "";
        string dev = getUriDevice (uri);
        if ("" == dev)
            return "";
        dev = substring (dev, 1);
        // is there a user@pass?
        integer i = findfirstof (dev, "@");
        if (nil != i)
            dev = substring (dev, i + 1);
        if (getUriType (uri) == "samba")
	{
	    list uri_list = splitstring (dev, "/");
            if (size (uri_list) >= 3)
                return uri_list[0]:"";

	}
	return "";

    }

    /**
     * Get uri user name and password. Applies to samba, novell.
     * @param uri printer uri
     * @return [ username, password ]
     * @see getUriType
     */
    global define list getUriUsernamePass (string uri) ``{
	if (size (uri) < 8)
	    return [ "", "" ];
	uri = substring (uri, 8);
	while ("/" == substring (uri, 0, 1))
	    uri = substring (uri, 1);
	integer len = findfirstof (uri, "@");
	if (nil == len)
	    return [ "", "" ];
	string user = substring (uri, 0, len);
	string pass = "";
	len = findfirstof (user, ":");
	if (nil != len)
	{
	    pass = substring (user, len + 1);
	    user = substring (user, 0, len);
	}
	return [ user, pass, ];
    }
    /**
     * Get nice name for printer uri
     * @param uri printer uri
     * @return nice name of printer uri (device, network printer...)
     */
    global define string getUriNiceName (string uri) ``{
	string type = getUriType (uri);
	if ("parallel" == type)
	    // Parallel printer on /dev/lp0
	    return sformat (_("Parallel printer on %1"), getUriDevice (uri));
	if ("serial" == type)
	{
	    string dev = getUriDevice (uri);
	    integer i = findfirstof (dev, "?");
	    if (nil != i)
		dev = substring (dev, 0, i);
	    // Serial printer on /dev/lp0
	    return sformat (_("Serial printer on %1"), dev);
	}
	if ("usb" == type)
	{
	    string dev = getUriDevice (uri);
	    integer i = findfirstof (dev, "?");
	    if (nil != i)
		dev = substring (dev, 0, i);
	    // USB printer on /dev/lp0
	    return sformat (_("USB printer on %1"), getUriDevice (uri));
	}
	if ("ptal" == type)
	    // HP all-in-one device mlc:usb:HP_LaserJet_1220
	    return sformat (_("HP All-in-One Device %1"), getUriDevice (uri));
	if ("pipe" == type)
	    // Prograam to get job on stdin
	    return sformat (_("Program %1"), getUriDevice (uri));
	if ("irda" == type)
            // IrDA printer on /dev/irlpt0
            return sformat (_("IrDA printer on %1"), getUriDevice (uri));
        if ("lpd" == type)
            // Filtering forwarding queue to QUEUENAME on LPD server SERVERNAME
            return sformat (_("Filtering forwarding queue to %1 on LPD server %2"), getUriRemoteQueue (uri), getUriHost (uri));
	if ("novell" == type)
	    // Queue QUEUENAME on novell server SERVERNAME
	    return sformat (_("Queue %1 on Novell server %2"), getUriRemoteQueue (uri), getUriHost (uri));
	if ("samba" == type)
	    // Queue QUEUENAME on SMB server SERVERNAME
	    return sformat (_("Queue %1 on SMB server %2"), getUriRemoteQueue (uri), getUriHost (uri));
	if ("ipp" == type || "http" == type)
	    // Queue QUEUENAME on IPP server SERVERNAME
	    return sformat (_("Queue %1 on IPP server %2"), getUriRemoteQueue (uri), getUriHost (uri));
	if ("socket" == type)
	    // Network printer HOSTNAME
	    return sformat (_("Direct TCP port printer %1"), getUriHost (uri));
	if ("class" == type)
	    // CUPS class
	    return _("CUPS class");
	// Unknown printer AnYtHiNg
	return sformat (_("Unknown printer %1"), uri);
    }
    /**
     * Get nice name of some device.
     * @param dev device
     * @param detected boolean set to true if displaying detected dialog
     * @return device nice name
     */
    global define string getDeviceNiceName (string dev, boolean detected) ``{
	if (regexpmatch (dev, "//.*?serial=.*")
	    && SCR::Read (.target.size, "/usr/lib/cups/backend/usb") > 0)
	{
	    y2milestone ("USB printer %1", dev);
	    setCupsUsbDevicesInfo ();
/*	    string serial = regexpsub (dev, ".*?(serial=.*)", "\\1");
	    y2milestone ("Serial: %1", serial);
	    if (serial != nil && serial != "")
	    {
		return sformat (_("USB port (%1)"), serial);
	    }*/
	    string ret = "";
	    foreach (`e, cups_usb_devices, ``{
		if (e[0]:"" == dev)
		    ret = e[1]:"";
	    });
	    if (detected)
		ret = "USB";
	    if (ret != "" && ret != nil)
		return sformat ("%1 (%2)", ret, dev);
	}
	return lookup ($[
	    // Names of devices. Labels in dialog
	    "/dev/lp0" : _("First Parallel Port (/dev/lp0)"),
	    // Names of devices. Labels in dialog
	    "/dev/lp1" : _("Second Parallel Port (/dev/lp1)"),
	    // Names of devices. Labels in dialog
	    "/dev/lp2" : _("Third Parallel Port (/dev/lp2)"),
	    // Names of devices. Labels in dialog
	    "/dev/lp3" : _("Fourth Parallel Port (/dev/lp3)"),

	    // Names of devices. Labels in dialog
	    "/dev/ttyS0" : _("First Serial Port (/dev/ttyS0)"),
	    // Names of devices. Labels in dialog
	    "/dev/ttyS1" : _("Second Serial Port (/dev/ttyS1)"),
	    // Names of devices. Labels in dialog
	    "/dev/ttyS2" : _("Third Serial Port (/dev/ttyS2)"),
	    // Names of devices. Labels in dialog
	    "/dev/ttyS3" : _("Fourth Serial Port (/dev/ttyS3)"),

	    // Names of devices. Labels in dialog
	    "/dev/usb/lp0" : _("First USB Printer (/dev/usb/lp0)"),
	    // Names of devices. Labels in dialog
	    "/dev/usb/lp1" : _("Second USB Printer (/dev/usb/lp1)"),
	    // Names of devices. Labels in dialog
	    "/dev/usb/lp2" : _("Third USB Printer (/dev/usb/lp2)"),
	    // Names of devices. Labels in dialog
	    "/dev/usb/lp3" : _("Fourth USB Printer (/dev/usb/lp3)"),
	    // Names of devices. Labels in dialog
	    "/dev/usb/lp4" : _("Fifth USB Printer (/dev/usb/lp4)"),
	    // Names of devices. Labels in dialog
	    "/dev/usb/lp5" : _("Sixth USB Printer (/dev/usb/lp5)"),
	    // Names of devices. Labels in dialog
	    "/dev/usb/lp6" : _("Seventh USB Printer (/dev/usb/lp6)"),
	    // Names of devices. Labels in dialog
	    "/dev/usb/lp7" : _("Eighth USB Printer (/dev/usb/lp7)"),
            // Names of devices. Labels in dialog
            "/dev/usb/lp8" : _("Ninth USB Printer (/dev/usb/lp8)"),
            // Names of devices. Labels in dialog
            "/dev/usb/lp9" : _("Tenth USB Printer (/dev/usb/lp9)"),
            // Names of devices. Labels in dialog
            "/dev/usb/lp10" : _("Eleventh USB Printer (/dev/usb/lp10)"),
            // Names of devices. Labels in dialog
            "/dev/usb/lp11" : _("Twelfth USB Printer (/dev/usb/lp11)"),
            // Names of devices. Labels in dialog
            "/dev/usb/lp12" : _("Thirteenth USB Printer (/dev/usb/lp12)"),
            // Names of devices. Labels in dialog
            "/dev/usb/lp13" : _("Forteenth USB Printer (/dev/usb/lp13)"),
            // Names of devices. Labels in dialog
            "/dev/usb/lp14" : _("Fifteenth USB Printer (/dev/usb/lp14)"),
            // Names of devices. Labels in dialog
            "/dev/usb/lp15" : _("Sixteenth USB Printer (/dev/usb/lp15)"),
	    ], dev, dev);
    }
    /**
     * get paper size from system and returns `a4 for a4 or `letter for letter
     * @return symbol `a4 for a4, `letter for letter
     */
    global define symbol getDefaultPaperSize () ``{
	if (nil != paper_size)
	    return paper_size;
	integer int_paper_size = SCR::Execute (.target.bash,
	    "/usr/bin/locale -k LC_PAPER | /usr/bin/grep width=210");
	if (int_paper_size != 0 && int_paper_size != 1)
	    int_paper_size = 0;
	if (int_paper_size == 0)
	    paper_size = `a4;
	else
	    paper_size = `letter;
	return paper_size;
    }
}
