/**
 * File:
 *  misc.ycp
 *
 * Module:
 *  Printer configurator
 *
 * Summary:
 *  Miscelaneous defines.
 *
 * Authors:
 *  Petr Blahos <pblahos@suse.cz>
 *  Jiri Srain <jsrain@suse.cz>   2002
 *
 * $Id$
 *
 * Miscelaneous defines.
 */

{
    textdomain "printer";
    import "Printer";
    import "Printerlib";

    /**
      * Write configuration to CUPS
      * @param list of entries
      * @return boolean true if successfull
      */
    global define boolean writeCupsPrinter (map entry) ``{
        string name = lookup (entry, "name", "");
        if (lookup (entry, "type", "yast2") != "yast2")
            return false;
        if (lookup (entry, "uri", "class") == "class")
        {
            return SCR::Write (.cups.classes.add, entry);
        }
        string uri = lookup (entry, "uri", "");
        string uri_type = Printerlib::getUriType (uri);
        if ("void" == lookup (entry, "cups-state", "changed"))
        {
            UI::MessagePopup (_("Queue %1 cannot be saved, because\n selected spooler doesn't support it"), name);
            return false;
        }

        boolean raw = false;//true;
        string ppdfile = SCR::Write (add (.printerdb.ppd, lookup (entry, "config", "")), lookup (entry, "options", $[]));
        string ppdfilename = lookup (entry, "ppd", "");
        string ownppd = lookup (entry, "ownppd", "");
        if (raw)
        {
            ppdfilename = "";
            ownppd = "";
        }
        else if (ppdfilename == "" && ownppd == "")
        {
            ppdfilename = SCR::Read (.target.tmpdir);
            ppdfilename = ppdfilename + "/ppdfile";
        }

        if (Printerlib::getUriType (uri) == "usb")
        {
            string dev_name = Printerlib::getCupsUsbDevice (lookup (entry, "vendor_id",0), lookup (entry, "device_id",0), "");
            if (dev_name != "")
                entry = add (entry, "uri", "usb:" + dev_name);
        }
        else if (Printerlib::getUriType (uri) == "serial")
        {
            string dev_name = Printerlib::getUriDevice (uri);
            integer baudrate = Printerlib::getUriBaudrate (uri);
            string ty = Printerlib::getUriValue (uri, "ty");
            string br_string = baudrate == 0 ? "" : sformat ("baud=%1", baudrate);
            string ty_string = filterchars (ty, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-") == "" ? "" : sformat ("%1", ty);
            string uri = "serial:" + dev_name;
            if (ty_string != "")
            {
                if (br_string != "")
                    uri = uri + "?" + br_string + "+" + ty_string;
                else
                    uri = uri + "?" + ty_string;
            }
            else
            {
                if (br_string != "")
                    uri = uri + "?" + br_string;
            }
            entry = add (entry, "uri", uri);
        }
        else if (Printerlib::getUriType (uri) == "irda")
        {
            string dev_name = Printerlib::getUriDevice (uri);
            if (dev_name != "")
                entry = add (entry, "uri", "parallel:" + dev_name);
        }
        else if (Printerlib::getUriType (uri) == "samba")
        {
            entry = add (entry, "uri", "smb" + substring (uri, 5));
        }
        else if (Printerlib::getUriType (uri) == "filtering")
        {
            string dev_name = Printerlib::getUriDevice (uri);
            if (dev_name != "")
                entry = add (entry, "uri", "lpd:/" + dev_name);
        }
        if (ownppd == "")
        {
            if (ppdfilename != "")
            {
                SCR::Write (.target.string, ppdfilename, ppdfile);
                entry = add (entry, "ppd", ppdfilename);
            }
        }
        else
            if (isPpd (ownppd))
//          if (0 == SCR::Execute (.target.bash, sformat ("test -f %1", ownppd)))
                entry = add (entry, "ppd", ownppd);
        boolean res = SCR::Write (.cups.printers.add, entry);
        if (! res)
            UI::MessagePopup (_("Error occured while saving queue %1"), name);
        return res;
    }


}
