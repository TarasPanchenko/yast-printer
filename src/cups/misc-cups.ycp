/**
 * File:
 *  misc.ycp
 *
 * Module:
 *  Printer configurator
 *
 * Summary:
 *  Miscelaneous defines for CUPS.
 *
 * Authors:
 *  Petr Blahos <pblahos@suse.cz>
 *  Jiri Srain <jsrain@suse.cz>   2002
 *
 * $Id$
 *
 * Miscelaneous defines.
 */

{
    textdomain "printer";

    import "CUPS";
    import "Popup";
    import "Printer";
    import "Printerdb";
    import "Printerlib";
    import "Runlevel";

    /**
      * Read settings of CUPS client-only
      * @return boolean true on success
      * TODO error handling
      */
    global define boolean cupsClientRead () ``{
	map state = (map)SCR::Read (.target.ycp, "/var/lib/YaST2/printers");
	if (nil == state)
	{
	    state = $[];
	}
	string cups_default = (string)SCR::Read (.cups.default_dest);
	map out = (map) SCR::Execute (.target.bash_output,
	    "/bin/grep ^Default </etc/cups/lpoptions | cut -f2 -d\\ ");
	string lpoptions_default = out["stdout"]:"";
	if (nil != findfirstof (lpoptions_default, "\n"))
	{
	    lpoptions_default = substring (lpoptions_default, 0,
		findfirstof (lpoptions_default, "\n"));
	}
	CUPS::server_default = ! (cups_default == lpoptions_default);
	Printer::default = CUPS::server_default
	    ? ""
	    : cups_default;
	return true;
    }

    /**
      * Write configuration to CUPS
      * @param entry map of printer entry
      * @return boolean true if successfull
      */
    global define boolean writeCupsPrinter (map entry) ``{
	Printerdb::loadFoomaticIfNeeded ();
        string name = lookup (entry, "name", "");
        if (lookup (entry, "uri", "class") == "class")
        {
            return SCR::Write (.cups.classes.add, entry);
        }
        string uri = lookup (entry, "uri", "");
        string uri_type = Printerlib::getUriType (uri);
	if (uri_type == "ptal")
	{
	    y2milestone ("Enabling PTAL service");
	    // for being sure, enable also hotplug
	    Runlevel::ServiceAdjust ("hotplug", "enable");
	    Runlevel::ServiceAdjust ("ptal", "enable");
	}
        if (! entry["valid"]:true)
        {
            return false;
        }
	entry = Printerdb::getUpdatedPpdFile (entry);
	boolean raw = entry["raw"]:false;
	if (entry == nil)
	    return false;

        if (Printerlib::getUriType (uri) == "usb")
        {
        }
        else if (Printerlib::getUriType (uri) == "serial")
        {
            string dev_name = Printerlib::getUriDevice (uri);
            integer baudrate = Printerlib::getUriBaudrate (uri);
            string ty = Printerlib::getUriValue (uri, "ty");
            string br_string = baudrate == 0 ? "" : sformat ("baud=%1", baudrate);
            string ty_string = filterchars (ty, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-") == "" ? "" : sformat ("%1", ty);
            string uri = "serial:" + dev_name;
            if (ty_string != "")
            {
                if (br_string != "")
                    uri = uri + "?" + br_string + "+" + ty_string;
                else
                    uri = uri + "?" + ty_string;
            }
            else
            {
                if (br_string != "")
                    uri = uri + "?" + br_string;
            }
            entry = add (entry, "uri", uri);
        }
        else if (Printerlib::getUriType (uri) == "irda")
        {
            string dev_name = Printerlib::getUriDevice (uri);
            if (dev_name != "")
                entry = add (entry, "uri", "parallel:" + dev_name);
        }
        else if (Printerlib::getUriType (uri) == "samba")
        {
            entry = add (entry, "uri", "smb" + substring (uri, 5));
        }

	string ppd = lookup (entry, "ppd", "");
	if (ppd != "" && -1 == SCR::Read (.target.size, ppd))
	{
	    y2error ("Unexsistent PPD file: %1", ppd);
		// error popup
	    Popup::Message (sformat (_("An error occurred while saving queue %1.

The specified PPD file does not exist.
"), name));
	    return false;
	}
	else if (raw)
	{
	    // remove the file
	    SCR::Execute (.target.bash, sformat ("test -f %1 && rm %1",
		sformat ("/etc/cups/ppd/%1.ppd", entry["name"]:"")));
	}

        boolean res = SCR::Write (.cups.printers.add, entry);
        if (! res)
	    // popup
            Popup::Message (sformat (_("An error occurred while communicating with the 
CUPS server while saving queue %1.

%2"), name, SCR::Read (.cups.last_error)));
        return res;
    }


}
