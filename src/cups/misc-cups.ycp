/**
 * File:
 *  misc.ycp
 *
 * Module:
 *  Printer configurator
 *
 * Summary:
 *  Miscelaneous defines.
 *
 * Authors:
 *  Petr Blahos <pblahos@suse.cz>
 *  Jiri Srain <jsrain@suse.cz>   2002
 *
 * $Id$
 *
 * Miscelaneous defines.
 */

{
    textdomain "printer";
    import "Printer";
    import "Printerlib";
    import "Report";
    import "Popup";
    import "Runlevel";

    /**
      * start CUPS server and don't wait until initialization finishes
      */
    global define void startCupsServer () ``{
        integer status = SCR::Execute (.target.bash, "/etc/init.d/cups status");
        if (0 != status)
        {
            SCR::Execute (.target.bash_background, "/etc/init.d/cups start");
        }
    }

    /**
      * display CUPS initialization popup
      */
    global define void showCupsInitPopup () ``{
        // popup
        UI::OpenDialog(`opt(`decorated ),`VBox (
                // label
            `Label(_("Initializing CUPS server...
This usually takes one or two minutes")),
            `ProgressBar (`id (`cups_prog), "", 60 * 10)));
    }

    /**
      * Get list of possible banners for CUPS server
      * @return list banners names
      */
    global define list getBannerList () ``{
        map out = SCR::Execute (.target.bash_output, "/bin/ls -1 /usr/share/cups/banners");
        list ban = splitstring (lookup (out, "stdout", ""), "\n");
        ban = toset (add (ban, "none"));
        return filter (`i, ban, ``("" != i));
    }

    /**
      * Write configuration to CUPS
      * @param entry map of printer entry
      * @return boolean true if successfull
      */
    global define boolean writeCupsPrinter (map entry) ``{
	loadFoomaticIfNeeded ();
        string name = lookup (entry, "name", "");
        if (lookup (entry, "type", "yast2") != "yast2")
            return false;
        if (lookup (entry, "uri", "class") == "class")
        {
            return SCR::Write (.cups.classes.add, entry);
        }
        string uri = lookup (entry, "uri", "");
        string uri_type = Printerlib::getUriType (uri);
	if (uri_type == "ptal")
	{
	    y2milestone ("Enabling PTAL service");
	    // for being sure, enable also hotplug
	    Runlevel::ServiceAdjust ("hotplug", "enable");
	    Runlevel::ServiceAdjust ("ptal", "enable");
	}
        if ("void" == lookup (entry, "cups-state", "changed"))
        {
            return false;
        }
	entry = getUpdatedPpdFile (entry);
	boolean raw = entry["raw"]:false;
	if (entry == nil)
	    return false;

        if (Printerlib::getUriType (uri) == "usb")
        {
        }
        else if (Printerlib::getUriType (uri) == "serial")
        {
            string dev_name = Printerlib::getUriDevice (uri);
            integer baudrate = Printerlib::getUriBaudrate (uri);
            string ty = Printerlib::getUriValue (uri, "ty");
            string br_string = baudrate == 0 ? "" : sformat ("baud=%1", baudrate);
            string ty_string = filterchars (ty, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-") == "" ? "" : sformat ("%1", ty);
            string uri = "serial:" + dev_name;
            if (ty_string != "")
            {
                if (br_string != "")
                    uri = uri + "?" + br_string + "+" + ty_string;
                else
                    uri = uri + "?" + ty_string;
            }
            else
            {
                if (br_string != "")
                    uri = uri + "?" + br_string;
            }
            entry = add (entry, "uri", uri);
        }
        else if (Printerlib::getUriType (uri) == "irda")
        {
            string dev_name = Printerlib::getUriDevice (uri);
            if (dev_name != "")
                entry = add (entry, "uri", "parallel:" + dev_name);
        }
        else if (Printerlib::getUriType (uri) == "samba")
        {
            entry = add (entry, "uri", "smb" + substring (uri, 5));
        }

	string ppd = lookup (entry, "ppd", "");
	if (ppd != "" && -1 == SCR::Read (.target.size, ppd))
	{
	    y2error ("Unexsistent PPD file: %1", ppd);
		// error popup
	    Popup::Message (sformat (_("An error occurred while saving queue %1.

The specified PPD file does not exist.
"), name));
	    return false;
	}
	else if (raw)
	{
	    // remove the file
	    SCR::Execute (.target.bash, sformat ("test -f %1 && rm %1",
		sformat ("/etc/cups/ppd/%1.ppd", entry["name"]:"")));
	}

        boolean res = SCR::Write (.cups.printers.add, entry);
        if (! res)
	    // popup
            Popup::Message (sformat (_("An error occurred while communicating with the 
CUPS server while saving queue %1.

%2"), name, SCR::Read (.cups.last_error)));
        return res;
    }
    /**
      * Reads CUPS server settings from /etc/cups/cupsd.conf file
      */
    global define void readCupsSettings () ``{
	map out = SCR::Execute (.target.bash_output, "
/bin/cp /etc/cups/cupsd.conf /etc/cups/cupsd.conf.y2
echo \"<Location /printers>
</Location>
<Location /classes>
</Location>
<Location /admin>
</Location>
<Location />
</Location>\" >>/etc/cups/cupsd.conf.y2

/bin/awk '
BEGIN {location = \"\";}
/^Browsing/ {printf (\"Browsing %s\\n\", $2); next;}
/^BrowseAddress/ {printf (\"BrowseAddress %s\\n\", $2); next;}
/^Order/ {printf (\"%sOrder %s\\n\", location, $2); next;}
/^<Location/ {location = $2; next;}
/^<\\/Location/ {location = \"\"; next;}
/^Allow From/ {printf (\"%sAllowFrom %s\\n\", location, $3); next;}
/^Deny From/ {printf (\"%sDenyFrom %s\\n\", location, $3); next;}
// {next;}
' </etc/cups/cupsd.conf.y2");
        string set = lookup (out, "stdout", "");
        list lines = splitstring (set, "\n");
        map settings = $[];
        foreach (`l, lines, ``{
            list parts = splitstring (l, " ");
            string key = select (parts, 0, "");
            string val = select (parts, 1, "");
            string prefix = "";
            map work = settings;
            if (issubstring (key, ">"))
            {
                list tmp = splitstring (key, ">");
                prefix = select (tmp, 0, "");
                key = select (tmp, 1, "");
            }
            if (prefix != "")
                work = lookup (settings, prefix, $[]);
            if (key == "Browsing" || key == "Order")
                work = add (work, key, val);
            else if (key == "BrowseAddress" || key == "AllowFrom" || key == "DenyFrom")
            {
                list current = lookup (work, key, []);
                current = add (current, val);
                work = add (work, key, current);
            }
            if (prefix != "")
                settings = add (settings, prefix, work);
            else
                settings = work;
        });
	y2milestone ("CUPS settings read: %1", settings);
	Printer::cups_server_settings = settings;
    }
    /**
      * Writes CUPS server settings to /etc/cups/cupsd.conf file
      */
    global define void writeCupsSettings () ``{
	if (Printer::cups_server_settings == $[])
	    readCupsSettings ();
	map settings = Printer::cups_server_settings;
        string run = "function write_browsing(x){\n";
        if (lookup (settings, "Browsing", "") != "")
            run = run + sformat ("printf \"Browsing %1\\n\";\n", lookup (settings, "Browsing", ""));
        run = run + "}\n\n";

        run = run + "function write_browse_addr(x){\n";
        foreach (`e, lookup (settings, "BrowseAddress", []), ``{
            run = run + sformat ("printf \"BrowseAddress %1\\n\";\n", e);
        });
        run = run + "}\n\n";

        run = run + "function write_deny(x){\n";
        foreach (`e, ["/", "/admin", "/printers", "/classes"], ``{
            map set2 = lookup (settings, e, $[]);
            list set = lookup (set2, "DenyFrom", []);
            if (size (set) > 0)
            {
                run = run + sformat ("if (x == \"%1>\") {\n", e);
                foreach (`s, set, ``{
                    run = run + sformat ("printf \"Deny From %1\\n\"\n", s);
                });
                run = run + "}\n";
            }
        });
        run = run + "}\n\n";

        run = run + "function write_allow(x){\n";
        foreach (`e, ["/", "/admin", "/printers", "/classes"], ``{
            map set2 = lookup (settings, e, $[]);
            list set = lookup (set2, "AllowFrom", []);
            if (size (set) > 0)
            {
                run = run + sformat ("if (x == \"%1>\") {\n", e);
                foreach (`s, set, ``{
                    run = run + sformat ("printf \"Allow From %1\\n\"\n", s);
                });
                run = run + "}\n";
            }
        });
        run = run + "}\n\n";

        run = run + "function write_order(x){\n";
        foreach (`e, ["/", "/admin", "/printers", "/classes"], ``{
            map set2 = lookup (settings, e, $[]);
            string  s = lookup (set2, "Order", "");
            if (s != "")
            {
                run = run + sformat ("if (x == \"%1>\") {\n", e);
                run = run + sformat ("printf \"Order %1\\n\"\n", s);
                run = run + "}\n";
            }
        });
        run = run + "}\n\n";


        run = run + "BEGIN {
    label = \"\"; browsing = 0; browseaddress = 0; order = false; allowfrom = false; denyfrom = false; 
open = 0;
done[\"\"] = 1;\n";

	foreach (`e, ["/", "/admin", "/printers", "/classes"], ``{
	    if (lookup (settings, e, $[]) == $[])
		run = run + sformat ("done[\"%1>\"] = 1;\n", e);
	});

	run = run + "}\n";

	run = run + "/^Browsing/ {
    if (browsing == 0) {write_browsing(label); browsing = 1;} next;
}\n";

        run = run + "/^BrowseAddress/ {
    if (browseaddress == 0) {write_browse_addr(label); browseaddress = 1;} next;
}\n";

        run = run + "/^<Location/ {
    label = $2;
    if (! done[$2] != 1) {next;}
    open = 1;
    if (browsing == 0) {write_browsing(\"\");} 
    if (browseaddress == 0) {write_browse_addr(\"\");}
    browsing = 1;
    browseaddress = 1;
    print $0
    deny = 0;
    allow = 0;
    order = 0;
    next;
}\n";

        run = run + "/^<\\/Location/ {
    if (! done[label] != 1) {next;}
    done[label] = 1;
    if (open == 0) {next;}
    if (deny == 0) {write_deny(label);}
    if (allow == 0) {write_allow(label);}
    if (order == 0) {write_order(label);}
    print $0;
    label = \"\";
    next;
}\n";

        run = run + "/^Order/ {
    if (order == 0 ) {write_order(label);}
    order = 1;
    next;
}\n";

        run = run + "/^Allow From/ {
    if (allow == 0) {write_allow(label);}
    allow = 1;
    next;
}\n";

        run = run + "/^Deny From/ {
    if (deny == 0) {write_deny(label);}
    deny = 1;
    next;
}\n";

        run = run + "// {print $0; next;}
#// {next;}

END {

}\n";
	run = sformat("/bin/awk '%1' </etc/cups/cupsd.conf.y2 >/etc/cups/cupsd.conf", run);
	map out = SCR::Execute (.target.bash_output, run);
    }
}
