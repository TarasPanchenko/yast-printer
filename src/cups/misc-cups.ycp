/**
 * File:
 *  misc.ycp
 *
 * Module:
 *  Printer configurator
 *
 * Summary:
 *  Miscelaneous defines for CUPS.
 *
 * Authors:
 *  Petr Blahos <pblahos@suse.cz>
 *  Jiri Srain <jsrain@suse.cz>   2002
 *
 * $Id$
 *
 * Miscelaneous defines.
 */

{
    textdomain "printer";

    import "Popup";
    import "Printerdb";
    import "Printerlib";
    import "Runlevel";

    /**
      * Get list of possible banners for CUPS server
      * @return list banners names
      */
    global define list getBannerList () ``{
        map out = SCR::Execute (.target.bash_output, "/bin/ls -1 /usr/share/cups/banners");
        list ban = splitstring (lookup (out, "stdout", ""), "\n");
        ban = toset (add (ban, "none"));
        return filter (`i, ban, ``("" != i));
    }

    /**
      * Write configuration to CUPS
      * @param entry map of printer entry
      * @return boolean true if successfull
      */
    global define boolean writeCupsPrinter (map entry) ``{
y2error ("Writing printer %1", entry);
	Printerdb::loadFoomaticIfNeeded ();
        string name = lookup (entry, "name", "");
        if (lookup (entry, "type", "yast2") != "yast2")
            return false;
        if (lookup (entry, "uri", "class") == "class")
        {
            return SCR::Write (.cups.classes.add, entry);
        }
        string uri = lookup (entry, "uri", "");
        string uri_type = Printerlib::getUriType (uri);
	if (uri_type == "ptal")
	{
	    y2milestone ("Enabling PTAL service");
	    // for being sure, enable also hotplug
	    Runlevel::ServiceAdjust ("hotplug", "enable");
	    Runlevel::ServiceAdjust ("ptal", "enable");
	}
        if ("void" == lookup (entry, "cups-state", "changed"))
        {
            return false;
        }
	entry = Printerdb::getUpdatedPpdFile (entry);
	boolean raw = entry["raw"]:false;
	if (entry == nil)
	    return false;

        if (Printerlib::getUriType (uri) == "usb")
        {
        }
        else if (Printerlib::getUriType (uri) == "serial")
        {
            string dev_name = Printerlib::getUriDevice (uri);
            integer baudrate = Printerlib::getUriBaudrate (uri);
            string ty = Printerlib::getUriValue (uri, "ty");
            string br_string = baudrate == 0 ? "" : sformat ("baud=%1", baudrate);
            string ty_string = filterchars (ty, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-") == "" ? "" : sformat ("%1", ty);
            string uri = "serial:" + dev_name;
            if (ty_string != "")
            {
                if (br_string != "")
                    uri = uri + "?" + br_string + "+" + ty_string;
                else
                    uri = uri + "?" + ty_string;
            }
            else
            {
                if (br_string != "")
                    uri = uri + "?" + br_string;
            }
            entry = add (entry, "uri", uri);
        }
        else if (Printerlib::getUriType (uri) == "irda")
        {
            string dev_name = Printerlib::getUriDevice (uri);
            if (dev_name != "")
                entry = add (entry, "uri", "parallel:" + dev_name);
        }
        else if (Printerlib::getUriType (uri) == "samba")
        {
            entry = add (entry, "uri", "smb" + substring (uri, 5));
        }

	string ppd = lookup (entry, "ppd", "");
	if (ppd != "" && -1 == SCR::Read (.target.size, ppd))
	{
	    y2error ("Unexsistent PPD file: %1", ppd);
		// error popup
	    Popup::Message (sformat (_("An error occurred while saving queue %1.

The specified PPD file does not exist.
"), name));
	    return false;
	}
	else if (raw)
	{
	    // remove the file
	    SCR::Execute (.target.bash, sformat ("test -f %1 && rm %1",
		sformat ("/etc/cups/ppd/%1.ppd", entry["name"]:"")));
	}

        boolean res = SCR::Write (.cups.printers.add, entry);
        if (! res)
	    // popup
            Popup::Message (sformat (_("An error occurred while communicating with the 
CUPS server while saving queue %1.

%2"), name, SCR::Read (.cups.last_error)));
        return res;
    }


}
