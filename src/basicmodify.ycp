/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:        include/printer/basicmodify.ycp
 * Package:     Configuration of printer
 * Summary:     Basic modify dialog definition
 * Authors:     Johannes Meixner <jsmeix@suse.de>
 *
 * $Id: basicmodify.ycp 27914 2006-02-13 14:32:08Z locilka $
 */

{

textdomain "printer";

import "Label";
import "Wizard";
import "Printer";
import "Printerlib";
import "Popup";

include "printer/helps.ycp";

/**
 * BasicModifyDialog dialog
 * @return dialog result
 */
any BasicModifyDialog()
{ string commandline = "";
  string name = Printer::queues[Printer::selected_queues_index,"name"]:"";
  string uri = Printer::queues[Printer::selected_queues_index,"uri"]:"";
  string description = Printer::queues[Printer::selected_queues_index,"description"]:"";
  string location = Printer::queues[Printer::selected_queues_index,"location"]:"";
  string ppd = Printer::queues[Printer::selected_queues_index,"ppd"]:"";
  // After the "Modify the Print Queue" text the actual queue name is appended
  // so that the result is e.g. "Modify the Print Queue funprinter1".
  // The actual queue name is a system value which cannot be translated.
  string caption = _("Modify the Print Queue") + " " + name;
  string model = "";
  list <string> description_words = splitstring( description, " " );
  if( size( description_words ) > 2 )
  { model = description_words[0]:"" + " "
            + description_words[1]:"" + " "
            + description_words[2]:"";
  }
  if( size( description_words ) == 2 )
  { model = description_words[0]:"" + " "
            + description_words[1]:"";
  }
  if( size( description_words ) == 1 )
  { model = description_words[0]:"";
  }
  string driver_filter_input_text = model;
  // Match anywhere in the NickName entry in the PPD:
  string driver_filter_string = filterchars( tolower( driver_filter_input_text ), Printer::lower_alnum_chars );
  string nick_name = "";
  term driver_options_content = `Empty();
  term paper_choice_content = `Empty();
  boolean a4_paper_choice = false;
  boolean a4_default_paper = false;
  term a4_paper_choice_radio_button = `RadioButton( `id(`a4), `opt(`disabled), "A&4" );
  boolean letter_paper_choice = false;
  boolean letter_default_paper = false;
  term letter_paper_choice_radio_button = `RadioButton( `id(`letter), `opt(`disabled), "Le&tter" );
  string default_paper_size = "";
  // Only local queues can be selected in the overview dialog to be modified.
  // For a local raw queue ppd is the empty string.
  // For a local queue with a System V style interface script ppd is "/etc/cups/interfaces/<name-of-the-script>".
  // For a normal local queue ppd is "/etc/cups/ppd/<queue-name>.ppd".
  // The leading part "/etc/" may vary depending on how the local cupsd
  // is installed or configured, see "/usr/bin/cups-config --serverroot".
  if( "" != ppd )
  { commandline = "test -r " + ppd;
    if( Printerlib::ExecuteBashCommand( commandline ) )
    { driver_options_content = `HBox( `Label( _("All") + " " ),
                                      `PushButton( `id(`driver_options),
                                                   _("Driver &Options")
                                                 ),
                                      `Label( " " + _("for the currently used driver") )
                                    );
    }
    else
    { ppd = "";
    }
  }
  if( issubstring( ppd, "/ppd/" ) )
  { // A "(recommended)" is removed because there is a special patch in CUPS
    // which suppresses it in certain "lpinfo -m" output.
    // Note the YCP quoting: \" becomes " and \\n becomes \n in the commandline.
    commandline = "grep '^\*NickName' " + ppd + " | cut -s -d '\"' -f2 | sed -e 's/(recommended)//' -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' | tr -s ' ' | tr -d '\\n'";
    if( Printerlib::ExecuteBashCommand( commandline ) )
    { y2milestone( "'%1' stdout (nick_name) is: '%2'", commandline, Printerlib::result["stdout"]:"" );
      nick_name = Printerlib::result["stdout"]:"";
      driver_filter_input_text = nick_name;
      // Match only at the beginning of the NickName entry in the PPD:
      driver_filter_string = "^" + filterchars( tolower( nick_name ), Printer::lower_alnum_chars );
    }
    if( ! Printer::DetermineDriverOptions( "" ) )
    { // Clear the Printer::driver_options so that no outdated driver options are used
      // (e.g. the driver options from another previously modified queue):
      Printer::driver_options = [];
    }
    foreach( map< string, any > driver_option,
             Printer::driver_options,
             { if( "PageSize" == driver_option["keyword"]:"" )
               { foreach( string value,
                          driver_option["values"]:[],
                          { if( "*A4" == value )
                            { default_paper_size = "A4";
                              a4_default_paper = true;
                              a4_paper_choice_radio_button = `RadioButton( `id(`a4), "A&4", true );
                            }
                            else
                            { if( "A4" == value )
                              { a4_paper_choice = true;
                                a4_paper_choice_radio_button = `RadioButton( `id(`a4), "A&4" );
                              }
                              else
                              { if( "*Letter" == value )
                                { default_paper_size = "Letter";
                                  letter_default_paper = true;
                                  letter_paper_choice_radio_button = `RadioButton( `id(`letter), "Le&tter", true );
                                }
                                else
                                { if( "Letter" == value )
                                  { letter_paper_choice = true;
                                    letter_paper_choice_radio_button = `RadioButton( `id(`letter), "Le&tter" );
                                  }
                                  else
                                  { if( "*" == substring( value, 0, 1 ) )
                                    { default_paper_size = substring( value, 1 );
                                    }
                                  }
                                }
                              }
                            }
                          }
                        );
                 y2milestone( "Default paper size is: '%1'", default_paper_size );
               }
             }
           );
  }
  // DefaultPageSize is required according to the Adobe PPD specification.
  // Nevertheless we don't rely on correct PPDs (e.g. whatever "third-party" PPDs)
  // and test if it really exists in the actually used PPD:
  if( "" != default_paper_size )
  { if( a4_default_paper
        || letter_default_paper
      )
    { paper_choice_content = `RadioButtonGroup( `id(`paper_size_radio_buttons),
                                                `HBox( `Label( _("Default paper size of the currently used driver") ),
                                                       a4_paper_choice_radio_button,
                                                       letter_paper_choice_radio_button,
                                                       `Label( _("(select what is actually loaded in your printer)") )
                                                     )
                                              );
    }
    else
    { if( a4_paper_choice
        || letter_paper_choice
      )
      { paper_choice_content = `RadioButtonGroup( `id(`paper_size_radio_buttons),
                                                  `HBox( `Label( _("Default paper size of the currently used driver")
                                                                 + ": " + default_paper_size + " "
                                                               ),
                                                         a4_paper_choice_radio_button,
                                                         letter_paper_choice_radio_button,
                                                         `Label( _("(select what is actually loaded in your printer)") )
                                                       )
                                                );
      }
      else
      { paper_choice_content = `Label( _("Default paper size of the currently used driver") + ": " + default_paper_size );
      }
    }
  }
  // Usually the id in the connection items is the matching index number in the connections list.
  // Here the id of the current connection is set to -1 because the uri of the current connection
  // is derived from the queues list and this uri may be not present in the connections list
  // for example when the queue has a special non-autodetectable DeviceURI (e.g. for iPrint)
  // or when the queue is for an USB printer which is currently not connected (e.g. a laptop user).
  // Therefore -1 (which means "invalid index number in the connections list") is used to be safe
  // and additionally -1 is used to distinguish when the current connection is kept
  // or when the connection was modified (then the id would be > 0 and valid in the connections list).
  // The current_connection item is preselected because it is the first entry in the
  // table of connections via prepend():
  term current_connection = `item( `id( -1 ),
                                   _("Currently used connection") + ": ",
                                   uri + " ",
                                   description
                                 );
  // Usually the id in the driver items is the matching index number in the ppds list.
  // Here the id of the current driver is set to -1 because the ppd for the current driver
  // is derived from the queues list and this ppd may be not present in the ppds list
  // for example when the queue has a ppd which is not in /usr/share/cups/model/ (e.g. a manually set up queue)
  // or when the ppd for the queue in /etc/cups/ppd/ was modified (e.g. different default option settings).
  // Therefore -1 (which means "invalid index number in the ppds list") is used to be safe
  // and additionally -1 is used to distinguish when the current driver is kept
  // or when the driver was modified (then the id would be > 0 and valid in the ppds list).
  // Furthermore the current_driver item is preselected via the additional "true".
  term current_driver = `item( `id( -1 ),
                               // Do not change or translate "raw", it is a technical term when no driver is used.
                               // Do not change or translate "System V style interface script", it is a technical term.
                               _("No driver is used (it is a 'raw' queue or a 'System V style interface script' is used)"),
                               true
                             );
  if( "" != nick_name )
  { current_driver = `item( `id( -1 ),
                            _("Currently used driver") + ": " + nick_name,
                            true
                          );
  }
  term contents = `VBox( `VBox( `Left( `Label( // Caption for a Table with a list of printer connections:
                                               _("Keep or Modify the Connection")
                                             )
                                     ),
                                `ReplacePoint( `id(`connection_selection_replace_point),
                                               `Table( `id(`connection_selection),
                                                       // By default there is no UserInput()
                                                       // if only something was selected in the Table
                                                       // (without clicking additionally a button)
                                                       // but the notify and immediate options
                                                       // forces UserInput() in this case:
                                                       `opt(`notify, `immediate),
                                                       // Headers of a Table with a list of printer connections:
                                                       `header( // Header of a Table column with a list of printer connections.
                                                                // Printer model name:
                                                                _("Model"),
                                                                // Header of a Table column with a list of printer connections.
                                                                // Connection of the printer (e.g. via USB or via parallel port):
                                                                _("Connection"),
                                                                // Header of a Table column with a list of printer connections.
                                                                // Additional description of the printer or its particular connection:
                                                                _("Description")
                                                              ),
                                                       prepend( Printer::ConnectionItems( "BasicAddDialog" ),
                                                                current_connection
                                                              )
                                                     )
                                             ),
                                `Right( `HBox( `Label( _("If the connection is not shown, try") + " " ),
                                               `PushButton( `id(`more_connections),
                                                            _("&More Connections")
                                                          ),
                                               `Label( " " + _("or use the") + " " ),
                                               `PushButton( `id(`connection_wizard),
                                                            _("&Connection Wizard")
                                                          )
                                             )
                                      )
                              ),
                         `VStretch(),
                         `VBox( `Left( `Label( // Caption for a printer driver selection:
                                               _("Keep or Exchange the Driver or Change the Option Settings of the Currently Used Driver")
                                             )
                                     ),
                                `HBox( `PushButton( `id(`apply_driver_filter),
                                                    // This button must be the default
                                                    // (it is activated when the user pressed the Enter key)
                                                    // because when the user has clicked into TextEntry to enter something
                                                    // it is normal to finish entering by pressing the Enter key
                                                    // but if the Enter key was linked to 'Next' or 'Back',
                                                    // the user would get the wrong action.
                                                    `opt(`default),
                                                    // Label of a PushButton to search a list for a search string:
                                                    _("&Show")
                                                  ),
                                       `Label( " " + _("drivers which match to") + " " ),
                                       `ReplacePoint( `id(`driver_filter_input_replace_point),
                                                      `TextEntry( `id(`driver_filter_input),
                                                                  `opt(`hstretch),
                                                                  "",
                                                                  driver_filter_input_text
                                                                )
                                                    ),
                                       `HStretch()
                                     ),
                                `ReplacePoint( `id(`paper_choice_and_driver_options_replace_point),
                                               `VBox( `Left( paper_choice_content ),
                                                      `Left( driver_options_content )
                                                    )
                                             ),
                                `ReplacePoint( `id(`driver_selection_replace_point),
                                               `SelectionBox( `id(`driver_selection),
                                                              // By default there is no UserInput()
                                                              // if only something was selected in the SelectionBox
                                                              // (without clicking additionally a button)
                                                              // but the notify option forces UserInput() in this case:
                                                              `opt(`notify),
                                                              "",
                                                              prepend( Printer::DriverItems( driver_filter_string, false ),
                                                                       current_driver
                                                                     )
                                                            )
                                             ),
                                `Right( `HBox( `Label( _("If no suitable driver is shown, try") + " " ),
                                               `PushButton( `id(`more_drivers),
                                                            _("More &Drivers")
                                                          ),
                                               `Label( " " + _("or") + " " ),
                                               `PushButton( `id(`all_drivers),
                                                            _("&All Drivers")
                                                          ),
                                               `Label( " " + _("or use the") + " " ),
                                               `PushButton( `id(`driver_wizard),
                                                            _("Driver &Wizard")
                                                          )
                                             )
                                      )
                              ),
                         `VStretch(),
                         `HBox( `TextEntry( `id(`description_input),
                                            `opt(`hstretch),
                                            _("Descri&ption"),
                                            description
                                          ),
                                `TextEntry( `id(`location_input),
                                            `opt(`hstretch),
                                            _("&Location"),
                                            location
                                          )
                              ),
                         `VStretch(),
                         `VBox( `Left( `Label( _("Special Settings") )
                                     ),
                                `Left( `HBox( `HWeight( 1,
                                                        `PushButton( `id(`queue_state),
                                                                     _("Enable/Disable")
                                                                   )
                                                      ),
                                              `HWeight( 1,
                                                        `PushButton( `id(`error_policy),
                                                                     _("Error Policy")
                                                                   )
                                                      ),
                                              `HWeight( 1,
                                                        `PushButton( `id(`access_control),
                                                                    _("Access Control")
                                                                   )
                                                      ),
                                              `HWeight( 1,
                                                        `PushButton( `id(`other_options),
                                                                    _("Other Options")
                                                                   )
                                                      ),
                                              `HStretch()
                                            )
                                     )
                              )
                       );
  Wizard::SetContentsButtons( caption,
                              contents,
                              HELPS["basic_modify_dialog"]:"",
                              Label::BackButton(),
                              // Set a different label for the "next" button
                              // (i.e. the lower right button which results `next as UI::UserInput).
                              // This button finishes the "add" procedure:
                              _("&Finish Modify")
                            );
  any ret = nil;
  while(true)
  { ret = UI::UserInput();
    if( ret == `abort || ret == `cancel || ret == `back ) break;
    if( ret == `next )
    { commandline = "/usr/sbin/lpadmin -h localhost -p '" + name + "'";
      boolean something_has_changed = false;
      integer selected_connection_index = (integer)UI::QueryWidget( `id(`connection_selection), `CurrentItem );
      if( selected_connection_index >= 0 )
      { uri = Printer::connections[selected_connection_index,"uri"]:"";
        if( "" != uri )
        { commandline = commandline + " -v '" + uri + "'";
          something_has_changed = true;
        }
      }
      integer selected_ppd_index = (integer)UI::QueryWidget( `id(`driver_selection), `CurrentItem );
      if( selected_ppd_index >= 0 )
      { ppd = Printer::ppds[selected_ppd_index,"ppd"]:"";
        if( "" != ppd )
        { commandline = commandline + " -m '" + ppd + "'";
          something_has_changed = true;
        }
      }
      if( -1 == selected_ppd_index )
      { // The default paper size can be only set for the currently used driver.
        // Depending on the currently used driver no paper size selection might exists
        // in particular not for a 'raw' queue or when a 'System V style interface script' is used:
        if( UI::WidgetExists( `id(`paper_size_radio_buttons) ) )
        { any paper_size = UI::QueryWidget( `id(`paper_size_radio_buttons), `CurrentButton );
          if( `a4 == paper_size
              && "A4" != default_paper_size
            )
          { commandline = commandline + " -o PageSize=A4";
            something_has_changed = true;
          }
          if( `letter == paper_size
              && "Letter" != default_paper_size
            )
          { commandline = commandline + " -o PageSize=Letter";
            something_has_changed = true;
          }
        }
      }
      string description_input = (string)UI::QueryWidget( `id(`description_input), `Value);
      if( description_input != description )
      { commandline = commandline + " -D '" + description_input + "'";
        something_has_changed = true;
      }
      string location_input = (string)UI::QueryWidget( `id(`location_input), `Value);
      if( location_input != location )
      { commandline = commandline + " -L '" + location_input + "'";
        something_has_changed = true;
      }
      if( something_has_changed )
      { Wizard::DisableBackButton();
        Wizard::DisableAbortButton();
        Wizard::DisableNextButton();
        if( ! Printerlib::ExecuteBashCommand( commandline ) )
        { Popup::Error( // Message of a Popup::Error
                        // where %1 will be replaced by the queue name.
                        // Only a simple message because this error does not happen on a normal system
                        // (i.e. a system which is not totally broken or totally messed up).
                        sformat( _("Failed to modify queue %1."), name )
                      );
        }
        Wizard::EnableBackButton();
        Wizard::EnableAbortButton();
        Wizard::EnableNextButton();
      }
      else
      { Popup::ShowFeedback( // No title for such a simple feedback message:
                             "",
                             // Message of a Popup::ShowFeedback when nothing was changed:
                             _("Nothing changed.")
                           );
        sleep( 1000 );
        Popup::ClearFeedback();
      }
      // Exit this dialog in any case:
      break;
    }
    if( ret == `connection_wizard )
    { // Exit this dialog and go to the ConnectionWizardDialog via the sequencer in wizards.ycp:
      break;
    }
    if( ret == `driver_wizard )
    { Popup::AnyMessage( // Header of a Popup::AnyMessage when the "Driver Wizard" was selected:
                         _("Not yet implemented"),
                         // Body of a Popup::AnyMessage when the "Driver Wizard" was selected:
                         _("The 'Driver Wizard' is not yet implemented.")
                       );
      continue;
    }
    if( ret == `queue_state )
    { Popup::AnyMessage( // Header of a Popup::AnyMessage when "Enable/Disable" was selected:
                         _("Not yet implemented"),
                         // Body of a Popup::AnyMessage when "Enable/Disable" was selected:
                         _("'Enable/Disable' is not yet implemented.")
                       );
      continue;
    }
    if( ret == `error_policy )
    { Popup::AnyMessage( // Header of a Popup::AnyMessage when "Error Policy" was selected:
                         _("Not yet implemented"),
                         // Body of a Popup::AnyMessage when "Error Policy" was selected:
                         _("'Error Policy' is not yet implemented.")
                       );
      continue;
    }
    if( ret == `access_control )
    { Popup::AnyMessage( // Header of a Popup::AnyMessage when "Access Control" was selected:
                         _("Not yet implemented"),
                         // Body of a Popup::AnyMessage when "Access Control" was selected:
                         _("'Access Control' is not yet implemented.")
                       );
      continue;
    }
    if( ret == `other_options )
    { Popup::AnyMessage( // Header of a Popup::AnyMessage when "Other Options" was selected:
                         _("Not yet implemented"),
                         // Body of a Popup::AnyMessage when "Other Options" was selected:
                         _("'Other Options' are not yet implemented.")
                       );
      continue;
    }
    if( ret == `driver_options )
    { if( Printer::selected_queues_index < 0
          || "" == Printer::queues[Printer::selected_queues_index,"name"]:""
          || "remote" == Printer::queues[Printer::selected_queues_index,"config"]:"remote"
        )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when "Driver Options" was selected:
                           _("No driver options available"),
                           // Body of a Popup::AnyMessage when "Driver Options" was selected:
                           _("Possible reasons: No print queue selected or it is a remote queue.")
                         );
        continue;
      }
      // Take a changed paper size setting into account.
      // The Printer::DriverOptionItems call stores the current setting
      // in Printer::driver_options so that it is known the DriverOptionsDialog
      if( UI::WidgetExists( `id(`paper_size_radio_buttons) ) )
      { any paper_size = UI::QueryWidget( `id(`paper_size_radio_buttons), `CurrentButton );
        if( `a4 == paper_size
            && "A4" != default_paper_size
          )
        { Printer::DriverOptionItems( "PageSize", "A4" );
        }
        if( `letter == paper_size
            && "Letter" != default_paper_size
          )
        { Printer::DriverOptionItems( "PageSize", "Letter" );
        }
      }
      // Exit this dialog and go to the DriverOptionsDialog via the sequencer in wizards.ycp:
      break;
    }
    if( ret == `more_connections )
    { UI::ReplaceWidget( `id(`connection_selection_replace_point),
                         `Table( `id(`connection_selection),
                                 // By default there is no UserInput()
                                 // if only something was selected in the Table
                                 // (without clicking additionally a button)
                                 // but the notify and immediate options
                                 // forces UserInput() in this case:
                                 `opt(`notify, `immediate),
                                 // Headers of a Table with a list of printer connections:
                                 `header( // Header of a Table column with a list of printer connections.
                                          // Printer model name:
                                          _("Model"),
                                          // Header of a Table column with a list of printer connections.
                                          // Connection of the printer (e.g. via USB or via parallel port):
                                          _("Connection"),
                                          // Header of a Table column with a list of printer connections.
                                          // Additional description of the printer or its particular connection:
                                          _("Description")
                                        ),
                                 prepend( Printer::ConnectionItems( "MoreConnections" ),
                                          current_connection
                                        )
                               )
                       );
      UI::FakeUserInput( `connection_selection );
      continue;
    }
    if( ret == `all_drivers )
    { y2milestone( "All drivers" );
      UI::ReplaceWidget( `id(`driver_filter_input_replace_point),
                         `TextEntry( `id(`driver_filter_input),
                                     "",
                                     _("any model")
                                   )
                       );
      UI::ReplaceWidget( `id(`driver_selection_replace_point),
                         `SelectionBox( `id(`driver_selection),
                                        // By default there is no UserInput()
                                        // if only something was selected in the SelectionBox
                                        // (without clicking additionally a button)
                                        // but the notify option forces UserInput() in this case:
                                        `opt(`notify),
                                        "",
                                        prepend( Printer::DriverItems( "", false ),
                                                 current_driver
                                               )
                                      )
                       );
      continue;
    }
    if( ret == `more_drivers )
    { driver_filter_string = "";
      list driver_items = [];
      // The meaning of "more drivers" is "more based upon the current stage of the modify dialog".
      // Therefore set the model to the current content of the driver_filter_input_text
      // because depending on the history of the modify dialog the driver_filter_input_text
      // could be the NickName of the currenty used PPD
      // or the first (up to three) words of the description of the currenty used connection
      // or the model info of another (autodetected) connection
      // or whatever the user may have entered before:
      model = driver_filter_input_text;
      // Use the existing value of model because for each subsequent run of this more_drivers section
      // the existing value of model is shortened at the end (the last word is removed) to get
      // more and mor derivers for each subsequent run of this more_drivers section.
      y2milestone( "More drivers for '%1'", model );
      if( "" != model
          && "unknown" != tolower( model )
        )
      { // This should be no endless loop because sooner or later driver_filter_string becomes empty
        // because the model string becomes shorter and shorter but to be safe there is a maximum count:
        integer count = 0;
        while( size( driver_items ) < 1
               && count < 5
             )
        { count = count + 1;
          // If the model string does not contain a space,
          // model_words is a singleton list which contains only model.
          list <string> model_words = splitstring( model, " " );
          if( size( model_words ) < 2 )
          { // If there are less than two words (in particular if there is only one word left),
            // the remove below would result an empty model_words list which results
            // an empty driver_filter_string but the fall back to show all drivers is done below.
            break;
          }
          // Remove the last word (i.e. the last element in model_words):
          model_words = remove( model_words, size( model_words ) - 1 );
          // Build a new model and driver_filter_string with the remaining words:
          model = "";
          foreach( string word,
                   model_words,
                   { if( "" == model )
                     { model = word;
                     }
                     else
                     { model = model + " " + word;
                     }
                   }
                 );
          driver_filter_string = filterchars( tolower( model ), Printer::lower_alnum_chars );
          if( "" != driver_filter_string )
          { // If a real search is done, match only at the beginning of the NickName entry in the PPD.
            // When driver_filter_string is empty is must stay empty (i.e. no "^" as driver_filter_string)
            // because Printer::DriverItems() tries to preselect a PPD if driver_filter_string is not empty.
            // When driver_filter_string is empty, the fall back to show all drivers is done below.
            driver_items = Printer::DriverItems( "^" + driver_filter_string, false );
          }
          if( size( driver_items ) < 1
              && size( model_words ) == 1
            )
          { // Nothing found with a driver_filter_string which was derived from only one word.
            // This can happen for example when the autodetected model string does not contain
            // the manufacturer, e.g. "Officejet 7200 series" (a leading "HP" is missing).
            // To make such a one-word-search (e.g. for "Officejet") less strict,
            // match anywhere in the NickName entry in the PPD (i.e. without leading '^'):
            driver_items = Printer::DriverItems( driver_filter_string, false );
          }
        }
        if( "" != driver_filter_string )
        { driver_filter_input_text = model;
        }
      }
      else
      { // Fall back to the manufacturer when the existing value of model cannot be used:
        string model = Printer::connections[Printer::selected_connections_index,"model"]:"";
        if( "" != model
            && "unknown" != tolower( model )
          )
        { // The first word in the driver_filter_string is usually the first word of the manufacturer name.
          // This fuzzy match is intended so that e.g. "Kyocera" and "Kyocera Mita" are the same.
          string manufacturer = splitstring( model, " " )[0]:"";
          if( "" != manufacturer )
          { // Even more fuzzieness for very ambiguous manufacturer names:
            if( "hewlett" == substring( tolower( driver_filter_string ), 0, 7 ) )
            { // Let "Hewlett-Packard", "Hewlett Packard", and "HP be the same:
              manufacturer = "HP";
            }
            if( "oki" == substring( tolower( driver_filter_string ), 0, 3 ) )
            { // Let "Oki", "Okidata", and "Okipage" be the same:
              manufacturer = "Oki";
            }
            driver_filter_string = filterchars( tolower( manufacturer ), Printer::lower_alnum_chars );
            driver_filter_input_text = manufacturer;
          }
        }
        // The driver_filter_string might be empty (e.g. when manufacturer = "unknown"):
        if( "" != driver_filter_string )
        { // Match only at the beginning of the NickName entry in the PPD:
          driver_items = Printer::DriverItems( "^" + driver_filter_string, false );
          if( size( driver_items ) < 1 )
          { // Nothing found with the above driver_filter_string.
            // To make the search less strict,
            // match anywhere in the NickName entry in the PPD (i.e. without leading '^'):
            driver_items = Printer::DriverItems( driver_filter_string, false );
            // Set an unspecific header (and not the specific manufacturer header):
            driver_filter_input_text = driver_filter_string;
          }
        }
      }
      if( size( driver_items ) < 1 )
      { // Nothing was found above.
        // Fall back to show all drivers:
        driver_items = Printer::DriverItems( "", false );
        // Header of a SelectionBox with a list of drivers:
        driver_filter_input_text = _("any model");
      }
      UI::ReplaceWidget( `id(`driver_filter_input_replace_point),
                         `TextEntry( `id(`driver_filter_input),
                                     "",
                                     driver_filter_input_text
                                   )
                       );
      UI::ReplaceWidget( `id(`driver_selection_replace_point),
                         `SelectionBox( `id(`driver_selection),
                                        // By default there is no UserInput()
                                        // if only something was selected in the SelectionBox
                                        // (without clicking additionally a button)
                                        // but the notify option forces UserInput() in this case:
                                        `opt(`notify),
                                        "",
                                        prepend( driver_items,
                                                 current_driver
                                               )
                                      )
                       );
      continue;
    }
    if( ret == `connection_selection )
    { integer selected_connection_index = (integer)UI::QueryWidget( `id(`connection_selection), `CurrentItem );
      if( nil == selected_connection_index )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when no connection was selected:
                           _("No Connection Selected"),
                           // Body of a Popup::AnyMessage when no connection was selected:
                           _("Select a connection.")
                         );
        continue;
      }
      // selected_connection_index is -1 for the currently used connection
      // which is an invalid index in the connections list because
      // it means that the connection is not to be exchanged.
      // To be safe that the currently used connection cannot be exchanged
      // Printer::selected_connections_index is set to -1 in this case.
      if( selected_connection_index != Printer::selected_connections_index )
      { Printer::selected_connections_index = selected_connection_index;
        y2milestone( "Selected connection is: %1", Printer::connections[selected_connection_index]:$[] );
        // Invalidate any previously selected driver, if a connection is selected anew
        // or if a previously selected connection had changed:
        Printer::selected_ppds_index = -1;
      }
      if( selected_connection_index >= 0 )
      { // When the currently used connection is to be exchanged,
        // derive the driver_filter_string from the model of the new connection:
        driver_filter_string = "";
        driver_filter_input_text = "";
        model = Printer::connections[Printer::selected_connections_index,"model"]:"";
        y2milestone( "Drivers for '%1'", model );
        if( "" != model
            && "unknown" != tolower( model )
          )
        { driver_filter_input_text = model;
          driver_filter_string = filterchars( tolower( model ), Printer::lower_alnum_chars );
          if( Printer::connections[Printer::selected_connections_index,"class"]:"" != "ConnectionWizardDialog" )
          { // Match at the beginning only if the connection is not from the connection wizard:
            driver_filter_string = "^" + driver_filter_string;
          }
        }
      }
      else
      { // When the currently used connection is re-selected,
        // derive the driver_filter_string from the NickName of the currently used PPD
        // or derive the driver_filter_string from the  description of the currently used connection:
        if( "" != nick_name )
        { driver_filter_input_text = nick_name;
          // Match only at the beginning of the NickName entry in the PPD:
          driver_filter_string = "^" + filterchars( tolower( nick_name ), Printer::lower_alnum_chars );
        }
        else
        { description_words = splitstring( description, " " );
          if( size( description_words ) > 2 )
          { model = description_words[0]:"" + " "
                    + description_words[1]:"" + " "
                    + description_words[2]:"";
          }
          if( size( description_words ) == 2 )
          { model = description_words[0]:"" + " "
                    + description_words[1]:"";
          }
          if( size( description_words ) == 1 )
          { model = description_words[0]:"";
          }
          driver_filter_input_text = model;
          // Match anywhere in the NickName entry in the PPD:
          driver_filter_string = filterchars( tolower( model ), Printer::lower_alnum_chars );
        }
      }
      UI::ReplaceWidget( `id(`driver_filter_input_replace_point),
                         `TextEntry( `id(`driver_filter_input),
                                     "",
                                     driver_filter_input_text
                                   )
                       );
      UI::ReplaceWidget( `id(`driver_selection_replace_point),
                         `SelectionBox( `id(`driver_selection),
                                        // By default there is no UserInput()
                                        // if only something was selected in the SelectionBox
                                        // (without clicking additionally a button)
                                        // but the notify option forces UserInput() in this case:
                                        `opt(`notify),
                                        "",
                                        prepend( Printer::DriverItems( driver_filter_string, false ),
                                                 current_driver
                                               )
                                      )
                       );
      // Do the same as if ret == `driver_selection
      // but don't show a popup if nil == selected_ppd_index:
      integer selected_ppd_index = (integer)UI::QueryWidget( `id(`driver_selection), `CurrentItem );
      if( nil == selected_ppd_index )
      { continue;
      }
      // selected_ppd_index is -1 for the currently used driver
      // which is an invalid index in the ppds list because
      // it means that the driver is not to be exchanged.
      // To be safe that the currently used driver cannot be exchanged
      // Printer::selected_ppds_index is set to -1 in this case.
      if( selected_ppd_index != Printer::selected_ppds_index )
      { Printer::selected_ppds_index = selected_ppd_index;
        if( selected_ppd_index >= 0 )
        { y2milestone( "Selected driver is: %1", Printer::ppds[selected_ppd_index]:$[] );
        }
        else
        { if( "" != nick_name )
          { y2milestone( "Selected currently used driver: '%1'", nick_name );
          }
          else
          { y2milestone( "Selected currently used driver: No driver is used (it is a 'raw' queue or a 'System V style interface script' is used)" );
          }
        }
      }
      if( selected_ppd_index >= 0 )
      { // When the currently used driver is to be exchanged,
        // the widgets to change options for the currently used driver are removed:
        UI::ReplaceWidget( `id(`paper_choice_and_driver_options_replace_point),
                           `Empty()
                         );
      }
      else
      { // When the currently used driver is re-selected,
        // the widgets to change options for the currently used driver are recreated:
        UI::ReplaceWidget( `id(`paper_choice_and_driver_options_replace_point),
                           `VBox( `Left( paper_choice_content ),
                                  `Left( driver_options_content )
                                )
                         );
      }
      continue;
    }
    if( ret == `driver_selection )
    { integer selected_ppd_index = (integer)UI::QueryWidget( `id(`driver_selection), `CurrentItem );
      if( nil == selected_ppd_index )
      { Popup::AnyMessage( // Header of a Popup::AnyMessage when no driver was selected:
                           _("No Driver Selected"),
                           // Body of a Popup::AnyMessage when no driver was selected:
                           _("Select a driver.")
                         );
        continue;
      }
      // selected_ppd_index is -1 for the currently used driver
      // which is an invalid index in the ppds list because
      // it means that the driver is not to be exchanged.
      // To be safe that the currently used driver cannot be exchanged
      // Printer::selected_ppds_index is set to -1 in this case.
      if( selected_ppd_index != Printer::selected_ppds_index )
      { Printer::selected_ppds_index = selected_ppd_index;
        if( selected_ppd_index >= 0 )
        { y2milestone( "Selected driver is: %1", Printer::ppds[selected_ppd_index]:$[] );
        }
        else
        { if( "" != nick_name )
          { y2milestone( "Selected currently used driver: '%1'", nick_name );
          }
          else
          { y2milestone( "Selected currently used driver: No driver is used (it is a 'raw' queue or a 'System V style interface script' is used)" );
          }
        }
      }
      if( selected_ppd_index >= 0 )
      { // When the currently used driver is to be exchanged,
        // the widgets to change options for the currently used driver are removed:
        UI::ReplaceWidget( `id(`paper_choice_and_driver_options_replace_point),
                           `Empty()
                         );
      }
      else
      { // When the currently used driver is re-selected,
        // the widgets to change options for the currently used driver are recreated:
        UI::ReplaceWidget( `id(`paper_choice_and_driver_options_replace_point),
                           `VBox( `Left( paper_choice_content ),
                                  `Left( driver_options_content )
                                )
                         );
      }
      continue;
    }
    if( ret == `apply_driver_filter )
    { driver_filter_input_text = (string)UI::QueryWidget( `id(`driver_filter_input), `Value );
      y2milestone( "Drivers for '%1'", driver_filter_input_text );
      // Match anywhere in the NickName entry in the PPD (i.e. without leading '^'):
      driver_filter_string = filterchars( tolower( driver_filter_input_text ), Printer::lower_alnum_chars );
      if( "" == driver_filter_string )
      { driver_filter_input_text = _("any model");
      }
      UI::ReplaceWidget( `id(`driver_filter_input_replace_point),
                         `TextEntry( `id(`driver_filter_input),
                                     "",
                                     driver_filter_input_text
                                   )
                       );
      UI::ReplaceWidget( `id(`driver_selection_replace_point),
                         `SelectionBox( `id(`driver_selection),
                                        // By default there is no UserInput()
                                        // if only something was selected in the SelectionBox
                                        // (without clicking additionally a button)
                                        // but the notify option forces UserInput() in this case:
                                        `opt(`notify),
                                        "",
                                        prepend( Printer::DriverItems( driver_filter_string, false ),
                                                 current_driver
                                               )
                                      )
                       );
      continue;
    }
    y2milestone( "Ignoring unexpected returncode in BasicModifyDialog: %1", ret );
    continue;
  }
  return ret;
}

/* EOF */
}
