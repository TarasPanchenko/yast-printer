/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:        modules/Printer.ycp
 * Package:     Configuration of printer
 * Summary:     Printer settings, input and output functions
 * Authors:     Johannes Meixner <jsmeix@suse.de>
 *
 * $Id: Printer.ycp 27914 2006-02-13 14:32:08Z locilka $
 *
 * Representation of the configuration of printer.
 * Input and output routines.
 */

{

module "Printer";
textdomain "printer";

import "Progress";
import "Summary";
import "Popup";
import "Printerlib";

/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 */
global boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global boolean() AbortFunction = Modified;

/**
 * Abort function
 * @return boolean return true if abort
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
    {
        return AbortFunction () == true;
    }
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}

// Settings:
// Define all variables needed for configuration of a printer:

/**
 * Explicite listing of all alphanumeric ASCII characters.
 * The reason is that in certain special locales for example [a-z] is not equivalent
 * to "abcdefghijklmnopqrstuvwxyz" because in certain special languages the 'z' is
 * not the last character in the alphabet, e.g. the Estonian alphabet ends
 * with ... s ... z ... t u v w ... x y (non-ASCII characters omitted here)
 * so that [a-z] would exclude t u v w x y in an Estonian locale.
 * Therefore uppercase and lowercase characters are both explicitely listed
 * to avoid any unexpected result e.g. of "tolower(uppercase_characters)".
 */
global string number_chars = "0123456789";
global string upper_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
global string lower_chars = "abcdefghijklmnopqrstuvwxyz";
global string letter_chars = upper_chars + lower_chars;
global string alnum_chars = number_chars + letter_chars;
global string lower_alnum_chars = number_chars + lower_chars;

/**
 * Explicite listing of all known manufacturers in a standard installation
 * which one gets as output from the command
 * lpinfo -l -m | grep make-and-model | cut -s -d '=' -f 2 | cut -s -d ' ' -f 2 | sort -f -u
 * and then a bit changing it (in particular removing duplicates and nonsense entries).
 * The current list was made on openSUSE 11.0.
 */
global list< string > known_manufacturers = [ "Generic",
                                              "Alps",
                                              "Anitech",
                                              "Apollo",
                                              "Apple",
                                              "Brother",
                                              "Canon",
                                              "Citizen",
                                              "CItoh",
                                              "Compaq",
                                              "DEC",
                                              "Dell",
                                              "Dymo",
                                              "Epson",
                                              "Fujifilm",
                                              "Fujitsu",
                                              "Gestetner",
                                              "Heidelberg",
                                              "Hitachi",
                                              "HP",
                                              "IBM",
                                              "Infotec",
                                              "Kodak",
                                              "KS",
                                              "Kyocera",
                                              "Lanier",
                                              "Lexmark",
                                              "Minolta",
                                              "Mitsubishi",
                                              "NEC",
                                              "NRG",
                                              "Oce",
                                              "Oki",
                                              "Olivetti",
                                              "Olympus",
                                              "Panasonic",
                                              "PCPI",
                                              "QMS",
                                              "Raven",
                                              "Ricoh",
                                              "Samsung",
                                              "Savin",
                                              "Seiko",
                                              "Sharp",
                                              "Shinko",
                                              "Sony",
                                              "Star",
                                              "Tally",
                                              "Tektronix",
                                              "Toshiba",
                                              "Xerox",
                                              "Zebra"
                                            ];

/**
 * PPD database:
 * the database is created anew in Printer::CreateDatabase() which calls
 * the bash script "/usr/lib/YaST2/bin/create_ppd_database"
 * which outputs on stdout a YCP list of @ref printer_ppd_map
 * where the last list entry is an emtpy map.
 * Printer::CreateDatabase() leaves manufacturer and modelname empty because
 * it would take several minutes (instead of a few seconds) to fill them up
 * (see the comments in create_ppd_database). Both fields can be filled up
 * during runtime for particular PPDs (e.g. for a more detailed PPD selection
 * among several PPDs which match to a particular model or manufacturer
 * but not for all the thousands of PPDs which are installed in the system).
 * @struct printer_ppd_map
 * $[ "ppd":"the PPD file name with path below /usr/share/cups/model/ (required)",
 *    "nickname":"the NickName entry in the PPD (required)",
 *    "deviceID":"the 1284DeviceID entry in the PPD (may be the empty string)",
 *    "language":"the language of the PPD, usually "en" (may be the empty string)",
 *    "manufacturer":"the Manufacturer entry in the PPD (initially the empty string)",
 *    "modelname":"the ModelName entry in the PPD (initially the empty string)"
 *  ]
 */
global list< map< string, string > > ppds = [];

/**
 * Selected PPD database index:
 * The index in the PPD database list (of PPD maps)
 * for the PPD which was selected by the user.
 * Preset to -1 which indicates that no PPD is selected.
 */
global integer selected_ppds_index = -1;

/**
 * Autodetected printers:
 * Determined at runtime via Printer::AutodetectPrinters() which calls the bash script
 * "/usr/lib/YaST2/bin/autodetect_printers"
 * which outputs on stdout a YCP list of @ref autodetected_printer_map
 * where the last list entry is an emtpy map.
 * @struct autodetected_printer_map
 * $[ "uri":"the full CUPS DeviceURI (required)",
 *    "model":"the manufacturer and model, often 'Unknown' (may be the empty string)",
 *    "deviceID":"what the printer reported as its device ID (often the empty string)",
 *    "info":"arbitrary info regarding this connection (may be the empty string)",
 *    "class":"one of 'direct','network','file','serial' or 'ConnectionWizardDialog' (may be the empty string)"
 *  ]
 */
global list< map< string, string > > connections = [];

/**
 * Selected autodetected printer index:
 * The index in the autodetected printers list (of connection maps)
 * for the connection which was selected by the user.
 * Preset to -1 which indicates that no connection is selected.
 */
global integer selected_connections_index = -1;

/**
 * Current device uri:
 * The device uri (i.e. the connection) which is currently in use
 * so that the BasicAddDialog and BasicModifyDialog could preselect it.
 * Note that selected_connections_index cannot be used for this
 * because the ConnectionItems function which generates
 * the list of connections for BasicAddDialog and BasicModifyDialog
 * invalidates selected_connections_index because it autodetects
 * the currently available connections in the system anew because
 * those would change e.g. after a printer was connected or disconnected
 * Preset to "" which indicates that no device uri is currently in use.
 */
global string current_device_uri = "";

/**
 * Autodetected queues:
 * Determined at runtime via Printer::AutodetectQueues() which calls the bash script
 * "/usr/lib/YaST2/bin/autodetect_print_queues"
 * which outputs on stdout a YCP list of @ref autodetected_queue_map
 * where the last list entry is an emtpy map.
 * @struct autodetected_queue_map
 * $[ "name":"the queue name (required)",
 *    "uri":"the full CUPS DeviceURI (required)",
 *    "description":"(may be the empty string)",
 *    "location":"(may be the empty string)",
 *    "ppd":"/etc/cups/ppd/<queue-name>.ppd (may be the empty string)",
 *    "default":"'yes' if it is a DefaultPrinter in /etc/cups/printers.conf, otherwise the empty string",
 *    "disabled":"'yes' if printing is disabled, otherwise 'no'",
 *    "rejecting":"'yes' if print job are rejected, otherwise 'no'",
 *    "config":"'local' if the queue exists in /etc/cups/printers.conf, 'class' if the class exists in /etc/cups/classes.conf, otherwise 'remote' (required)"
 *  ]
 */
global list< map< string, string > > queues = [];

/**
 * Selected queue index:
 * The index in the queues list (of queue maps)
 * for the queue which was selected by the user.
 * Preset to -1 which indicates that no queue is selected.
 */
global integer selected_queues_index = -1;

/**
 * Queue filter string:
 * Can be either "all" or "local" or "remote" depending on
 * which kind of queues from the queues list (of queue maps)
 * the user wants to see in the overview dialog.
 * Preset to "all" which indicates that all queues are shown.
 */
global boolean queue_filter_show_local = true;
global boolean queue_filter_show_remote = true;

/**
 * Current queue name:
 * The name of the queue which is currently in use
 * so that the Overview dialog could preselect it.
 * Note that selected_queues_index cannot be used for this
 * because the QueueItems function which generates
 * the list of queues for the Overview dialog
 * invalidates selected_queues_index because it autodetects
 * the current actual queues in the system anew because
 * the list of queues in the system would have changed
 * e.g. after a new queue was added or after a queue was removed.
 * Preset to "" which indicates that no queue is currently in use.
 */
global string current_queue_name = "";

/**
 * Driver options (options in the PPD for one specific existing queue):
 * Determined at runtime via Printer::DetermineDriverOptions( "queue_name")
 * which calls the bash script "/usr/lib/YaST2/bin/determine_printer_driver_options"
 * which outputs on stdout a YCP list of @ref driver_option_map
 * where the last list entry is an emtpy map.
 * @struct driver_option_map
 * $[ "keyword":"the main keyword of the option in the PPD (required)",
 *    "translation":"the translation string of the main keyword (may be the empty string)",
 *    "values":["a list of the option keywords in the PPD (at least one non-empty entry is required)
 *               i.e. the values for the main keyword (i.e. the values for this option)
 *               where the currently set option value of the queue is marked by a leading '*'
 *               and where the last list entry is an emtpy string"],
 *    "selected":"the curently selected value in the DriverOptionsDialog (may be the empty string)"
 *  ]
 */
global list< map< string, any > > driver_options = [];

/*
 * Local variables:
 */
string create_database_progress_filename = "/var/lib/YaST2/create_printer_ppd_database.progress" ;
string database_filename = "/var/lib/YaST2/printer_ppd_database.ycp";
string create_database_commandline = "/usr/lib/YaST2/bin/create_printer_ppd_database >" + database_filename;
string autodetect_printers_progress_filename = "/var/lib/YaST2/autodetect_printers.progress" ;
string autodetected_printers_filename = "/var/lib/YaST2/autodetected_printers.ycp" ;
string autodetect_printers_commandline = "export PROGRESS=" + autodetect_printers_progress_filename + " ; /usr/lib/YaST2/bin/autodetect_printers >" + autodetected_printers_filename;
string autodetected_queues_filename = "/var/lib/YaST2/autodetected_print_queues.ycp" ;
string autodetect_queues_commandline = "/usr/lib/YaST2/bin/autodetect_print_queues >" + autodetected_queues_filename;
string driver_options_filename = "/var/lib/YaST2/printer_driver_options.ycp";
string determine_printer_driver_options_commandline = "/usr/lib/YaST2/bin/determine_printer_driver_options >" + driver_options_filename + " ";

/*
 * Global functions which are called by the local functions below:
 */


/*
 * Local functions which are called by the global functions below:
 */

/**
 * Create the PPD database by calling a bash script
 * which calls "lpinfo -l -m" and processes its output
 * and stores the results as YCP list in a temporary file
 * and then read the temporary file (SCR::Read)
 * to get the YCP list of @ref printer_ppd_map
 * @return true on success
 */
boolean CreateDatabase()
{ // Show feedback because creating the printer driver database takes several seconds:
  boolean progress_feedback = UI::HasSpecialWidget( `DownloadProgress );
  if( progress_feedback )
  { // Show nice self-updating feedback:
    // Empty an existing database file so that the DownloadProgress starts at the beginning.
    // Don't care if this command is successful. All what matters is if CreateDatabase() works.
    Printerlib::ExecuteBashCommand( "cat /dev/null >" + database_filename );
    UI::OpenDialog( `MinSize( 60, 3,
                              `ReplacePoint( `id(`create_database_progress_replace_point),
                                             `DownloadProgress( // Header of a DownloadProgress indicator:
                                                                _("Retrieving printer driver information..."),
                                                                create_database_progress_filename,
                                                                // On my openSUSE 11.0 the size is about 80000 bytes:
                                                                90000
                                                              )
                                           )
                            )
                  );
  }
  else
  { // Show a simple static busy message:
    Popup::ShowFeedback( // No title for a simple busy message:
                         "",
                         // Busy message:
                         // Body of a Popup::ShowFeedback:
                         _("Retrieving printer driver information...\n(this could take more than a minute)")
                       );
  }
  if( ! Printerlib::ExecuteBashCommand( create_database_commandline ) )
  { if( progress_feedback )
    { UI::CloseDialog();
    }
    else
    { Popup::ClearFeedback();
    }
    Popup::ErrorDetails( // Popup::ErrorDetails message.
                         // Only a simple message because this error does not happen on a normal system
                         // (i.e. a system which is not totally broken or totally messed up).
                         _("Failed to create PPD database."),
                         Printerlib::result["stderr"]:""
                       );
    return false;
  }
  if( -1 == SCR::Read( .target.size, database_filename ) )
  { if( progress_feedback )
    { UI::CloseDialog();
    }
    else
    { Popup::ClearFeedback();
    }
    y2milestone( "Error: %1: file does not exist.", database_filename );
    Popup::Error( sformat( // Message of a Popup::Error where %1 will be replaced by the file name.
                           // Only a simple message because this error does not happen on a normal system
                           // (i.e. a system which is not totally broken or totally messed up).
                           _("File %1 does not exist."),
                           database_filename
                         )
                 );
    return false;
  }
  ppds = (list< map< string, string > >)SCR::Read( .target.ycp, database_filename );
  if( nil == ppds )
  { if( progress_feedback )
    { UI::CloseDialog();
    }
    else
    { Popup::ClearFeedback();
    }
    y2milestone( "Error: Failed to read %1", database_filename );
    Popup::Error( sformat( // Message of a Popup::Error where %1 will be replaced by the file name.
                           // Only a simple message because this error does not happen on a normal system
                           // (i.e. a system which is not totally broken or totally messed up).
                           _("Failed to read %1."),
                           database_filename
                         )
                 );
    ppds = [];
    return false;
  }
  if( progress_feedback )
  { // Setting the DownloadProgress to 100% by setting its property
    // ExpectedSize to 1 (setting it to 0 results wrong output) by calling
    // UI::ChangeWidget( `id(`create_database_progress), `ExpectedSize, 1 )
    // results bad looking output because the DownloadProgress widget is visible re-drawn
    // first with a small 1% initially starting progress bar which then jumps up to 100%
    // but what is intended is that the current progress bar jumps directly up to 100%.
    // Therefore DownloadProgress is not used at all but replaced by a 100% ProgressBar.
    // Because ProgressBar has a different default width than DownloadProgress,
    // a MinWidth which is sufficient for both is set above.
    // The size is measured in units roughly equivalent to the size of a character
    // in the respective UI (1/80 of the full screen width horizontally,
    // 1/25 of the full screen width vertically) where full screen size
    // is 640x480 pixels (y2qt) or 80x25 characters (y2ncurses).
    UI::ReplaceWidget( `id(`create_database_progress_replace_point),
                       `ProgressBar( // Header for a finished ProgressBar:
                                     _("Retrieved printer driver information"),
                                     100,
                                     100
                                   )
                     );
    // Sleep half a second to let the user notice that the progress is finished:
    sleep( 500 );
    UI::CloseDialog();
  }
  else
  { Popup::ClearFeedback();
  }
  return true;
}

/**
 * Try to autodetect printers by calling a bash script
 * which calls "lpinfo -l -v" and processes its output
 * and stores the results as YCP list in a temporary file
 * and then read the temporary file (SCR::Read)
 * to get the YCP list of @ref autodetected_printer_map
 * @return true on success
 */
boolean AutodetectPrinters()
{ // Show feedback because detecting printers takes a few seconds:
  boolean progress_feedback = UI::HasSpecialWidget( `DownloadProgress );
  if( progress_feedback )
  { // Show nice self-updating feedback:
    // Empty an existing progress file so that the DownloadProgress starts at the beginning.
    // Don't care if this command is successful.
    Printerlib::ExecuteBashCommand( "cat /dev/null >" + autodetect_printers_progress_filename );
    UI::OpenDialog( `MinSize( 60, 3,
                              `ReplacePoint( `id(`autodetect_printers_progress_replace_point),
                                             `DownloadProgress( // Header of a DownloadProgress indicator:
                                                                _("Detecting printers..."),
                                                                autodetect_printers_progress_filename,
                                                                // The progress file can grow up to about 3600 bytes
                                                                // if the MAXIMUM_WAIT="60" in tools/autodetect_printers
                                                                // is really needed:
                                                                3700
                                                              )
                                           )
                            )
                  );
  }
  else
  { // Show a simple static busy message:
    Popup::ShowFeedback( // No title for a simple busy message:
                         "",
                         // Busy message:
                         // Body of a Popup::ShowFeedback:
                         _("Detecting printers...")
                       );
  }
  if( ! Printerlib::ExecuteBashCommand( autodetect_printers_commandline ) )
  { if( progress_feedback )
    { UI::CloseDialog();
    }
    else
    { Popup::ClearFeedback();
    }
    Popup::ErrorDetails( // Popup::ErrorDetails message.
                         // Only a simple message because this error does not happen on a normal system
                         // (i.e. a system which is not totally broken or totally messed up).
                         // Do not confuse this error with the case when no printer was autodetected.
                         // The latter results no error.
                         _("Failed to detect printers automatically."),
                         Printerlib::result["stderr"]:""
                       );
    return false;
  }
  if( -1 == SCR::Read( .target.size, autodetected_printers_filename ) )
  { if( progress_feedback )
    { UI::CloseDialog();
    }
    else
    { Popup::ClearFeedback();
    }
    y2milestone( "Error: %1: file does not exist.", autodetected_printers_filename );
    Popup::Error( sformat( // Message of a Popup::Error where %1 will be replaced by the file name.
                           // Only a simple message because this error does not happen on a normal system
                           // (i.e. a system which is not totally broken or totally messed up).
                           _("File %1 does not exist."),
                           autodetected_printers_filename
                         )
                 );
    return false;
  }
  connections = (list< map< string, string > >)SCR::Read( .target.ycp, autodetected_printers_filename );
  if( nil == connections )
  { if( progress_feedback )
    { UI::CloseDialog();
    }
    else
    { Popup::ClearFeedback();
    }
    y2milestone( "Error: Failed to read %1", autodetected_printers_filename );
    Popup::Error( sformat( // Message of a Popup::Error where %1 will be replaced by the file name.
                           // Only a simple message because this error does not happen on a normal system
                           // (i.e. a system which is not totally broken or totally messed up).
                           _("Failed to read %1."),
                           autodetected_printers_filename
                         )
                );
    connections = [];
    return false;
  }
  if( progress_feedback )
  { // Setting the DownloadProgress to 100% by setting its property
    // ExpectedSize to 1 results bad looking output (see above).
    // Therefore DownloadProgress is not used at all but replaced by a 100% ProgressBar
    // which requires a MinWidth with sufficient size (see above).
    UI::ReplaceWidget( `id(`autodetect_printers_progress_replace_point),
                       `ProgressBar( // Header for a finished ProgressBar:
                                     _("Printer detection finished"),
                                     100,
                                     100
                                   )
                     );
    // Sleep half a second to let the user notice that the progress is finished:
    sleep( 500 );
    UI::CloseDialog();
  }
  else
  { Popup::ClearFeedback();
  }
  y2milestone( "Autodetected printers: %1", connections );
  return true;
}

/*
 * Global functions:
 */

/**
 * Autodetect queues by calling a bash script
 * which calls "lpstat -v" and processes its output
 * and stores the results as YCP list in a temporary file
 * and then read the temporary file (SCR::Read)
 * to get the YCP list of @ref autodetected_queue_map
 * @return true on success
 */
global boolean AutodetectQueues()
{ // To be safe invalidate selected_queues_index in any case:
  selected_queues_index = -1;
  if( ! Printerlib::ExecuteBashCommand( autodetect_queues_commandline ) )
  { Popup::ErrorDetails( // Popup::ErrorDetails message.
                         // Only a simple message because this error does not happen on a normal system
                         // (i.e. a system which is not totally broken or totally messed up).
                         // Do not confuse this error with the case when no queue was detected
                         // (e.g. simply because there is no queue). This results no error.
                         _("Failed to detect print queues."),
                         Printerlib::result["stderr"]:""
                       );
    return false;
  }
  if( -1 == SCR::Read( .target.size, autodetected_queues_filename ) )
  { y2milestone( "Error: %1: file does not exist.", autodetected_queues_filename );
    Popup::Error( sformat( // Message of a Popup::Error where %1 will be replaced by the file name.
                           // Only a simple message because this error does not happen on a normal system
                           // (i.e. a system which is not totally broken or totally messed up).
                           _("File %1 does not exist."),
                           autodetected_queues_filename
                         )
                );
    return false;
  }
  queues = (list< map< string, string > >)SCR::Read( .target.ycp, autodetected_queues_filename );
  if( nil == queues )
  { y2milestone( "Error: Failed to read %1", autodetected_queues_filename );
    Popup::Error( sformat( // Message of a Popup::Error where %1 will be replaced by the file name.
                           // Only a simple message because this error does not happen on a normal system
                           // (i.e. a system which is not totally broken or totally messed up).
                           _("Failed to read %1."),
                           autodetected_queues_filename
                         )
                );
    queues = [];
    return false;
  }
  y2milestone( "Autodetected queues: %1", queues );
  return true;
}

/**
 * Determine driver options by calling a bash script
 * which calls "lpoptions -l" and processes its output
 * and stores the results as YCP list in a temporary file
 * and then read the temporary file (SCR::Read)
 * to get the YCP list of @ref autodetected_queue_map
 * @return true on success
 */
global boolean DetermineDriverOptions( string queue_name )
{ if( "" == queue_name )
  { queue_name = queues[selected_queues_index,"name"]:"";
    if( "local" != queues[selected_queues_index,"config"]:"remote" )
    { return false;
    }
  }
  if( "" == queue_name )
  { return false;
  }
  string commandline = determine_printer_driver_options_commandline + queue_name;
  if( ! Printerlib::ExecuteBashCommand( commandline ) )
  { Popup::ErrorDetails( sformat( // Popup::ErrorDetails message where %1 will be replaced by the queue name.
                                  // Only a simple message because this error does not happen on a normal system
                                  // (i.e. a system which is not totally broken or totally messed up).
                                  // Do not confuse this error with the case when no queue was detected
                                  // (e.g. simply because there is no queue). This results no error.
                                  _("Failed to determine driver options for queue %1."),
                                  queue_name
                                ),
                         Printerlib::result["stderr"]:""
                       );
    return false;
  }
  if( -1 == SCR::Read( .target.size, driver_options_filename ) )
  { y2milestone( "Error: %1: file does not exist.", driver_options_filename );
    Popup::Error( sformat( // Message of a Popup::Error where %1 will be replaced by the file name.
                           // Only a simple message because this error does not happen on a normal system
                           // (i.e. a system which is not totally broken or totally messed up).
                           _("File %1 does not exist."),
                           driver_options_filename
                         )
                );
    return false;
  }
  driver_options = (list< map< string, any > >)SCR::Read( .target.ycp, driver_options_filename );
  if( nil == driver_options )
  { y2milestone( "Error: Failed to read %1", driver_options_filename );
    Popup::Error( sformat( // Message of a Popup::Error where %1 will be replaced by the file name.
                           // Only a simple message because this error does not happen on a normal system
                           // (i.e. a system which is not totally broken or totally messed up).
                           _("Failed to read %1."),
                           driver_options_filename
                         )
                );
    driver_options = [];
    return false;
  }
  y2milestone( "Driver options for queue %1: %2", queue_name, driver_options );
  return true;
}

/**
 * Initialize printer configuration (checks only the installed packages) see
 * http://en.opensuse.org/YaST/Development/Printer_Enhancement#Basic_Implementation_Principles:
 * for background information
 * @return true on success
 */
global boolean Read()
{ // Define the progress stages:
  Progress::New( // Header of a Progress::New:
                 _("Initializing Printer Configuration"),
                 " ",
                 1,
                 [ // 1. progress stage name of a Progress::New:
                   _("Check installed packages")
                 ],
                 [ // 1. progress step progress bar title of a Progress::New:
                   _("Checking installed packages..."),
                   // Last progress step progress bar title of a Progress::New:
                   _("Finished")
                 ],
                 ""
               );
  // Progress 1. stage (Check installed packages):
  if( Abort() ) return false;
  // The cups-client RPM is the minimum requirement
  // for accessing remote CUPS servers via a "client-only" config.
  // Therefore abort (return false) if cups-client is not installed:
  if( ! Printerlib::TestAndInstallPackage( "cups-client", "install" ) )
  { return false;
  }
  // The cups RPM ist the default requirement
  // for accessing remote CUPS servers via CUPS Browsing
  // and it is the minimum requirement for local print queues.
  // Therefore try to install cups but because for a "client-only" config
  // only cups-client is required, proceed even if cups is not installed:
  Printerlib::TestAndInstallPackage( "cups", "install" );
  // Progress last stage (progress finished):
  if( Abort() ) return false;
  Progress::NextStage();
  // Sleep half a second to let the user notice that the progress is finished:
  sleep( 500 );
  if( Abort() ) return false;
  Progress::Finish();
  return true;
}

/**
 * Finish printer configuration (does actually nothing except to exit verbosely) see
 * http://en.opensuse.org/YaST/Development/Printer_Enhancement#Basic_Implementation_Principles:
 * for background information
 * @return true in any case (because it only exits)
 */
global boolean Write()
{ // Define the progress stages:
  Progress::New( // Header of a Progress::New:
                 _("Finishing Printer Configuration"),
                 " ",
                 1,
                 [ // 1. progress stage name of a Progress::New:
                   _("Finish printer configuration")
                 ],
                 [ // 1. progress step progress bar title of a Progress::New:
                   _("Finishing printer configuration..."),
                   // Last progress step progress bar title of a Progress::New:
                   _("Finished")
                 ],
                 ""
               );
  // Progress first stage (Finish printer configuration):
  Progress::NextStage();
  // Sleep half a second to let the user notice the progress:
  sleep( 500 );
  // Progress last stage (progress finished):
  Progress::Finish();
  // Sleep half a second to let the user notice that the progress is finished:
  sleep( 500 );
  return true;
}

/**
 * Derive a reasonable model info from an arbitrary description string.
 * @param string from which a model is derived.
 * @return string (possibly the empty string)
 */
global string DeriveModelName( string description )
{ string model_info = "";
  list <string> description_words = splitstring( description, " " );
  // Remove empty words because a sequence of spaces results empty words in description_words
  // for example "ACME  Funprinter" (two spaces!) results ["ACME","","Funprinter"].
  // In Printer.ycp and basicmodify.ycp there are lines like
  //  description = model + " with driver " + description;
  //  new_description = model + " with driver " + new_description;
  // Avoid having "with" and/or "driver" in the model_info.
  description_words = filter( string word,
                              description_words,
                              { return( "" != word && "with" != word && "driver" != word );
                              }
                            );
  // Use the description only if its first word is actually a known manufacturer:
  boolean description_starts_with_known_manufacturer = false;
  foreach( string known_manufacturer,
           known_manufacturers,
           { if( tolower( description_words[0]:"" ) == tolower( known_manufacturer ) )
             { description_starts_with_known_manufacturer = true;
               break;
             }
           }
         );
  if( description_starts_with_known_manufacturer )
  { // After the first word which contains the manufacturer name
    // there are none or up to two words which contain only letters and hyphens (the model name)
    // and then there is a word which contains at least one number (the model series).
    // Therefore the manufacturer and model sub-string can be assumed to be:
    //   One word which contains the manufacturer name,
    //   followed by at most two words which contain only letters and perhaps hyphens
    //   finished by one word which may start with letters and hyphens
    //   but it must contain at least one number followed by whatever characters.
    // It is crucial to take whatever (trailing) character in the model series into account
    // to be on the safe side to distinguish different models
    // (e.g. "HP LaserJet 4" versus "HP LaserJet 4/4M" or "Kyocera FS-1000" versus "Kyocera FS-1000+").
    // For example as egrep regular expression:
    //   lpinfo -m | cut -d' ' -f2-
    //   | egrep -o '^[[:alpha:]]+[[:space:]]+([[:alpha:]-]+[[:space:]]+){0,2}[[:alpha:]-]*[[:digit:]][^[:space:]]*'
    // Of course this best-guess is not 100% correct because it would result for example
    // that "ACME FunPrinter 1000" and "ACME FunPrinter 1000 XL"
    // are considered to be the same model "ACME FunPrinter 1000"
    // but "ACME FunPrinter 1000XL" and "ACME FunPrinter 1000 XL"
    // are considered to be different models "ACME FunPrinter 1000XL" and "ACME FunPrinter 1000":
    boolean skip_the_rest = false;
    integer index = -1;
    description_words = maplist( string word,
                                 description_words,
                                 { if( ! skip_the_rest )
                                   { index = index + 1;
                                     if( 0 == index )
                                     { // Return the manufacturer name:
                                       return word;
                                     }
                                     if( 1 == index || 2 == index )
                                     { // Check for words which look like the model name:
                                       if( "" == deletechars( word, letter_chars + "-" ) )
                                       { // Return a word of the model name:
                                         return word;
                                       }
                                     }
                                     if( 1 == index || 2 == index || 3 == index )
                                     { // Check for a word which looks like the model series:
                                       if( "" != filterchars( word, number_chars ) )
                                       { // Skip the rest after the first model series word:
                                         skip_the_rest = true;
                                         // Return the model series:
                                         return word;
                                       }
                                     }
                                   }
                                 }
                               );
    model_info = mergestring( description_words, " " );
  }
  y2milestone("DeriveModelName: derived '%1' from '%2'", model_info, description );
  return model_info;
}

/**
 * Derive a reasonable model info from an arbitrary description string.
 * @param string from which a model is derived.
 * @return string (possibly the empty string)
 */
global string DeriveDriverFilterString( string driver_filter_input_text )
{ string driver_filter_string = "";
  list <string> words = splitstring( driver_filter_input_text, " " );
  // Remove empty words because a sequence of spaces results empty words in words
  // for example "ACME  Funprinter" (two spaces!) results ["ACME","","Funprinter"].
  // Avoid having meaningless words like "series" or "Serie"
  // and "Mita" (from "Kyocera Mita") in the driver_filter_string
  // (the driver_filter_string "kyocera.*FS-1000" finds the "Kyocera Mita FS-1000+")
  words = filter( string word,
                  words,
                  { return( "" != word
                            && ! issubstring( tolower( word ), "serie" )
                            && "mita" != tolower( word )
                          );
                  }
                );
  if( size( words ) > 0 )
  { // Replace each sequence of spaces in driver_filter_input_text
    // by the regular expression '.*' so that the search result
    // hopefully fits better to what the user expects to get,
    // for example searching with "ACME 1000" should work to also
    // find "ACME FunPrinter 1000" and "ACME Fancy Printer 1000 XL"
    // Besides the regular expression characters '.*'
    // only the special character '+' is also taken into account
    // because this is also a meaningful character in model names
    // for example the '+' at the end of a Kyocera model name
    // indicates that this model has a built-in PostScript interpreter
    // while the model without the '+' understands only PCL.
    driver_filter_string = filterchars( tolower( mergestring( words, ".*" ) ), lower_alnum_chars + ".*+" );
    // Replace '+' by '\\+' which evaluates to '\+' (because of YCP quoting with '\\')
    // to get a '+' character in a word quoted as '\+' because otherwise
    // a '+' character would be interpreded as a special regular expression character
    // when the driver_filter_string is used as pattern for regexpmatch in DriverItems().
    driver_filter_string = mergestring( splitstring( driver_filter_string, "+" ), "\\+" );
  }
  y2milestone("DeriveDriverFilterString: derived '%1' from '%2'", driver_filter_string, driver_filter_input_text );
  return driver_filter_string;
}

/**
 * Create a valid new queue name.
 * @param proposal string from which a valid new queue name is derived.
 * @return string
 */
global string NewQueueName( string proposal )
{ // Only letters [A-Za-z], numbers [0-9], and '_' is more strict than
  // what is actually allowed in CUPS but such queue names are
  // safe to work in whatever mixed printing system environment:
  proposal = filterchars( proposal, alnum_chars + "_" );
  // Use a fallback queue name "printer_1" if the proposal is empty
  // (or has become empty because of the above filterchars)
  // or if the proposal consists only of '_':
  if( "" == proposal || "" == deletechars( proposal, "_" ) )
  { proposal = "printer_1";
  }
  // Remove leading '_' characters from the proposal.
  // For example if the proposal was initially something like "_foo"
  // or if it has become a leading '_' because of the above filterchars:
  if( "_" == substring( proposal, 0, 1) )
  { // findfirstnotof cannot return nil because the proposal cannot consist only of '_':
    proposal = substring( proposal, findfirstnotof( proposal, "_") );
  }
  // Make sure that the queue name starts with a letter,
  // otherwise add a "printer_" prefix:
  if( "" != deletechars( substring( proposal, 0, 1), letter_chars ) )
  { proposal = "printer_" + proposal;
  }
  // Make sure that no queue with the name of the proposal already exists.
  // Otherwise add a sufficient high number at the end:
  string queue_name = proposal;
  integer trailing_number = 0;
  boolean try_again = true;
  while( try_again )
  { try_again = false;
    foreach( map< string, string > queue,
             queues,
             { if( tolower( queue["name"]:"" ) == tolower( queue_name ) )
                 { // If queue_name already exists, add a sufficient high number at the end.
                   if( issubstring( proposal, "_") )
                   { // Remove a trailing number or a plain trailing '_' from the proposal
                     // to avoid that multiple trailing numbers or multiple '_' are added
                     // like "funprinter_1_1" or "printer__1":
                     integer position = findlastof( proposal, "_" );
                     if( "" == deletechars( substring( proposal, position ), number_chars + "_" ) )
                     { // The value of position is the lenght of the substring
                       // up to the last '_' but excluding the last '-'.
                       // For example in "fun_printer_1" the string position of the last '-' is 11
                       // and the first 11 characters in "fun_printer_1" are "fun_printer".
                       proposal = substring( proposal, 0, position );
                     }
                   }
                   trailing_number = trailing_number + 1;
                   queue_name = proposal + "_" + tostring( trailing_number );
                   try_again = true;
                   break;
                 }
               }
             );
    // Avoid an endless loop:
    if( trailing_number > 10000 )
    { queue_name = "";
      break;
    }
  }
  return queue_name;
}

/**
 * Create the list of queues for the Table in the OverviewDialog
 * @return table items
 */
global list QueueItems( boolean local, boolean remote )
{ // Invalidate selected_queues_index to be safe:
  selected_queues_index = -1;
  if( ! AutodetectQueues() )
  { Popup::Error( // Message of a Popup::Error.
                  // Only a simple message because this error does not happen on a normal system
                  // (i.e. a system which is not totally broken or totally messed up).
                  // Do not confuse this error with the case when no queue was detected
                  // (e.g. simply because there is no queue). This results no error.
                  _("Cannot show print queues (failed to detect print queues).")
                );
    // Return an empty list:
    return [];
  }
  integer queues_index = -1;
  list< term > queue_items = [];
  foreach( map< string, string > queue,
           queues,
           { // Set the queues_index to the index number of the actual queue in queues:
             queues_index = queues_index + 1;
             // Use local variables to have shorter variable names:
             string name = queue["name"]:"";
             string uri = queue["uri"]:"";
             string description = queue["description"]:"";
             string location = queue["location"]:"";
             string config = queue["config"]:"remote";
             string is_default = queue["default"]:"";
             string is_disabled = queue["disabled"]:"yes";
             string is_rejecting = queue["rejecting"]:"yes";
             if( name != "" && uri != "" )
             { // Have local or remote stuff in the list depending on whether or not each is requested:
               if( (config=="local" && local) || (config=="class" && local) || (config=="remote" && remote) )
               { if( "local" == config )
                 { // When the queue configuration exists on the local host:
                   config = _("Local");
                 }
                 if( "class" == config )
                 { // When the class configuration exists on the local host:
                   config = _("Class");
                 }
                 if( "remote" == config )
                 { // When the queue configuration exists on a remote machine:
                   config = _("Remote");
                 }
                 if( "yes" == is_default )
                 { // When the queue is the default queue on the local host:
                   is_default = _("Yes");
                 }
                 // When the queue accepts print jobs and printing is enabled:
                 string queue_state = _("Ready");
                 if( "yes" == is_disabled )
                 { // When printing is disabled for the queue:
                   queue_state = _("Printout disabled");
                 }
                 if( "yes" == is_rejecting )
                 { if( "yes" == is_disabled )
                   { // When the queue rejects print jobs and printing is disabled:
                     queue_state = _("Rejecting print jobs, printout disabled");
                   }
                   else
                   { // When the queue rejects print jobs:
                     queue_state = _("Rejecting print jobs");
                   }
                 }
                 // Add trailing spaces because the current YaST UI
                 // has almost no additional space between table columns
                 // in partitcular not where the widest entry in a column is:
                 queue_items = add( queue_items, `item( `id( queues_index ),
                                                        config + " ",
                                                        name + " ",
                                                        description + " ",
                                                        location + " ",
                                                        is_default + " ",
                                                        queue_state
                                                      )
                                  );
                 // Set selected_queues_index when the current_queue_name is in the list
                 // so that the OverviewDialog can preselect the currently used queue
                 // via its id in the list which is the selected_queues_index.
                 // This is correct for any kind of queue ("local", "class", "remote") here
                 // because any queue in the list can be selected in the OverviewDialog:
                 if( current_queue_name == name )
                 { selected_queues_index = queues_index;
                 }
               }
             }
           }
          );
  // Show a fallback text if there are no queues:
  if( size( queue_items ) < 1 )
  { queue_items = add( queue_items, `item( `id( -1 ),
                                           "", "",
                                           // Show a fallback text if there are no queues:
                                           _("There is no print queue."),
                                           "", "", ""
                                         )
                     );
  }
  // Sort the lists according to the queue_string which means sort according to the queue name:
  // queue_item[0] is `id(queues_index), queue_item[1] is the config, queue_item[2] is the queue name:
  return sort( term one_item,
               term another_item,
               queue_items,
               { return tolower(one_item[2]:"") < tolower(another_item[2]:""); }
             );
}

/**
 * Create a list of items from the autodetected connections
 * which is used for the SelectionBox in the BasicAddDialog and BasicModifyDialog.
 * This function is also called in connectionwizard.ycp and in printer_proposal.ycp.
 * @param connection_filter_string string of a search string to return only matching connections
 *        (return all connections if connection_filter_string is the empty string)
 * @return list of connections (i.e. DeviceURI, model, and info of the "lpinfo -l -v" output)
 */
global list ConnectionItems( string connection_filter_string )
{ // Invalidate selected_connections_index and selected_ppds_index to be safe:
  selected_connections_index = -1;
  selected_ppds_index = -1;
  // Autodetect printers if the connections list is empty:
  if( size( connections ) < 1 || "MoreConnections" == connection_filter_string )
  { list< map< string, string > > connection_wizard_connections = [];
    // Save existing connections which have been manually added by the connection wizard:
    foreach( map< string, string > connection,
             connections,
             { if( "ConnectionWizardDialog" == connection["class"]:"" )
               { connection_wizard_connections = add( connection_wizard_connections, connection );
               }
             }
           );
    // AutodetectPrinters overwrites the existing connections list:
    if( ! AutodetectPrinters() )
    { Popup::Error( // Message of a Popup::Error.
                    // Only a simple message because before the function AutodetectPrinters
                    // was called and this function would have shown more specific messages.
                    _("Failed to autodetect printers.")
                  );
    }
    // The connection wizard prepends its manually added connections to the connections list.
    // Therefore the connection_wizard_connections are also prepended to the connections list.
    // There is an error in the YaST documentation regarding "merge" for lists:
    // It reads "Interprets two lists as sets" which would
    // remove duplicates in each list before the merge.
    // Actually merge([1,2,2,3],[2,3,3,4]) results [1,2,2,3,2,3,3,4]
    // which is needed here to preserve any entry to be on the safe side:
    connections = (list <map <string, string> >)merge( connection_wizard_connections, connections );
  }
  // Determine if there is at least one "hp:/usb/" DeviceURI
  // and if there is at least one "parallel:/" DeviceURI
  boolean hp_usb_uri_exists = false;
  boolean parallel_uri_exists = false;
  foreach( map< string, string > connection_entry,
           connections,
           { if( "hp:/usb/" == substring( connection_entry["uri"]:"", 0, 8 ) )
             { hp_usb_uri_exists = true;
             }
             if( "parallel:/" == substring( connection_entry["uri"]:"", 0, 10 ) )
             { parallel_uri_exists = true;
             }
           }
         );
  // Make a list of uri, model, and info entries of the connections
  // and take the connection_filter_string into account (if it is not the empty string).
  list< term > connection_items = [];
  list< term > sorted_connection_items = [];
  list< string > already_added_uris = [];
  boolean an_item_was_added = false;
  integer connections_index = -1;
  string uri = "";
  string model = "";
  string info = "";
  string class = "";
  foreach( map< string, string > connection_entry,
           connections,
           { an_item_was_added = false;
             // Set the connections_index to the index number of the current connection_entry:
             connections_index = connections_index + 1;
             // Use local variables to have shorter variable names:
             uri = connection_entry["uri"]:"";
             model = connection_entry["model"]:"";
             info = connection_entry["info"]:"";
             class = connection_entry["class"]:"";
             // Skip effectively empty (i.e. useless) entries:
             if( "" == uri )
             { continue;
             }
             // Skip duplicate URIs because it does not make sense
             // to show more than one entry with the same URI because
             // for CUPS only different URIs distinguish different devices.
             // For example two same USB printer models without different serial numbers
             // are indistinguishable for CUPS so that any printout would be sent only
             // to one of both devices (probably the first one in the USB device list):
             if( contains( already_added_uris, uri ) )
             { y2milestone( "skipped connection_entry with duplicate DeviceURI: '%1'", connection_entry );
               continue;
             }
             // Take the filter_string into account:
             if( "" == connection_filter_string )
             { // Add trailing spaces because the current YaST UI
               // has almost no additional space between table columns
               // in partitcular not where the widest entry in a column is:
               connection_items = add( connection_items, `item( `id( connections_index ),
                                                                model + " ",
                                                                uri + " ",
                                                                info
                                                              )
                                     );
               an_item_was_added = true;
             }
             else
             { // If the connection_filter_string is the special string "BasicAddDialog",
               // do a special filtering for those connections which are suitable
               // for the BasicAddDialog (i.e. only parallel, usb, and hp connections):
               if( "BasicAddDialog" == connection_filter_string )
               { if( "parallel:/" == substring( uri, 0, 10 )
                     || "usb:/" == substring( uri, 0, 5 )
                     || "hp:/" == substring( uri, 0, 4 )
                     || "ConnectionWizardDialog" == class
                   )
                 { // Skip "usb://HP/" DeviceURIs if it was not created by the Connection Wizard
                   // and if there is at least one "hp:/usb/" DeviceURI
                   // so that the "hp:/usb/" DeviceURI is used with preference.
                   // The "usb://HP/" DeviceURI is still available via "MoreConnections".
                   // It can happen that a "usb://HP/" DeviceURI is skipped
                   // without a matching "hp:/usb/" DeviceURI because
                   // the "hp" backend lists only devices which are known as supported by HPLIP.
                   // If there are two HP printers connected but only one is supported by HPLIP,
                   // there exists one "hp:/usb/" DeviceURI and therefore all "usb://HP/" DeviceURIs
                   // are skipped even the one for the HP printer which is unknown to HPLIP.
                   // But this is no real problem because all "usb://HP/" DeviceURIs are still
                   // available via "MoreConnections".
                   // Actually it is even good that HP printers which are unknown to HPLIP
                   // are skipped by default because usually we do not provide a driver
                   // for such printers so that the extra-cklick on "MoreConnections" may
                   // make the user aware that something is fishy with this particular model
                   // so that the user hopefully pays more attention which driver he selects.
                   // If a HP printer is unknown to HPLIP it does not mean that it is unsupported
                   // (it does also not mean that it is unsupported by HPLIP) because
                   // it could be simply a new model which is not yet known to HPLIP
                   // but compatible to a known model. In this case the user must pay attention
                   // which exact driver he selects manually for his particular model.
                   if( "usb://hp/" == tolower( substring( uri, 0, 9 ) )
                       && hp_usb_uri_exists
                       && class != "ConnectionWizardDialog"
                     )
                   { y2milestone( "skipped 'usb://HP/' DeviceURI '%1'", uri );
                   }
                   else
                   { // Skip "hp:/par/" DeviceURIs if it was not created by the Connection Wizard
                     // and if there is at least one "parallel:/" DeviceURI
                     // so that the "parallel:/" DeviceURI is used with preference.
                     // The reason for this preference is that for my LaserJet 1220
                     // which is accessible via "parallel:/dev/lp0" and
                     // via "hp:/par/HP_LaserJet_1220?device=/dev/parport0"
                     // it does not work for the "hp:/par/" DeviceURI and in /var/log/messages there is
                     // ... parport0: io/hpmud/pp.c 517: compat_write_data transfer stalled
                     // ... parport0: io/hpmud/musb.c 1339: unable to write data
                     //     hp:/par/HP_LaserJet_1220?device=/dev/parport0: Resource temporarily unavailable
                     // so that the generic "parallel:/" DeviceURI seems to be the better fail-safe default.
                     // It should not happen that a "hp:/par/" DeviceURI is skipped without
                     // having a matching  generic "parallel:/" DeviceURI available.
                     // The "hp:/par/" DeviceURI is still available via "MoreConnections".
                     if( "hp:/par/" == tolower( substring( uri, 0, 8 ) )
                         && parallel_uri_exists
                         && class != "ConnectionWizardDialog"
                       )
                     { y2milestone( "skipped 'hp:/par/' DeviceURI '%1'", uri );
                     }
                     else
                     { // Add trailing spaces because the current YaST UI
                       // has almost no additional space between table columns
                       // in partitcular not where the widest entry in a column is:
                       connection_items = add( connection_items, `item( `id( connections_index ),
                                                                        model + " ",
                                                                        uri + " ",
                                                                        info
                                                                      )
                                             );
                       an_item_was_added = true;
                     }
                   }
                 }
               }
               else
               { // If the connection_filter_string is the special string "MoreConnections",
                 // do a special filtering for those connections which are supposed to work
                 // i.e. where the uri seems to be a complete DeviceURI e.g. "socket://192.168.1.2:9100"
                 // and not just an URI scheme like a plain "socket".
                 // It doesn't matter if backends (i.e. schemes) with non alphanumeric characters
                 // are skipped here because for unusual backends there is the "Connection Wizard":
                 if( "MoreConnections" == connection_filter_string )
                 { // if( issubstring ( uri , ":/" ) )
                   if( regexpmatch( uri, "^[" + alnum_chars + "]+:/" )
                       || "ConnectionWizardDialog" == class
                     )
                   { // Add trailing spaces because the current YaST UI
                     // has almost no additional space between table columns
                     // in partitcular not where the widest entry in a column is:
                     connection_items = add( connection_items, `item( `id( connections_index ),
                                                                      model + " ",
                                                                      uri + " ",
                                                                      info
                                                                    )
                                           );
                     an_item_was_added = true;
                   }
                 }
                 else
                 { // If the connection_filter_string is a usual non-empty string,
                   // test whether the model matches to the connection_filter_string:
                   if( regexpmatch( tolower( model ), tolower( connection_filter_string ) ) )
                   { // Add trailing spaces because the current YaST UI
                     // has almost no additional space between table columns
                     // in partitcular not where the widest entry in a column is:
                     connection_items = add( connection_items, `item( `id( connections_index ),
                                                                      model + " ",
                                                                      uri + " ",
                                                                      info
                                                                    )
                                           );
                     an_item_was_added = true;
                   }
                 }
               }
             }
             if( an_item_was_added )
             { already_added_uris = add( already_added_uris, uri );
               if( current_device_uri == uri )
               { // Set selected_connections_index when the current_device_uri is in the list so that
                 // BasicAddDialog and BasicModifyDialog can preselect the currently used connection
                 // via its id in the list which is the selected_connections_index.
                 selected_connections_index = connections_index;
               }
             }
           }
         );
  // Sort the list according to the model:
  // connection_item[0] is `id(connections_index)
  // connection_item[1] is the model
  // connection_item[2] is the uri
  // connection_item[3] is the info
  // The comparison expression must evaluate to a boolean value and
  // it must be irreflexive (e.g. "<" instead of "<=") which results conditions like
  // 'a condition for one item' and 'not the same condition for the other item'
  sorted_connection_items = sort( term one_item,
                                  term another_item,
                                  connection_items,
                                  { // Have entries which are "created by the connection wizard"
                                    // or "modified by the connection wizard" topmost:
                                    // Have short local variable names for shorter comparison expression
                                    // and avoid multiple complicated accesses of same elements in an list:
                                    string this = one_item[3]:"";
                                    string that = another_item[3]:"";
                                    string connection_wizard_match = "by the connection wizard";
                                    // This is an entry where the info is "created/modified by the connection wizard"
                                    // and that is no such entry:
                                    if( issubstring( this, connection_wizard_match )
                                        && ( ! issubstring( that, connection_wizard_match ) )
                                      ) return true;
                                    // This is an entry where the info is not "created/modified by the connection wizard"
                                    // but that is such an entry:
                                    if( ( ! issubstring( this, connection_wizard_match ) )
                                        && issubstring( that, connection_wizard_match )
                                      ) return false;
                                    // If both are "created/modified by the connection wizard"
                                    // or if both are not "created/modified by the connection wizard"
                                    // have entries with a valid model name topmost:
                                    // Have short local variable names for shorter comparison expression
                                    // and avoid multiple complicated accesses of same elements in an list:
                                    this = one_item[1]:"";
                                    that = another_item[1]:"";
                                    // This is an entry where the model is neither empty nor "Unknown"
                                    // and that is no such entry:
                                    if( ( this != "" && tolower( this ) != "unknown" )
                                        && ( that == "" || tolower( that ) == "unknown" )
                                      ) return true;
                                    // This is an entry where the model is empty or "Unknown"
                                    // and that is no such entry:
                                    if( ( this == "" || tolower( this ) == "unknown" )
                                        && ( that != "" && tolower( that ) != "unknown" )
                                      ) return false;
                                    // Fall back to alphabetical sorting of the model name:
                                    return tolower(this) < tolower(that);
                                  }
                                );
  if( size( sorted_connection_items ) < 1 )
  { sorted_connection_items = [ `item( `id( -1 ),
                                       "",
                                       // Show a fallback text if there are no connections.
                                       _("No connections."),
                                       // A hint what to do if there are no connections.
                                       // 'More Connections' and 'Connection Wizard' are
                                       // button lables and must be translated accordingly:
                                       _("Try 'More Connections' or use the 'Connection Wizard'.")
                                     )
                              ];
  }
  return sorted_connection_items;
}

/**
 * Create a list of items from the PPD database entries
 * which is used for the SelectionBox in the BasicAddDialog and SelectDriverDialog
 * @param driver_filter_string string of a search string to return only matching PPDs
 *        (return all PPDs if driver_filter_string is the empty string)
 * @return list of drivers (i.e. the NickName entries of the PPDs)
 */
global list DriverItems( string driver_filter_string, boolean preselection )
{ // Create the driver database only if the ppds list is empty:
  if( size( ppds ) < 1 )
  { if( ! CreateDatabase() )
    { Popup::Error( // Message of a Popup::Error.
                    // Only a simple message because before the function CreateDatabase
                    // was called and this function would have shown more specific messages.
                    _("Failed to create the printer driver database.")
                  );
      // Return an empty list:
      return [];
    }
  }
  list< term > driver_items = [];
  list< term > sorted_driver_items = [];
  string driver_string = "";
  // If the driver_filter_string is the special string "BasicAddDialog",
  // produce a special fast output which is suitable to be shown
  // initially when the BasicAddDialog is launched:
  if( "BasicAddDialog" == driver_filter_string )
  { if( preselection
        && selected_ppds_index >= 0
      )
    { // If a driver was already selected, show this driver and preselect it
      // if preselection should be done at all:
      driver_string = ppds[selected_ppds_index,"nickname"]:"" + " [" + ppds[selected_ppds_index,"ppd"]:"" + "]";
      driver_items = [ `item( `id( selected_ppds_index ), driver_string, true ) ];
    }
    else
    { // If no driver was already selected, show a meaningful text as
      // fallback entry for a SelectionBox when no connection is selected.
      // It will be replaced by real content, when a connection is selected.
      driver_string = _("Select a connection, then matching drivers show up here.");
      driver_items =  [ `item( `id( -1 ), driver_string ) ];
      // Invalidate selected_ppds_index to be on the safe side.
      // Otherwise it is possible to set up a queue with a previously selected driver
      // even if the current dialog does not show it.
      selected_ppds_index = -1;
    }
    return driver_items;
  }
  // Make a list of the NickName entries of the PPDs according to the PPD database
  // and take the driver_filter_string into account (if it is not the empty string)
  // and try to preselect an entry according to a selected autodetected printer:
  Popup::ShowFeedback( // No title for a simple busy message:
                       "",
                       // Busy message:
                       // Body of a Popup::ShowFeedback:
                       _("Determining matching printer drivers...")
                     );
  y2milestone( "The driver_filter_string is: '%1'", driver_filter_string );
  integer ppds_index = -1;
  foreach( map< string, string > ppd_entry,
           ppds,
           { // Set the ppds_index to the index number of the current ppd_entry:
             ppds_index = ppds_index + 1;
             // Use local variables to have shorter variable names:
             string ppd = ppd_entry["ppd"]:"";
             string nickname = ppd_entry["nickname"]:"";
             string deviceID = ppd_entry["deviceID"]:"";
             string language = ppd_entry["language"]:"";
             // Skip effectively empty (i.e. useless) entries:
             if( "" == ppd || "" == nickname )
             { continue;
             }
             // Build the entry:
             driver_string = nickname + " [" + ppd + "]";
             // Take the filter_string into account:
             if( "" == driver_filter_string )
             { driver_items = add( driver_items, `item( `id( ppds_index ), driver_string ) );
             }
             else
             { // If the driver_filter_string is a non-empty string,
               // test whether nickname or deviceID matches to the driver_filter_string.
               // Only the special character '+' is also taken into account because
               // this is sometimes also a meaningful character in the model name
               // for example the '+' at the end of a Kyocera model name
               // indicates that this model has a built-in PostScript interpreter
               // while the model without the '+' understands only PCL.
               string unified_nickname = filterchars( tolower( nickname ), lower_alnum_chars + "+" );
               string unified_deviceID = filterchars( tolower( deviceID ), lower_alnum_chars + "+" );
               if( regexpmatch( unified_nickname, driver_filter_string )
                   || regexpmatch( unified_deviceID, driver_filter_string )
                 )
               { driver_items = add( driver_items, `item( `id( ppds_index ), driver_string ) );
               }
             }
           }
         );
  if( size( driver_items ) == 0 )
  { // If the driver_items list is empty (e.g. because of a too restrictive driver_filter_string),
    // show a meaningful text as fallback entry ('More Drivers' is a button label).
    driver_string = _("No matching driver found. Change the search string or try 'More Drivers'.");
    driver_items =  [ `item( `id( -1 ), driver_string ) ];
    // Invalidate selected_ppds_index to be on the safe side.
    // Otherwise it is possible to set up a queue with a previously selected driver
    // even if the current dialog does not show it.
    selected_ppds_index = -1;
    Popup::ClearFeedback();
    return driver_items;
  }
  // More feedback to stay in contact with the user
  // if the list of driver_items is very long
  // e.g. when all PPDs are shown (several thousand)
  // or when all PPDs for "HP" are shown (more than 1000)
  // or when all PPDs for "Epson" are shown (more than 500).
  // Then it takes some time to determine if a PPD can be preselected
  // and to sort the list.
  // Actually it is the sorting which takes most of the time but for the user
  // a feedback message like "sorting list of drivers" is meaningless.
  if( size( driver_items ) > 500 )
  { Popup::ShowFeedback( // No title for a simple busy message:
                         "",
                         // Busy message:
                         // Body of a Popup::ShowFeedback:
                         _("Processing many printer drivers. Please wait...")
                       );
    // Sleep half a second to let the user notice the feedback in any case:
    sleep( 500 );
  }
  // Preselect the entry in the driver_items list which matches
  // to the current value of selected_ppds_index
  // if such an entry exists in driver_items (e.g. because of the
  // driver_filter_string there may be no such entry in driver_items) and
  // if preselection should be done at all:
  integer driver_items_index = -1;
  integer selected_driver_items_index = -1;
  // Determine if such an entry exists:
  foreach( term driver_item,
           driver_items,
           { // Set the driver_items_index to the index number of the current driver_item:
             driver_items_index = driver_items_index + 1;
             // driver_item[0] is the term `id(ppds_index) and id[0] is the ppds_index
             // so that driver_item[0,0] is the ppds_index:
             if( selected_ppds_index == driver_item[0,0]:-1 )
             { selected_driver_items_index = driver_items_index;
               break;
             }
           }
         );
  if( preselection
      && selected_driver_items_index >= 0
    )
  { // Actually preselect the entry and set selected_ppds_index accordingly.
    // driver_items[selected_driver_items_index] is a driver_item and
    // driver_item[1] is the driver_string and
    // driver_item[0] is the term `id(ppds_index) and id[0] is the ppds_index
    // so that driver_item[0,0] is the ppds_index so that
    // driver_items[selected_driver_items_index,0,0] is the ppds_index:
    selected_ppds_index = driver_items[selected_driver_items_index,0,0]:-1;
    driver_string = driver_items[selected_driver_items_index,1]:"";
    driver_items[selected_driver_items_index] = `item( `id( selected_ppds_index ), driver_string, true );
    y2milestone( "Already preselected driver: '%1'", driver_string );
  }
  else
  { // Invalidate selected_ppds_index to be on the safe side.
    // Otherwise it is possible to set up a queue with a previously selected driver
    // even if the current dialog does not show it.
    selected_ppds_index = -1;
  }
  // Sort the driver_items list.
  // There are two kind of sorting the driver_items list.
  // By default, the list is sorted according to the driver_string
  // which is basically sorting according to NickName (first part of driver_string)
  // which is basically sorting according to Manufacturer and ModelName (first parts of NickName).
  // But when all elements in the driver_items list belong to the same model,
  // it would be nicer to sort according to which PPD looks most suitable for the model
  // (i.e. according to the above step-by-step approach to preselect a PPD).
  // The real problem is that the NickName is a plain sequence of words which describe
  // manufacturer, model, driver, and optionally whether the driver is recommended
  // but there are no delimiters which mark where the model info begins and ends.
  // Some NickName examples (note the one missing ')' after recommended):
  //   Brother HL-10h Foomatic/lj4dith
  //   Canon BJC-600 Foomatic/bjc610a0.upp
  //   Canon S600 Foomatic/bj8pa06n.upp (recommended)
  //   DesignJet 5000PS (recommended)
  //   designjet 5500ps (recommended)
  //   EPSON AL-2600 PS3 v3016.103
  //   Epson E 100 - CUPS+Gutenprint v5.0.0 Simplified
  //   Epson Stylus Color 8 3 - CUPS+Gutenprint v5.0.0
  //   Epson Stylus Color PRO Foomatic/stcolor (recommended)
  //   EPSON Stylus Color Series CUPS v1.2
  //   Epson Stylus Photo EX - CUPS+Gutenprint v5.0.0 Simplified
  //   Epson Stylus Photo EX3 - CUPS+Gutenprint v5.0.0
  //   Generic IBM-Compatible Dot Matrix Printer Foomatic/ibmpro (recommended)
  //   Generic PCL 4 Printer - CUPS+Gutenprint v5.0.0 Simplified
  //   Gestetner MP1100/DSm7110 PS plain PostScript
  //   Gestetner P7026n PS PostScript+Foomatic (recommended)
  //   HP 2500CM Foomatic/hpijs
  //   HP Color LaserJet 2500 - CUPS+Gutenprint v5.0.0 black and white only
  //   HP Color LaserJet Series PCL 6 CUPS
  //   HP DesignJet 2500CP PS3 v3010.103 (recommended
  //   HP DeskJet 2500CM - CUPS+Gutenprint v5.0.0
  //   HP e-printer e20 Foomatic/hpijs (recommended)
  //   HP LaserJet 4 Foomatic/ljet4 (recommended)
  //   HP LaserJet 4 Plus v2013.111 Postscript (recommended)
  //   HP LaserJet 4/4M 600DPI Postscript (recommended)
  //   HP PSC 2500 Foomatic/hpijs (recommended)
  //   Kyocera FS-1000 Foomatic/ljet4
  //   Kyocera FS-1000+ Foomatic/Postscript
  //   Kyocera KM-3530 Foomatic/Postscript (recommended)
  //   Kyocera Mita KM-3530
  //   Kyocera Mita KM-4230/5230
  //   NRG 10515/10518/10512 Foomatic/pxlmono (recommended)
  //   NRG 10515/10518/10512 PXL Foomatic/pxlmono (recommended)
  //   OKI C5450 PS
  //   OKI C5700(PS)
  //   OKIPAGE 14i
  //   Oki Okipage 14ex Foomatic/ljet4
  //   Okidata Okipage 14ex - CUPS+Gutenprint v5.0.0
  //   TOSHIBA e-STUDIO3510c Series PS
  //   Toshiba e-Studio 3511 Foomatic/Postscript (recommended)
  //   Toshiba e-Studio 351c Foomatic/Postscript (recommended)
  // It is not possible to extract manufacturer and model reliable from the NickName.
  // Only a best-guess which is as fail-safe as possible can be done.
  // An usual full qualified model description looks like:
  //   ACME FunPrinter 1000
  //   ACME Fun Printer 1000
  //   ACME FunPrinter 1000XL
  //   ACME Fun Printer 1000 XL
  //   ACME Fun Printer 1000-XL
  //   ACME 1000XL
  //   ACME FunPrinter Pro 1000XL
  //   ACME Pro-1000-XL
  //   ACME Ltd. Fun Printer Pro 1000 XL
  // After at least one words which contains only letters (the manufacturer name)
  // there are none or up to two words which contain only letters and hyphens (the model name)
  // and then there is a word which contains at least one number (the model series).
  // Therefore the manufacturer and model sub-string can be assumed to be:
  //   One word which contains only letters,
  //   followed by at most two words which contain only letters and perhaps hyphens
  //   finished by one word which may start with letters and hyphens
  //   but it must contain at least one number followed by whatever characters.
  // It is crucial to take whatever (trailing) character in the model series into account
  // to be on the safe side to distinguish different models
  // (e.g. "HP LaserJet 4" versus "HP LaserJet 4/4M" or "Kyocera FS-1000" versus "Kyocera FS-1000+").
  // For example as egrep regular expression:
  //   lpinfo -m | cut -d' ' -f2-
  //   | egrep -o '^[[:alpha:]]+[[:space:]]+([[:alpha:]-]+[[:space:]]+){0,2}[[:alpha:]-]*[[:digit:]][^[:space:]]*'
  // Of course this best-guess is not 100% correct because it would result for example
  // that "ACME FunPrinter 1000" and "ACME FunPrinter 1000 XL" are considered to be the same model
  // but "ACME FunPrinter 1000XL" and "ACME FunPrinter 1000 XL" are considered to be different models.
  // The latter results no problem because the special sorting is only done
  // when all entries in the driver_items list seem to belong to the same model.
  // But the former results a small problem because the special sorting is done here
  // for different models with similar names.
  // To mitigate such problems, the special sorting is only done
  // when the driver_items list is short so that the user can easily survey the whole list.
  // For example the PPDs in openSUSE 10.2
  //   lpinfo -m | cut -d' ' -f2-
  //   | egrep -o '^[[:alpha:]]+[[:space:]]+([[:alpha:]-]+[[:space:]]+){0,2}[[:alpha:]-]*[[:digit:]][^[:space:]]*'
  //   | sort -f | uniq -i -c | sort -n
  // results that the maximum lenght of the driver_items list for the same model is 13
  // (in openSUSE 10.2 the 13 entries are for the "Kyocera FS-600").
  // In openSUSE 10.2 there are only 4 models (HP LaserJet 4, 4100, 9000 and the Kyocera FS-600)
  // for which more than 9 entries exist (11 for LaserJet 4100 and 12 for LaserJet 4 and 9000)
  // but there are 23 models with 9 entries (there is no no model with 10 entries).
  // Since there is /usr/lib/cups/driver/gutenprint.* the Gutenprint entries are listed twice:
  // Once for the readymade PPDs in /usr/share/cups/model/gutenprint/
  // and additionally a second entry from /usr/lib/cups/driver/gutenprint.*
  // which increases the maximum lenght of the driver_items list for the same model
  // in openSUSE 11.0 up to 17 for the Kyocera FS-600 and 16 for the HP LaserJet 4
  // and several other HP LaserJet and Kyocera models with more than 10 entries
  // so that a maximum of 20 entries for the special sorting should be o.k.:
  if( size( driver_items ) <= 20 )
  { // Test if all entries in the driver_items list seem to be for the same model.
    list< integer > position = [];
    string manufacturer_and_model = "";
    driver_items_index = -1;
    foreach( term driver_item,
             driver_items,
             { // Set the driver_items_index to the index number of the current driver_item:
               driver_items_index = driver_items_index + 1;
               if( 0 == driver_items_index )
               { // Determine the assumed manufacturer and model sub-string from the first driver item
                 // (driver_item[0] is `id(ppds_index) and driver_item[1] is the driver_string):
                 position = regexppos( driver_item[1]:"", "^[[:alpha:]]+[[:space:]]+([[:alpha:]-]+[[:space:]]+){0,2}[[:alpha:]-]*[[:digit:]][^[:space:]]*" );
                 // driver_item[1] is the driver_string which is nickname + ppd:
                 manufacturer_and_model = substring( driver_item[1]:"", position[0]:0, position[1]:0 );
                 // Break if manufacturer_and_model is empty or seems too short to be really meaningful
                 // (shortest manufacturer and model strings are e.g. "HP PSC 500", "Epson E 100", "Star LC 90"):
                 if( "" == manufacturer_and_model || size( manufacturer_and_model ) < 10 )
                 { driver_items_index = -1;
                   break;
                 }
               }
               else
               { // Test if the manufacturer_and_model string matches for all subsequent driver items:
                 string other_manufacturer_and_model = substring( driver_item[1]:"", position[0]:0, position[1]:0 );
                 other_manufacturer_and_model = filterchars( tolower( other_manufacturer_and_model ), lower_alnum_chars );
                 if( other_manufacturer_and_model != filterchars( tolower( manufacturer_and_model ), lower_alnum_chars ) )
                 { driver_items_index = -1;
                   break;
                 }
               }
             }
           );
    if( driver_items_index >= 0 )
    { // All entries in the driver_items list seem to belong to the same model:
      y2milestone( "All entries in the driver_items list seem to belong to the same model: '%1'", manufacturer_and_model );
      // Return a list which is sorted according to which PPD looks most suitable for the model.
      // Define the regular expression strings for comparisons which are
      // used for the special sorting of the drivers list.
      // Define also the matching weights for the special sorting of the drivers list.
      // The weight values are of the form 2^n so that the sum of all weights up to n-1
      // is less than the weight for the layer n comparison.
      // The smallest weight is 1 for the fallback alphabetical comparison.
      // Therefore the special comparisons here start with 2 up to whatever layer is needed.
      // The double \\ in YCP results a single \ in the actual string value
      // so that in the end there is \( and \) and \[ in the regular expression.
      // This is a PPD which was downloaded by the user:
      string downloaded = "\\[downloaded/";
      integer downloaded_weight = 32;
      // This is a recommended PPD:
      string recommended = "\\(recommended\\)";
      integer recommended_weight = 16;
      // This is an original PPD from a manufacturer:
      string manufacturerPPD = "\\[manufacturer-PPDs/";
      integer manufacturerPPD_weight = 8;
      // This is a PPD from the HPLIP project (HP Linux Imaging and Printing):
      string hplip = "/hplip/";
      integer hplip_weight = 4;
      // This is a PPD for a ESC/P2 driver from Gutenprint (formerly Gimp-Print)
      string gutenprint_escp2 = "\\[gutenprint/stp-escp2-";
      integer gutenprint_escp2_weight = 2;
      // This is a PPD for the ljet4 driver from OpenPrinting (formerly LinuxPrinting):
      string foomatic_ljet4 = "Foomatic/ljet4";
      integer foomatic_ljet4_weight = 2;
      // The comparison expression must evaluate to a boolean value and
      // it must be irreflexive (e.g. "<" instead of "<=").
      // Therefore the comparison expression calculates weights for both items
      // so that at the end a simple numerical comparison of the weights is sufficient.
      // (driver_item[0] is `id(ppds_index) and driver_item[1] is the driver_string):
      sorted_driver_items = sort( term one_item,
                                  term another_item,
                                  driver_items,
                                  { // Have short local variable names for shorter expressions
                                    // and avoid multiple complicated accesses of same elements in a list:
                                    string this = one_item[1]:"";
                                    string that = another_item[1]:"";
                                    integer this_weight = 0;
                                    integer that_weight = 0;
                                    // Sum up the weights:
                                    // Add the weight if it is a PPD which was downloaded by the user:
                                    if( regexpmatch( this, downloaded ) )
                                    { this_weight = this_weight + downloaded_weight;
                                    }
                                    if( regexpmatch( that, downloaded ) )
                                    { that_weight = that_weight + downloaded_weight;
                                    }
                                    // Add the weight if it is a recommended PPD:
                                    if( regexpmatch( this, recommended ) )
                                    { this_weight = this_weight + recommended_weight;
                                    }
                                    if( regexpmatch( that, recommended ) )
                                    { that_weight = that_weight + recommended_weight;
                                    }
                                    // Add the weight if it is an original PPD from a manufacturer:
                                    if( regexpmatch( this, manufacturerPPD ) )
                                    { this_weight = this_weight + manufacturerPPD_weight;
                                    }
                                    if( regexpmatch( that, manufacturerPPD ) )
                                    { that_weight = that_weight + manufacturerPPD_weight;
                                    }
                                    // Add the weight if it is a PPD from the HPLIP project:
                                    if( regexpmatch( this, hplip ) )
                                    { this_weight = this_weight + hplip_weight;
                                    }
                                    if( regexpmatch( that, hplip ) )
                                    { that_weight = that_weight + hplip_weight;
                                    }
                                    // Add the weight if it is a PPD for a ESC/P2 driver from Gutenprint:
                                    if( regexpmatch( this, gutenprint_escp2 ) )
                                    { this_weight = this_weight + gutenprint_escp2_weight;
                                    }
                                    if( regexpmatch( that, gutenprint_escp2 ) )
                                    { that_weight = that_weight + gutenprint_escp2_weight;
                                    }
                                    // Add the weight if it is a PPD for the ljet4 driver from OpenPrinting:
                                    if( regexpmatch( this, foomatic_ljet4 ) )
                                    { this_weight = this_weight + foomatic_ljet4_weight;
                                    }
                                    if( regexpmatch( that, foomatic_ljet4 ) )
                                    { that_weight = that_weight + foomatic_ljet4_weight;
                                    }
                                    // Add the weight 1 for the fallback alphabetical comparison:
                                    if( tolower(this) < tolower(that) )
                                    { this_weight = this_weight + 1;
                                    }
                                    if( tolower(that) < tolower(this) )
                                    { that_weight = that_weight + 1;
                                    }
                                    // Return the result of the numerical comparison of the weights.
                                    // Return true to get this alphabetically sorted before that:
                                    return this_weight > that_weight;
                                  }
                                );
      // If neither a downloaded PPD nor a recommended PPD nor a manufacturer PPD exists,
      // do not preselect any PPD because in this case there is nothing which indicates
      // that a particular PPD is known to work - i.e. it looks really problematic
      // so that now it is only the user who can make a decission in this case
      // (even if all he can do is guessing but then he knows at least what he did).
      // Because of the above sorting it is sufficient to test only the first entry in sorted_driver_items.
      // sorted_driver_items[0] is the first entry in sorted_driver_items and
      // sorted_driver_item[1] is the driver_string and
      // sorted_driver_item[0] is the term `id(ppds_index) and id[0] is the ppds_index
      // so that sorted_driver_item[0,0] is the ppds_index so that
      // sorted_driver_items[0,0,0] is the ppds_index:
      driver_string = sorted_driver_items[0,1]:"";
      // Preselect the first entry in sorted_driver_items
      // if preselection should be done at all and
      // if there is not alredy an entry preselected and if a preselectable PPD exists:
      if( preselection
          && -1 == selected_ppds_index
          && ( regexpmatch( driver_string, downloaded )
               || regexpmatch( driver_string, recommended )
               || regexpmatch( driver_string, manufacturerPPD )
             )
        )
      { // Preselect the first entry and set selected_ppds_index accordingly.
        selected_ppds_index = sorted_driver_items[0,0,0]:-1;
        // The first entry in a SelectionBox is always preselected in the GUI
        // (it does not help to have all items in a SelectionBox with 'false' as third argument).
        // Do not have this entry preselected (i.e. no 'true' as a third argument)
        // because in the BasicModifyDialog the currently used driver is additionally prepended
        // and then the currently used driver must be preselected by default because
        // the currently used driver is then the very first entry in the SelectionBox.
        y2milestone( "Preselected driver: '%1'", driver_string );
      }
      // The specially sorted_driver_items list has a maximum of 20 entries which is o.k. for the log:
      y2milestone( "sorted_driver_items: %1", sorted_driver_items );
      if( selected_ppds_index < 0 )
      { // When no driver was preselected, prepend a dummy entry
        // because the first entry in a SelectionBox is always preselected in the GUI
        // (it does not help to have all items in a SelectionBox with 'false' as third argument).
        // Do not have this dummy entry preselected (i.e. no 'true' as a third argument)
        // because in the BasicModifyDialog the currently used driver is additionally prepended
        // and then the currently used driver must be preselected by default because
        // the currently used driver is then the very first entry in the SelectionBox.
        sorted_driver_items = prepend( sorted_driver_items, `item( `id( -1 ), _("Select a driver.") ) );
        y2milestone( "No driver preselected." );
      }
      Popup::ClearFeedback();
      return sorted_driver_items;
    }
  }
  // Return a list which is sorted according to the driver_string which is basically
  // sorting according to Nickname which is the first part of the driver_string
  // (driver_item[0] is `id(ppds_index) and driver_item[1] is the driver_string).
  sorted_driver_items = sort( term one_item,
                              term another_item,
                              driver_items,
                              { return tolower(one_item[1]:"") < tolower(another_item[1]:"");
                              }
                            );
  if( selected_ppds_index < 0 )
  { // When no driver was preselected, prepend a dummy entry
    // because the first entry in a SelectionBox is always preselected in the GUI
    // (it does not help to have all items in a SelectionBox with 'false' as third argument).
    // Do not have this dummy entry preselected (i.e. no 'true' as a third argument)
    // because in the BasicModifyDialog the currently used driver is additionally prepended
    // and then the currently used driver must be preselected by default because
    // the currently used driver is then the very first entry in the SelectionBox.
    sorted_driver_items = prepend( sorted_driver_items, `item( `id( -1 ), _("Select a driver.") ) );
    y2milestone( "No driver preselected." );
  }
  Popup::ClearFeedback();
  return sorted_driver_items;
}

/**
 * Add new queue or overwrite existing queue
 * @return true on success
 */
global boolean AddQueue( string queue_name, string default_paper_size )
{ // Delete ' characters because they are used for quoting in the bash commandline below:
  queue_name = deletechars( queue_name, "'" );
  string uri = deletechars( connections[selected_connections_index,"uri"]:"", "'" );
  string ppd = deletechars( ppds[selected_ppds_index,"ppd"]:"", "'" );
  string model = deletechars( connections[selected_connections_index,"model"]:"", "'" );
  string description = deletechars( ppds[selected_ppds_index,"nickname"]:"", "'" );
  if( "" != description
      && "" != model
      && "unknown" != tolower( model )
      && ! issubstring( filterchars( tolower( description ), lower_alnum_chars ),
                        filterchars( tolower( model ), lower_alnum_chars )
                      )
    )
  { description = model + " with driver " + description;
  }
  if( "" == uri || "" == ppd || "" == queue_name )
  { y2milestone( "Cannot set up queue because of empty mandatory parameter: queue_name = '%1', uri = '%2', ppd = '%3'", queue_name, uri, ppd );
    current_queue_name = "";
    current_device_uri = "";
    return false;
  }
  // Note the bash quotings of the parameters with ' characters:
  string commandline = "/usr/sbin/lpadmin -h localhost -p '" + queue_name + "' -v '" + uri + "' -m '" + ppd + "' -D '" + description + "' -E";
  if( ! Printerlib::ExecuteBashCommand( commandline ) )
  { Popup::ErrorDetails( sformat( // Popup::ErrorDetails message where %1 will be replaced by the queue name.
                                  // Only a simple message because this error does not happen on a normal system
                                  // (i.e. a system which is not totally broken or totally messed up).
                                  _("Failed to add queue %1."),
                                  queue_name
                                ),
                                Printerlib::result["stderr"]:""
                       );
    // When the PPD file is totally broken, it will not be accepted by the cupsd.
    // In this case lpadmin shows an error message and exits with non-zero exit code
    // but nevertherless the queue is created without a PPD file, i.e. as a raw queue.
    // It seems that first of all lpadmin creates the queue and then
    // in a second step it is modified to assign the PPD file,
    // see http://www.cups.org/newsgroups.php?gcups.bugs+T+Q"STR+%232949"
    // Because this AddQueue function is only used to add a not-yet-existing queue,
    // it is safe to try to remove the queue in any case if the setup had failed
    // but ignore any possible errors here (e.g. when the queue does not exist).
    Printerlib::ExecuteBashCommand( "/usr/sbin/lpadmin -h localhost -x '" + queue_name + "'" );
    current_queue_name = "";
    current_device_uri = "";
    return false;
  }
  // Try to set the requested default_paper_size if it is an available choice for this queue.
  // If no default_paper_size is requested, the CUPS default is used.
  // For the CUPS 1.3 default see http://www.cups.org/str.php?L2846
  // For CUPS 1.4 the default depends on the "DefaultPaperSize" setting in cupsd.conf
  // see https://bugzilla.novell.com/show_bug.cgi?id=395760
  // and http://www.cups.org/str.php?L2848
  if( "" != default_paper_size )
  { // Since CUPS 1.4 there is a weird timing-effect regarding which defaults 'lpoptions -l' reports
    // after the defaults have been changed directly after a new queue was set up
    // see https://bugzilla.novell.com/show_bug.cgi?id=520642
    // and http://www.cups.org/str.php?L3264
    // Regardless of the DirtyCleanInterval setting it works when there is one second delay
    // between a new queue was set up and before its defaults were changed:
    sleep( 1000 );
    // The following command fails intentionally if the queue has no PPD file - i.e. when it is a "raw" queue
    // (a queue with a "System V style interface script" cannot be set up with YaST).
    // '\>' is used to find an available choice also when it is the last value on the line.
    // Note the YCP quoting: \\< becomes \< and \\> becomes \> in the commandline.
    commandline = "lpoptions -h localhost -p '" + queue_name + "' -l | grep '^PageSize.*\\<" + default_paper_size + "\\>'";
    if( Printerlib::ExecuteBashCommand( commandline ) )
    { commandline = "/usr/sbin/lpadmin -h localhost -p '" + queue_name + "' -o 'PageSize=" + default_paper_size + "'";
      // Do not care if it fails to set the default_paper_size (i.e. show no error message to the user)
      // because the default_paper_size setting is nice to have but not mandatoty for a working queue:
      Printerlib::ExecuteBashCommand( commandline );
    }
  }
  current_queue_name = queue_name;
  current_device_uri = uri;
  return true;
}

/**
 * Delete queue
 * @return true on success
 */
global boolean DeleteQueue( string queue_name )
{ // To be safe invalidate selected_queues_index, current_queue_name, and current_device_uri in any case:
  selected_queues_index = -1;
  current_queue_name = "";
  current_device_uri = "";
  if( "" == queue_name )
  { queue_name = queues[selected_queues_index,"name"]:"";
    if( "local" != queues[selected_queues_index,"config"]:"remote"
        && "class" != queues[selected_queues_index,"config"]:"remote"
      )
    { y2milestone( "Cannot delete '%1' because it is no local configuration", queue_name );
      return false;
    }
  }
  // Delete ' characters because they are used for quoting in the bash commandline below:
  queue_name = deletechars( queue_name, "'" );
  if( "" == queue_name )
  { y2milestone( "Cannot delete queue because queue_name is the empty string" );
    return false;
  }
  // Note the bash quoting of the queue_name string with ' characters:
  string commandline = "/usr/sbin/lpadmin -h localhost -x '" + queue_name + "'";
  if( ! Printerlib::ExecuteBashCommand( commandline ) )
  { Popup::ErrorDetails( sformat( // Popup::ErrorDetails message where %1 will be replaced by the queue name.
                                  // Only a simple message because this error does not happen on a normal system
                                  // (i.e. a system which is not totally broken or totally messed up).
                                  _("Failed to delete configuration %1."),
                                  queue_name
                                ),
                                Printerlib::result["stderr"]:""
                       );
    return false;
  }
  return true;
}

/**
 * Create a list of tree widget items from the driver_options
 * which is used for the tree widget in the DriverOptionsDialog
 * @param selected_keyword string of an already selected keyword
 *        to have the matching values list opened by default in the tree
 * @param selected_value string of a selected value which matches to the selected_keyword string
 *        to show this value in the tree (which might be different than the value of the queue)
 * @return list of driver options items for a tree widget
 */
global list DriverOptionItems( string selected_keyword, string selected_value )
{ // Run DetermineDriverOptions if the driver_options list is empty:
  if( size( driver_options ) < 1 )
  { if( ! DetermineDriverOptions( "" ) )
    { Popup::Error( // Message of a Popup::Error.
                    // Only a simple message because this is only a fallback case
                    // which should not happen at all:
                    _("Failed to determine the driver options.")
                  );
      // Return at least a list with only a fallback string so that the user is informed:
      return [ _("No driver options available") ];
    }
  }
  list driver_options_tree_items_list = [];
  integer driver_options_index = -1;
  integer pagesize_option_index = -1;
  foreach( map< string, any > driver_option,
           driver_options,
           { // Set the driver_options_index to the index number of the actual driver_option in driver_options:
             driver_options_index = driver_options_index + 1;
             boolean opened = false;
             string keyword = driver_option["keyword"]:"";
             // Show only options with at least one real value.
             // Even if there is no choice when there is only one value,
             // the user should at least see what the setting is.
             // Test for '>1' because last entry in the "values" list is always an emtpy string.
             // Additionally do not show the PageRegion option because
             // the media size should usually only be set via the PageSize option
             // and the PageRegion has a special purpose (see the Adobe PPD spec.)
             // so that from the user's point of view PageRegion looks like
             // a confusing duplicate of PageSize:
             if( "" != keyword
                 && size( driver_option["values"]:[] ) > 1
                 && "PageRegion" != keyword
               )
             { if( "PageSize" == keyword )
               { pagesize_option_index = driver_options_index;
               }
               if( selected_keyword == keyword )
               { opened = true;
               }
               string option_name = keyword;
               if( "" != driver_option["translation"]:"" )
               { option_name = option_name + " / " + driver_option["translation"]:"";
               }
               // Provide the values as list of items i.e. specified as `item("string"):
               list value_items_list = [];
               string current_value_setting = "";
               foreach( string value,
                        driver_option["values"]:[],
                        { // At least the last value is always the emtpy string.
                          // Do not show an emtpy string as possible choice to the user:
                          if( "" != value )
                          { if( "*" == substring( value, 0, 1 ) )
                            { // The currently set value for the queue is marked by a leading '*'.
                              // Do not show the leading '*' to the user:
                              value = substring( value, 1 );
                              current_value_setting = value;
                            }
                            if( selected_keyword == keyword
                                && selected_value == value
                              )
                            { // Dummy info for a currently selected item:
                              string dummy_info = _("currently selected");
                              if( current_value_setting == value  )
                              { // Info when a currently selected item is already set:
                                dummy_info = _("current setting of the print queue");
                              }
                              // It seems to be impossible to preselect the currently selected item.
                              // In particular `item( value, true) does not preselect it.
                              // Therefore a dirty hack is used to mark the currently selected item
                              // only by means of the user interface because changing the content
                              // of the string value (e.g. like ">> value <<") is even more evil
                              // because then the content is no longer a valid option value keyword.
                              // Therefore a dummy item list is added (an empty list doesn't work)
                              // which lets the user interface show a '+' before the value
                              // but because the added item list is meaningless we keep it closed:
                              value_items_list = add( value_items_list, `item( value, false, [ dummy_info ] ) );
                            }
                            else
                            { value_items_list = add( value_items_list, `item( value ) );
                            }
                          }
                        }
                      );
               // Have the value list opened for the currently selected keyword:
               if( selected_keyword == keyword )
               { opened = true;
                 // If the user had selected another value for this keyword
                 // store it so that if is know for subsequent DriverOptionItems calls:
                 if( "" != selected_value )
                 { driver_options[driver_options_index] = add( driver_options[driver_options_index]:$[],
                                                               "selected",
                                                               selected_value
                                                             );
                 }
               }
               // Override the current_value_setting if the user has selected another value:
               if( "" != driver_options[driver_options_index,"selected"]:"" )
               { current_value_setting = driver_options[driver_options_index,"selected"]:"";
               }
               if( "" != current_value_setting )
               { // Show the currently set value at the tree item name of the particular option
                 // so that the user can see it even when the respective tree item is not opened.
                 // By default the option items are not opened to provide a concise overview:
                 option_name = option_name + " : " + current_value_setting;
               }
               driver_options_tree_items_list = add( driver_options_tree_items_list,
                                                     `item( `id( keyword ),
                                                            option_name,
                                                            opened,
                                                            value_items_list
                                                          )
                                                    );
             }
           }
         );
  // Have the PageSize option topmost:
  if( pagesize_option_index >= 0 )
  { term pagesize_option_tree_item = driver_options_tree_items_list[pagesize_option_index]:`item("no PageSize option");
    driver_options_tree_items_list = remove( driver_options_tree_items_list, pagesize_option_index );
    driver_options_tree_items_list = prepend( driver_options_tree_items_list, pagesize_option_tree_item );
  }
  if( size( driver_options_tree_items_list ) < 1 )
  { // Return at least a list with only a fallback string so that the user is informed:
    return [ _("No driver options available") ];
  }
  return driver_options_tree_items_list;
}

/**
 * Get all printer settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings) {
        Printerlib::WriteClientSettings(settings["cups_remote_server"]:$[]);
	Printerlib::WriteCupsSettings(settings["server_settings"]:$[]);
    return true;
}

/**
 * Dump the printer settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
    Printerlib::DetermineClientOnly();
    Printer::AutodetectQueues();
    list <map> p_queues = filter(map queue, Printer::queues, { return (queue["config"]:""=="local"); });
    map exp = $[
//	"queues" : p_queues,
//	"filters" : Printerlib::ExportFilters( p_queues ),
	"server_settings" : (map)SCR::Read(.cups.server),
	"cups_remote_server" : (map)SCR::Read(.cups.client)
	];
//y2internal("export %1", exp);
   return exp;
}

/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages() {
    // TODO FIXME: your code here...
    return $[ "install":[], "remove":[] ];
}

/* EOF */
}
