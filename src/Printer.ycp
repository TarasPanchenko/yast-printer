/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:        modules/Printer.ycp
 * Package:     Configuration of printer
 * Summary:     Printer settings, input and output functions
 * Authors:     Johannes Meixner <jsmeix@suse.de>
 *
 * $Id: Printer.ycp 27914 2006-02-13 14:32:08Z locilka $
 *
 * Representation of the configuration of printer.
 * Input and output routines.
 */

{

module "Printer";
textdomain "printer";

import "Progress";
import "Report";
import "Summary";
import "Message";
import "Popup";
import "Printerlib";

/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 */
global boolean proposal_valid = false;

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global boolean() AbortFunction = Modified;

/**
 * Abort function
 * @return boolean return true if abort
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
    {
        return AbortFunction () == true;
    }
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2debug("modified=%1",modified);
    return modified;
}

// Settings:
// Define all variables needed for configuration of a printer:

/**
 * Explicite listing of all alphanumeric ASCII characters.
 * The reason is that in certain special locales for example [a-z] is not equivalent
 * to "abcdefghijklmnopqrstuvwxyz" because in certain special languages the 'z' is
 * not the last character in the alphabet, e.g. the Estonian alphabet ends
 * with ... s ... z ... t u v w ... x y (non-ASCII characters omitted here)
 * so that [a-z] would exclude t u v w x y in an Estonian locale.
 * Therefore uppercase and lowercase characters are both explicitely listed
 * to avoid any unexpected result e.g. of "tolower(uppercase_characters)".
 */
global string number_chars = "0123456789";
global string upper_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
global string lower_chars = "abcdefghijklmnopqrstuvwxyz";
global string letter_chars = upper_chars + lower_chars;
global string alnum_chars = number_chars + letter_chars;
global string lower_alnum_chars = number_chars + lower_chars;

/**
 * PPD database:
 * the database is created anew in Printer::CreateDatabase() which calls
 * the bash script "/usr/lib/YaST2/bin/create_ppd_database"
 * which outputs on stdout a YCP list of @ref printer_ppd_map
 * where the last list entry is an emtpy map.
 * Printer::CreateDatabase() leaves manufacturer and modelname empty because
 * it would take several minutes (instead of a few seconds) to fill them up
 * (see the comments in create_ppd_database). Both fields can be filled up
 * during runtime for particular PPDs (e.g. for a more detailed PPD selection
 * among several PPDs which match to a particular model or manufacturer
 * but not for all the thousands of PPDs which are installed in the system).
 * @struct printer_ppd_map
 * $[ "ppd":"the PPD file name with path below /usr/share/cups/model/ (required)",
 *    "nickname":"the NickName entry in the PPD (required)",
 *    "deviceID":"the 1284DeviceID entry in the PPD (may be the empty string)",
 *    "language":"the language of the PPD, usually "en" (may be the empty string)",
 *    "manufacturer":"the Manufacturer entry in the PPD (initially the empty string)",
 *    "modelname":"the ModelName entry in the PPD (initially the empty string)"
 *  ]
 */
global list< map< string, string > > ppds = [];

/**
 * Selected PPD database index:
 * The index in the PPD database list (of PPD maps)
 * for the PPD which was selected by the user.
 * Preset to -1 which indicates that no PPD is selected.
 */
global integer selected_ppds_index = -1;

/**
 * Autodetected printers:
 * Determined at runtime via Printer::AutodetectPrinters() which calls the bash script
 * "/usr/lib/YaST2/bin/autodetect_printers"
 * which outputs on stdout a YCP list of @ref autodetected_printer_map
 * where the last list entry is an emtpy map.
 * @struct autodetected_printer_map
 * $[ "uri":"the full CUPS DeviceURI (required)",
 *    "model":"the manufacturer and model, often "Unknown" (may be the empty string)",
 *    "deviceID":"what the printer reported as its device ID (often the empty string)",
 *    "info":"arbitrary info regarding this connection (may be the empty string)",
 *    "class":"the kind of connection, e.g. "direct","network","file" (may be the empty string)"
 *  ]
 */
global list< map< string, string > > connections = [];

/**
 * Selected autodetected printer index:
 * The index in the autodetected printers list (of connection maps)
 * for the connection which was selected by the user.
 * Preset to -1 which indicates that no connection is selected.
 */
global integer selected_connections_index = -1;

/**
 * Autodetected queues:
 * Determined at runtime via Printer::AutodetectQueues() which calls the bash script
 * "/usr/lib/YaST2/bin/autodetect_print_queues"
 * which outputs on stdout a YCP list of @ref autodetected_queue_map
 * where the last list entry is an emtpy map.
 * @struct autodetected_queue_map
 * $[ "name":"the queue name (required)",
 *    "uri":"the full CUPS DeviceURI (required)",
 *    "description":"(may be the empty string)",
 *    "location":"(may be the empty string)",
 *    "ppd":"/etc/cups/ppd/<queue-name>.ppd (may be the empty string)",
 *    "default":"'yes' if it is a DefaultPrinter in /etc/cups/printers.conf, otherwise the empty string",
 *    "disabled":"'yes' if printing is disabled, otherwise 'no'",
 *    "rejecting":"'yes' if print job are rejected, otherwise 'no'",
 *    "config":"either 'local' if the queue exists in /etc/cups/printers.conf, otherwise 'remote' (required)"
 *  ]
 */
global list< map< string, string > > queues = [];

/**
 * Selected queue index:
 * The index in the queues list (of queue maps)
 * for the queue which was selected by the user.
 * Preset to -1 which indicates that no queue is selected.
 */
global integer selected_queues_index = -1;

/**
 * Queue filter string:
 * Can be either "all" or "local" or "remote" depending on
 * which kind of queues from the queues list (of queue maps)
 * the user wants to see in the overview dialog.
 * Preset to "all" which indicates that all queues are shown.
 */
global boolean queue_filter_show_local = true;
global boolean queue_filter_show_remote = true;

/**
 * Driver options (options in the PPD for one specific existing queue):
 * Determined at runtime via Printer::DetermineDriverOptions( "queue_name")
*  which calls the bash script "/usr/lib/YaST2/bin/determine_printer_driver_options"
 * which outputs on stdout a YCP list of @ref driver_option_map
 * where the last list entry is an emtpy map.
 * @struct driver_option_map
 * $[ "keyword":"the main keyword of the option in the PPD (required)",
 *    "translation":"the translation string of the main keyword (may be the empty string)",
 *    "values":["a list of the option keywords in the PPD (at least one non-empty entry is required)
 *               i.e. the values for the main keyword (i.e. the values for this option)
 *               where the currently set option value of the queue is marked by a leading '*'
 *               and where the last list entry is an emtpy string"],
 *    "selected":"the curently selected value in the DriverOptionsDialog (may be the empty string)"
 *  ]
 */
global list< map< string, any > > driver_options = [];


/*
 * Local variables:
 */
string database_filename = "/var/lib/YaST2/printer_ppd_database.ycp";
string create_database_commandline = "/usr/lib/YaST2/bin/create_printer_ppd_database >" + database_filename;
string autodetect_printers_progress_filename = "/var/lib/YaST2/autodetect_printers.progress" ;
string autodetected_printers_filename = "/var/lib/YaST2/autodetected_printers.ycp" ;
string autodetect_printers_commandline = "export PROGRESS=" + autodetect_printers_progress_filename + " ; /usr/lib/YaST2/bin/autodetect_printers >" + autodetected_printers_filename;
string autodetected_queues_filename = "/var/lib/YaST2/autodetected_print_queues.ycp" ;
string autodetect_queues_commandline = "/usr/lib/YaST2/bin/autodetect_print_queues >" + autodetected_queues_filename;
string driver_options_filename = "/var/lib/YaST2/printer_driver_options.ycp";
string determine_printer_driver_options_commandline = "/usr/lib/YaST2/bin/determine_printer_driver_options >" + driver_options_filename + " ";

/*
 * Global functions which are called by the local functions below:
 */


/*
 * Local functions which are called by the global functions below:
 */

/**
 * Create the PPD database by calling a bash script
 * which calls "lpinfo -l -m" and processes its output
 * and stores the results as YCP list in a temporary file
 * and then read the temporary file (SCR::Read)
 * to get the YCP list of @ref printer_ppd_map
 * @return true on success
 */
boolean CreateDatabase()
{ // Show feedback because creating the printer driver database takes a few seconds:
  boolean progress_feedback = UI::HasSpecialWidget( `DownloadProgress );
  if( progress_feedback )
  { // Show nice self-updating feedback:
    // Empty an existing database file so that the DownloadProgress starts at the beginning.
    // Don't care if this command is successful. All what matters is if CreateDatabase() works.
    Printerlib::ExecuteBashCommand( "cat /dev/null >" + database_filename );
    UI::OpenDialog( `MinSize( 60, 3,
                              `ReplacePoint( `id(`create_database_progress_replace_point),
                                             `DownloadProgress( // Header of a DownloadProgress indicator:
                                                                _("Retrieving printer driver information..."),
                                                                database_filename,
                                                                // On my openSUSE 10.3 the size is about 1700000 bytes:
                                                                1900000
                                                              )
                                           )
                            )
                  );
  }
  else
  { // Show a simple static busy message:
    Popup::ShowFeedback( // No title for a simple busy message:
                         "",
                         // Busy message:
                         // Body of a Popup::ShowFeedback:
                         _("Retrieving printer driver information...")
                       );
  }
  if( ! Printerlib::ExecuteBashCommand( create_database_commandline ) )
  { if( progress_feedback )
    { UI::CloseDialog();
    }
    else
    { Popup::ClearFeedback();
    }
    Report::Error( // Message of a Report::Error.
                   // Only a simple message because this error does not happen on a normal system
                   // (i.e. a system which is not totally broken or totally messed up).
                   _("Failed to create PPD database.")
                 );
    return false;
  }
  if( -1 == SCR::Read( .target.size, database_filename ) )
  { if( progress_feedback )
    { UI::CloseDialog();
    }
    else
    { Popup::ClearFeedback();
    }
    y2milestone( "Error: %1: file does not exist.", database_filename );
    Report::Error( sformat( // Message of a Report::Error where %1 will be replaced by the file name.
                            // Only a simple message because this error does not happen on a normal system
                            // (i.e. a system which is not totally broken or totally messed up).
                            _("File %1 does not exist."),
                            database_filename
                          )
                 );
    return false;
  }
  ppds = (list< map< string, string > >)SCR::Read( .target.ycp, database_filename );
  if( nil == connections )
  { if( progress_feedback )
    { UI::CloseDialog();
    }
    else
    { Popup::ClearFeedback();
    }
    y2milestone( "Error: Failed to read %1", database_filename );
    Report::Error( sformat( // Message of a Report::Error where %1 will be replaced by the file name.
                            // Only a simple message because this error does not happen on a normal system
                            // (i.e. a system which is not totally broken or totally messed up).
                            _("Failed to read %1."),
                            database_filename
                          )
                 );
    ppds = [];
    return false;
  }
  if( progress_feedback )
  { // Setting the DownloadProgress to 100% by setting its property
    // ExpectedSize to 1 (setting it to 0 results wrong output) by calling
    // UI::ChangeWidget( `id(`create_database_progress), `ExpectedSize, 1 )
    // results bad looking output because the DownloadProgress widget is visible re-drawn
    // first with a small 1% initially starting progress bar which then jumps up to 100%
    // but what is intended is that the current progress bar jumps directly up to 100%.
    // Therefore DownloadProgress is not used at all but replaced by a 100% ProgressBar.
    // Because ProgressBar has a different default width than DownloadProgress,
    // a MinWidth which is sufficient for both is set above.
    // The size is measured in units roughly equivalent to the size of a character
    // in the respective UI (1/80 of the full screen width horizontally,
    // 1/25 of the full screen width vertically) where full screen size
    // is 640x480 pixels (y2qt) or 80x25 characters (y2ncurses).
    UI::ReplaceWidget( `id(`create_database_progress_replace_point),
                       `ProgressBar( // Header for a finished ProgressBar:
                                     _("Retrieved printer driver information"),
                                     100,
                                     100
                                   )
                     );
    // Sleep half a second to let the user notice that the progress is finished:
    sleep( 500 );
    UI::CloseDialog();
  }
  else
  { Popup::ClearFeedback();
  }
  return true;
}

/**
 * Try to autodetect printers by calling a bash script
 * which calls "lpinfo -l -v" and processes its output
 * and stores the results as YCP list in a temporary file
 * and then read the temporary file (SCR::Read)
 * to get the YCP list of @ref autodetected_printer_map
 * @return true on success
 */
boolean AutodetectPrinters()
{ // Show feedback because detecting printers takes a few seconds:
  boolean progress_feedback = UI::HasSpecialWidget( `DownloadProgress );
  if( progress_feedback )
  { // Show nice self-updating feedback:
    // Empty an existing progress file so that the DownloadProgress starts at the beginning.
    // Don't care if this command is successful.
    Printerlib::ExecuteBashCommand( "cat /dev/null >" + autodetect_printers_progress_filename );
    UI::OpenDialog( `MinSize( 60, 3,
                              `ReplacePoint( `id(`autodetect_printers_progress_replace_point),
                                             `DownloadProgress( // Header of a DownloadProgress indicator:
                                                                _("Detecting printers..."),
                                                                autodetect_printers_progress_filename,
                                                                // The progress file can grow up to about 3600 bytes
                                                                // if the MAXIMUM_WAIT="60" in tools/autodetect_printers
                                                                // is really needed:
                                                                3700
                                                              )
                                           )
                            )
                  );
  }
  else
  { // Show a simple static busy message:
    Popup::ShowFeedback( // No title for a simple busy message:
                         "",
                         // Busy message:
                         // Body of a Popup::ShowFeedback:
                         _("Detecting printers...")
                       );
  }
  if( ! Printerlib::ExecuteBashCommand( autodetect_printers_commandline ) )
  { if( progress_feedback )
    { UI::CloseDialog();
    }
    else
    { Popup::ClearFeedback();
    }
    Report::Error( // Message of a Report::Error.
                   // Only a simple message because this error does not happen on a normal system
                   // (i.e. a system which is not totally broken or totally messed up).
                   // Do not confuse this error with the case when no printer was autodetected.
                   // The latter results no error.
                   _("Failed to detect printers automatically.")
                 );
    return false;
  }
  if( -1 == SCR::Read( .target.size, autodetected_printers_filename ) )
  { if( progress_feedback )
    { UI::CloseDialog();
    }
    else
    { Popup::ClearFeedback();
    }
    y2milestone( "Error: %1: file does not exist.", autodetected_printers_filename );
    Report::Error( sformat( // Message of a Report::Error where %1 will be replaced by the file name.
                            // Only a simple message because this error does not happen on a normal system
                            // (i.e. a system which is not totally broken or totally messed up).
                            _("File %1 does not exist."),
                            autodetected_printers_filename
                          )
                 );
    return false;
  }
  connections = (list< map< string, string > >)SCR::Read( .target.ycp, autodetected_printers_filename );
  if( nil == connections )
  { if( progress_feedback )
    { UI::CloseDialog();
    }
    else
    { Popup::ClearFeedback();
    }
    y2milestone( "Error: Failed to read %1", autodetected_printers_filename );
    Report::Error( sformat( // Message of a Report::Error where %1 will be replaced by the file name.
                            // Only a simple message because this error does not happen on a normal system
                            // (i.e. a system which is not totally broken or totally messed up).
                            _("Failed to read %1."),
                            autodetected_printers_filename
                          )
                 );
    connections = [];
    return false;
  }
  if( progress_feedback )
  { // Setting the DownloadProgress to 100% by setting its property
    // ExpectedSize to 1 results bad looking output (see above).
    // Therefore DownloadProgress is not used at all but replaced by a 100% ProgressBar
    // which requires a MinWidth with sufficient size (see above).
    UI::ReplaceWidget( `id(`autodetect_printers_progress_replace_point),
                       `ProgressBar( // Header for a finished ProgressBar:
                                     _("Detected printers"),
                                     100,
                                     100
                                   )
                     );
    // Sleep half a second to let the user notice that the progress is finished:
    sleep( 500 );
    UI::CloseDialog();
  }
  else
  { Popup::ClearFeedback();
  }
  y2milestone( "Autodetected printers: %1", connections );
  return true;
}

/*
 * Global functions:
 */

/**
 * Autodetect queues by calling a bash script
 * which calls "lpstat -v" and processes its output
 * and stores the results as YCP list in a temporary file
 * and then read the temporary file (SCR::Read)
 * to get the YCP list of @ref autodetected_queue_map
 * @return true on success
 */
global boolean AutodetectQueues()
{ // To be safe invalidate selected_queues_index in any case:
  selected_queues_index = -1;
  if( ! Printerlib::ExecuteBashCommand( autodetect_queues_commandline ) )
  { Report::Error( // Message of a Report::Error.
                   // Only a simple message because this error does not happen on a normal system
                   // (i.e. a system which is not totally broken or totally messed up).
                   // Do not confuse this error with the case when no queue was detected
                   // (e.g. simply because there is no queue). This results no error.
                   _("Failed to detect print queues.")
                 );
    return false;
  }
  if( -1 == SCR::Read( .target.size, autodetected_queues_filename ) )
  { y2milestone( "Error: %1: file does not exist.", autodetected_queues_filename );
    Report::Error( sformat( // Message of a Report::Error where %1 will be replaced by the file name.
                            // Only a simple message because this error does not happen on a normal system
                            // (i.e. a system which is not totally broken or totally messed up).
                            _("File %1 does not exist."),
                            autodetected_queues_filename
                          )
                 );
    return false;
  }
  queues = (list< map< string, string > >)SCR::Read( .target.ycp, autodetected_queues_filename );
  if( nil == queues )
  { y2milestone( "Error: Failed to read %1", autodetected_queues_filename );
    Report::Error( sformat( // Message of a Report::Error where %1 will be replaced by the file name.
                            // Only a simple message because this error does not happen on a normal system
                            // (i.e. a system which is not totally broken or totally messed up).
                            _("Failed to read %1."),
                            autodetected_queues_filename
                          )
                 );
    queues = [];
    return false;
  }
  y2milestone( "Autodetected queues: %1", queues );
  return true;
}

/**
 * Determine driver options by calling a bash script
 * which calls "lpoptions -l" and processes its output
 * and stores the results as YCP list in a temporary file
 * and then read the temporary file (SCR::Read)
 * to get the YCP list of @ref autodetected_queue_map
 * @return true on success
 */
global boolean DetermineDriverOptions( string queue_name )
{ if( "" == queue_name )
  { queue_name = queues[selected_queues_index,"name"]:"";
    if( "local" != queues[selected_queues_index,"config"]:"remote" )
    { return false;
    }
  }
  if( "" == queue_name )
  { return false;
  }
  string commandline = determine_printer_driver_options_commandline + queue_name;
  if( ! Printerlib::ExecuteBashCommand( commandline ) )
  { Report::Error( sformat( // Message of a Report::Error where %1 will be replaced by the queue name.
                            // Only a simple message because this error does not happen on a normal system
                            // (i.e. a system which is not totally broken or totally messed up).
                            // Do not confuse this error with the case when no queue was detected
                            // (e.g. simply because there is no queue). This results no error.
                            _("Failed to determine driver options for queue %1."),
                            queue_name
                          )
                 );
    return false;
  }
  if( -1 == SCR::Read( .target.size, driver_options_filename ) )
  { y2milestone( "Error: %1: file does not exist.", driver_options_filename );
    Report::Error( sformat( // Message of a Report::Error where %1 will be replaced by the file name.
                            // Only a simple message because this error does not happen on a normal system
                            // (i.e. a system which is not totally broken or totally messed up).
                            _("File %1 does not exist."),
                            driver_options_filename
                          )
                 );
    return false;
  }
  driver_options = (list< map< string, any > >)SCR::Read( .target.ycp, driver_options_filename );
  if( nil == driver_options )
  { y2milestone( "Error: Failed to read %1", driver_options_filename );
    Report::Error( sformat( // Message of a Report::Error where %1 will be replaced by the file name.
                            // Only a simple message because this error does not happen on a normal system
                            // (i.e. a system which is not totally broken or totally messed up).
                            _("Failed to read %1."),
                            driver_options_filename
                          )
                 );
    driver_options = [];
    return false;
  }
  y2milestone( "Driver options for queue %1: %2", queue_name, driver_options );
  return true;
}

/**
 * Read all printer settings
 * @return true on success
 */
global boolean Read()
{ // Define the progress stages:
  Progress::New( // Header of a Progress::New:
                 _("Initializing Printer Configuration"),
                 " ",
                 1,
                 [ // 1. progress stage name of a Progress::New:
                   _("Autodetect already configured printers"),
                 ],
                 [ // 1. progress step progress bar title of a Progress::New:
                   _("Autodetecting already configured printers..."),
                   // Last progress step progress bar title of a Progress::New:
                   _("Finished")
                 ],
                 ""
               );
  // Progress 1. stage (Autodetect already configured printers):
  if( Abort() ) return false;
  Printerlib::Read();
  Progress::NextStage();
  // Progress last stage (progress finished):
  if( Abort() ) return false;
  Progress::Finish();
  // Sleep half a second to let the user notice that the progress is finished:
  sleep( 500 );
  if( Abort() ) return false;
  return true;
}

/**
 * Write printer settings:
 * - Finish printer configuration
 * @return true on success
 */
global boolean Write()
{ // Define the progress stages:
  Progress::New( // Header of a Progress::New:
                 _("Finishing Printer Configuration"),
                 " ",
                 0,
                 [ // 1. progress stage name of a Progress::New:
                   _("Finish printer configuration")
                 ],
                 [ // 1. progress step progress bar title of a Progress::New:
                   _("Finishing printer configuration..."),
                   // Last progress step progress bar title of a Progress::New:
                   _("Finished")
                 ],
                 ""
               );
  // Progress first stage (Finish printer configuration):
  if( Abort() ) return false;
  Progress::NextStage();
  // Sleep half a second to let the user notice the progress:
  sleep( 500 );
  // Progress last stage (progress finished):
  if( Abort() ) return false;
  Progress::Finish();
  // Sleep half a second to let the user notice that the progress is finished:
  sleep( 500 );
  if( Abort() ) return false;
  return true;
}

/**
 * Create a valid new queue name.
 * @param proposal string from which a valid new queue name is derived.
 * @return string
 */
global string NewQueueName( string proposal )
{ // Only letters [A-Za-z], numbers [0-9], and '_' is more strict than
  // what is actually allowed in CUPS but such queue names are
  // safe to work in whatever mixed printing system environment:
  proposal = filterchars( proposal, alnum_chars + "_" );
  // Use a fallback queue name "queue_1" if the proposal is empty
  // (or has become empty because of the above filterchars)
  // or if the proposal consists only of '_':
  if( "" == proposal || "" == deletechars( proposal, "_" ) )
  { proposal = "queue_1";
  }
  // Remove leading '_' characters from the proposal.
  // For example if the proposal was initially something like "_foo"
  // or if it has become a leading '_' because of the above filterchars:
  if( "_" == substring( proposal, 0, 1) )
  { // findfirstnotof cannot return nil because the proposal cannot consist only of '_':
    proposal = substring( proposal, findfirstnotof( proposal, "_") );
  }
  // Make sure that the queue name starts with a letter,
  // otherwise add a "queue_" prefix:
  if( "" != deletechars( substring( proposal, 0, 1), letter_chars ) )
  { proposal = "queue_" + proposal;
  }
  // Make sure that no queue with the name of the proposal already exists.
  // Otherwise add a sufficient high number at the end:
  string queue_name = proposal;
  integer trailing_number = 0;
  boolean try_again = true;
  while( try_again )
  { try_again = false;
    foreach( map< string, string > queue,
             queues,
             { if( tolower( queue["name"]:"" ) == tolower( queue_name ) )
                 { // If queue_name already exists, add a sufficient high number at the end.
                   if( issubstring( proposal, "_") )
                   { // Remove a trailing number or a plain trailing '_' from the proposal
                     // to avoid that multiple trailing numbers or multiple '_' are added
                     // like "funprinter_1_1" or "queue__1":
                     integer position = findlastof( proposal, "_" );
                     if( "" == deletechars( substring( proposal, position ), number_chars + "_" ) )
                     { // The value of position is the lenght of the substring
                       // up to the last '_' but excluding the last '-'.
                       // For example in "fun_printer_1" the string position of the last '-' is 11
                       // and the first 11 characters in "fun_printer_1" are "fun_printer".
                       proposal = substring( proposal, 0, position );
                     }
                   }
                   trailing_number = trailing_number + 1;
                   queue_name = proposal + "_" + tostring( trailing_number );
                   try_again = true;
                   break;
                 }
               }
             );
    // Avoid an endless loop:
    if( trailing_number > 10000 )
    { queue_name = "";
      break;
    }
  }
  return queue_name;
}

/**
 * Create the list of queues for the Table in the OverviewDialog
 * @return table items
 */
global list QueueItems( boolean local, boolean remote )
{
  // Invalidate selected_queues_index to be safe:
  selected_queues_index = -1;
  if( ! AutodetectQueues() )
  { Report::Error( // Message of a Report::Error.
                   // Only a simple message because this error does not happen on a normal system
                   // (i.e. a system which is not totally broken or totally messed up).
                   // Do not confuse this error with the case when no queue was detected
                   // (e.g. simply because there is no queue). This results no error.
                   _("Failed to detect print queues.")
                 );
    // Return an empty list:
    return [];
  }
  integer queues_index = -1;
  list< term > queue_items = [];
  foreach( map< string, string > queue,
           queues,
           { // Set the queues_index to the index number of the actual queue in queues:
             queues_index = queues_index + 1;
             // Use local variables to have shorter variable names:
             string name = queue["name"]:"";
             string uri = queue["uri"]:"";
             string description = queue["description"]:"";
             string location = queue["location"]:"";
             string config = queue["config"]:"remote";
             string is_default = queue["default"]:"";
             string is_disabled = queue["disabled"]:"yes";
             string is_rejecting = queue["rejecting"]:"yes";
             if( name != "" && uri != "" )
             { if( (config=="local" && local) || (config=="remote" && remote))
               { if( "local" == config )
                 { // When the queue configuration exists on the local host:
                   config = _("Local");
                 }
                 else
                 { // When the queue configuration exists on a remote machine:
                   config = _("Remote");
                 }
                 if( "yes" == is_default )
                 { // When the queue is the default queue on the local host:
                   is_default = _("Yes");
                 }
                 // When the queue accepts print jobs and printing is enabled:
                 string queue_state = _("Ready");
                 if( "yes" == is_disabled )
                 { // When printing is disabled for the queue:
                   queue_state = _("Printout disabled");
                 }
                 if( "yes" == is_rejecting )
                 { if( "yes" == is_disabled )
                   { // When the queue rejects print jobs and printing is disabled:
                     queue_state = _("Rejecting print jobs, printout disabled");
                   }
                   else
                   { // When the queue rejects print jobs:
                     queue_state = _("Rejecting print jobs");
                   }
                 }
                 // Add trailing spaces because the current YaST UI
                 // has almost no additional space between table columns
                 // in partitcular not where the widest entry in a column is:
                 queue_items = add( queue_items, `item( `id( queues_index ),
                                                        config + " ",
                                                        name + " ",
                                                        description + " ",
                                                        location + " ",
                                                        is_default + " ",
                                                        queue_state
                                                      )
                                  );
               }
             }
           }
          );
  // Show a fallback text if there are no local queues:
  if( size( queue_items ) < 1 )
  { queue_items = add( queue_items, `item( `id( -1 ),
                                           "", "",
                                           // Show a fallback text if there are no local queues:
                                           _("There is no print queue."),
                                           "", "", ""
                                         )
                     );
  }
  // Sort the lists according to the queue_string which means sort according to the queue name:
  // queue_item[0] is `id(queues_index), queue_item[1] is the config, queue_item[2] is the queue name:
  return sort( term one_item,
               term another_item,
               queue_items,
               { return tolower(one_item[2]:"") < tolower(another_item[2]:""); }
             );
}

/**
 * Create a list of items from the autodetected connections
 * which is used for the SelectionBox in the BasicAddDialog and SelectConnectionDialog
 * @param connection_filter_string string of a search string to return only matching connections
 *        (return all connections if connection_filter_string is the empty string)
 * @return list of connections (i.e. DeviceURI, model, and info of the "lpinfo -l -v" output)
 */
global list ConnectionItems( string connection_filter_string )
{ // Autodetect printers if the connections list is empty:
  if( size( connections ) < 1 || "MoreConnections" == connection_filter_string )
  { list< map< string, string > > connection_wizard_connections = [];
    // Save existing connections which have been manually added by the connection wizard:
    foreach( map< string, string > connection,
             connections,
             { if( "ConnectionWizardDialog" == connection["class"]:"" )
               { connection_wizard_connections = add( connection_wizard_connections, connection);
               }
             }
           );
    // AutodetectPrinters overwrites the existing connections list:
    if( ! AutodetectPrinters() )
    { Report::Error( // Message of a Report::Error.
                     // Only a simple message because before the function AutodetectPrinters
                     // was called and this function would have shown more specific messages.
                     _("Failed to autodetect printers.")
                   );
      // Return only the existing connection wizard connections which is usally an empty list:
      return connection_wizard_connections;
    }
    // The connection wizard prepends its manually added connections to the connections list.
    // Theerefore the connection_wizard_connections are also prepended to the connections list.
    // There is an error in the YaST documentation regarding "merge" for lists:
    // It reads "Interprets two lists as sets" which would remove duplicates.
    // Actually merge([1,2,2,3],[2,3,3,4]) results [1,2,2,3,2,3,3,4]
    // which is needed here to preserve any entry to be on the safe side:
    connections = (list <map <string, string> >)merge( connection_wizard_connections, connections );
  }
  // Make a list of uri, model, and info entries of the connections
  // and take the connection_filter_string into account (if it is not the empty string).
  selected_connections_index = -1;
  list< term > connection_items = [];
  list< term > sorted_connection_items = [];
  integer connections_index = -1;
  string uri = "";
  string model = "";
  string info = "";
  string class = "";
  foreach( map< string, string > connection_entry,
           connections,
           { // Set the connections_index to the index number of the current connection_entry:
             connections_index = connections_index + 1;
             // Use local variables to have shorter variable names:
             uri = connection_entry["uri"]:"";
             model = connection_entry["model"]:"";
             info = connection_entry["info"]:"";
             class = connection_entry["class"]:"";
             if( uri != "" )
             { // Take the filter_string into account:
               if( "" == connection_filter_string )
               { // Add trailing spaces because the current YaST UI
                 // has almost no additional space between table columns
                 // in partitcular not where the widest entry in a column is:
                 connection_items = add( connection_items, `item( `id( connections_index ),
                                                                  model + " ",
                                                                  uri + " ",
                                                                  info
                                                                )
                                       );
               }
               else
               { // If the connection_filter_string is the special string "BasicAddDialog",
                 // do a special filtering for those connections which are suitable
                 // for the BasicAddDialog (i.e. only parallel, usb, and hp connections):
                 if( "BasicAddDialog" == connection_filter_string )
                 { if( "parallel:/" == substring( uri, 0, 10 )
                       || "usb:/" == substring( uri, 0, 5 )
                       || "hp:/" == substring( uri, 0, 4 )
                       || "ConnectionWizardDialog" == class
                     )
                   { // Add trailing spaces because the current YaST UI
                     // has almost no additional space between table columns
                     // in partitcular not where the widest entry in a column is:
                     connection_items = add( connection_items, `item( `id( connections_index ),
                                                                      model + " ",
                                                                      uri + " ",
                                                                      info
                                                                    )
                                           );
                   }
                 }
                 else
                 { // If the connection_filter_string is the special string "MoreConnections",
                   // do a special filtering for those connections which are supposed to work
                   // i.e. where the uri seems to be a complete DeviceURI e.g. "socket://192.168.1.2:9100"
                   // and not just an URI scheme like a plain "socket".
                   // It doesn't matter if backends (i.e. schemes) with non alphanumeric characters
                   // are skipped here because for unusual backends there is the "Connection Wizard":
                   if( "MoreConnections" == connection_filter_string )
                   { // if( issubstring ( uri , ":/" ) )
                     if( regexpmatch( uri, "^[" + alnum_chars + "]+:/" )
                         || "ConnectionWizardDialog" == class
                       )
                     { // Add trailing spaces because the current YaST UI
                       // has almost no additional space between table columns
                       // in partitcular not where the widest entry in a column is:
                       connection_items = add( connection_items, `item( `id( connections_index ),
                                                                        model + " ",
                                                                        uri + " ",
                                                                        info
                                                                      )
                                             );
                     }
                   }
                   else
                   { // If the connection_filter_string is a usual non-empty string,
                     // test whether the model matches to the connection_filter_string:
                     if( regexpmatch( tolower( model ), tolower( connection_filter_string ) ) )
                     { // Add trailing spaces because the current YaST UI
                       // has almost no additional space between table columns
                       // in partitcular not where the widest entry in a column is:
                       connection_items = add( connection_items, `item( `id( connections_index ),
                                                                        model + " ",
                                                                        uri + " ",
                                                                        info
                                                                      )
                                             );
                     }
                   }
                 }
               }
             }
           }
         );
/*
  // Preselect the entry in the connection_items list which matches
  // to the current value of selected_connections_index
  // if such an entry exists in connection_items (e.g. because of the
  // connection_filter_string there may be no such entry in connection_items):
  integer connection_items_index = -1;
  integer selected_connection_items_index = -1;
  // Determine if such an entry exists:
  foreach( term connection_item,
           connection_items,
           { // Set the connection_items_index to the index number of the current connection_item:
             connection_items_index = connection_items_index + 1;
             // connection_item[0] is the term `id(connections_index) and id[0] is the connections_index
             // so that connection_item[0,0] is the connections_index:
             if( selected_connections_index == connection_item[0,0]:-1 )
             { selected_connection_items_index = connection_items_index;
               break;
             }
           }
         );
  if( selected_connection_items_index >= 0 )
  { // Actually preselect the entry and set selected_connections_index accordingly.
    // connection_items[selected_connection_items_index] is a connection_item and
    // connection_item[0] is the term `id(connections_index) so that
    // connection_item[0,0] is the connections_index (see the previous comment) and
    // connection_item[1] is the model string and
    // connection_item[2] is the uri string and
    // connection_item[3] is the info string so that
    // connection_items[selected_connection_items_index,0,0] is the connections_index and
    // connection_items[selected_connection_items_index,1] is the model string and
    // connection_items[selected_connection_items_index,2] is the uri string and
    // connection_items[selected_connection_items_index,3] is the info string:
    selected_connections_index = connection_items[selected_connection_items_index,0,0]:-1;
    model = connection_items[selected_connection_items_index,1]:"";
    uri = connection_items[selected_connection_items_index,2]:"";
    info = connection_items[selected_connection_items_index,3]:"";
    connection_items[selected_connection_items_index] = `item( `id( selected_connections_index ),
                                                               model,
                                                               uri,
                                                               info,
                                                               true
                                                             );
    y2milestone( "Preselected connection shown to the user (model, uri, info): %1, %2, %3", model, uri, info );
  }
  else
  { // Invalidate selected_connections_index to be safe:
    selected_connections_index = -1;
    y2milestone( "No preselected connection shown to the user. The connection_filter_string is: '%1'", connection_filter_string );
  }
*/
  // Sort the list according to the model:
  // connection_item[0] is `id(connections_index)
  // connection_item[1] is the model
  // connection_item[2] is the uri
  // connection_item[3] is the info
  // The comparison expression must evaluate to a boolean value and
  // it must be irreflexive (e.g. "<" instead of "<=") which results conditions like
  // 'a condition for one item' and 'not the same condition for the other item'
  sorted_connection_items = sort( term one_item,
                                  term another_item,
                                  connection_items,
                                  { // Have the entries which are "created by the connection wizard" topmost:
                                    // Have short local variable names for shorter comparison expression
                                    // and avoid multiple complicated accesses of same elements in an list:
                                    string this = one_item[3]:"";
                                    string that = another_item[3]:"";
                                    // This is an entry where the info is "created by the connection wizard"
                                    // and that is no such entry:
                                    if( ( this == "created by the connection wizard" )
                                        && ( that != "created by the connection wizard" )
                                      ) return true;
                                    // This is an entry where the info is not "created by the connection wizard"
                                    // but that is such an entry:
                                    if( ( this != "created by the connection wizard" )
                                        && ( that == "created by the connection wizard" )
                                      ) return false;
                                    // If both are "created by the connection wizard"
                                    // or if both are not "created by the connection wizard"
                                    // have entries with a valid model name topmost:
                                    // Have short local variable names for shorter comparison expression
                                    // and avoid multiple complicated accesses of same elements in an list:
                                    this = one_item[1]:"";
                                    that = another_item[1]:"";
                                    // This is an entry where the model is neither empty nor "Unknown"
                                    // and that is no such entry:
                                    if( ( this != "" && tolower( this ) != "unknown" )
                                        && ( that == "" || tolower( that ) == "unknown" )
                                      ) return true;
                                    // This is an entry where the model is empty or "Unknown"
                                    // and that is no such entry:
                                    if( ( this == "" || tolower( this ) == "unknown" )
                                        && ( that != "" && tolower( that ) != "unknown" )
                                      ) return false;
                                    // Fall back to alphabetical sorting of the model name:
                                    return tolower(this) < tolower(that);
                                  }
                                );
  // Preselect a particular entry in a Table widget is not possible.
  // The Table widget has always the first entry preselected.
  // Therefore the selected_connections_index (i.e. the selected printer)
  // and the selected_ppds_index (i.e. the selected driver)
  // are invalidated in any case:
  selected_connections_index = -1;
  selected_ppds_index = -1;
  // Additionally an empty first dummy entry is prepended to avoid that the
  // first real printer connection entry becomes always preselected
  // regardless that selected_connections_index is invalidated
  // which leads to arbitrary confusion (e.g. wrong driver selections):
//  sorted_connection_items = prepend( sorted_connection_items, `item( `id( -1 ), "", "", "" ) );
  return sorted_connection_items;
}

/**
 * Create a list of items from the PPD database entries
 * which is used for the SelectionBox in the BasicAddDialog and SelectDriverDialog
 * @param driver_filter_string string of a search string to return only matching PPDs
 *        (return all PPDs if driver_filter_string is the empty string)
 * @return list of drivers (i.e. the NickName entries of the PPDs)
 */
global list DriverItems( string driver_filter_string, boolean preselection )
{ // Create the driver database only if the ppds list is empty:
  if( size( ppds ) < 1 )
  { if( ! CreateDatabase() )
    { Report::Error( // Message of a Report::Error.
                     // Only a simple message because before the function CreateDatabase
                     // was called and this function would have shown more specific messages.
                     _("Failed to create the printer driver database.")
                   );
      // Return an empty list:
      return [];
    }
  }
  list< term > driver_items = [];
  list< term > sorted_driver_items = [];
  string driver_string = "";
  // If the driver_filter_string is the special string "BasicAddDialog",
  // produce a special fast output which is suitable to be shown
  // initially when the BasicAddDialog is launched:
  if( "BasicAddDialog" == driver_filter_string )
  { if( preselection
        && selected_ppds_index >= 0
      )
    { // If a driver was already selected, show this driver and preselect it
      // if preselection should be done at all:
      driver_string = ppds[selected_ppds_index,"nickname"]:"" + " [" + ppds[selected_ppds_index,"ppd"]:"" + "]";
      driver_items = [ `item( `id( selected_ppds_index ), driver_string, true ) ];
    }
    else
    { // If no driver was already selected, show a meaningful text as
      // fallback entry for a SelectionBox when no connection is selected.
      // It will be replaced by real content, when a connection is selected.
      driver_string = _("Select a connection, then matching drivers show up here.");
      driver_items =  [ `item( `id( -1 ), driver_string ) ];
    }
    return driver_items;
  }
  // Make a list of the NickName entries of the PPDs according to the PPD database
  // and take the driver_filter_string into account (if it is not the empty string)
  // and try to preselect an entry according to a selected autodetected printer:
  Popup::ShowFeedback( // No title for a simple busy message:
                       "",
                       // Busy message:
                       // Body of a Popup::ShowFeedback:
                       _("Determine available drivers...")
                     );
  y2milestone( "The driver_filter_string is: '%1'", driver_filter_string );
  integer ppds_index = -1;
  foreach( map< string, string > ppd_entry,
           ppds,
           { // Set the ppds_index to the index number of the current ppd_entry:
             ppds_index = ppds_index + 1;
             // Use local variables to have shorter variable names:
             string ppd = ppd_entry["ppd"]:"";
             string nickname = ppd_entry["nickname"]:"";
             string deviceID = ppd_entry["deviceID"]:"";
             string language = ppd_entry["language"]:"";
             // Build the entry:
             if( ppd != "" && nickname != "" )
             { driver_string = nickname + " [" + ppd + "]";
               // Take the filter_string into account:
               if( "" == driver_filter_string )
               { driver_items = add( driver_items, `item( `id( ppds_index ), driver_string ) );
               }
               else
               { // If the driver_filter_string is a non-empty string,
                 // test whether the nickname matches to the driver_filter_string:
                 string unified_nickname = filterchars( tolower( nickname ), lower_alnum_chars );
                 if( regexpmatch( unified_nickname, driver_filter_string ) )
                 { driver_items = add( driver_items, `item( `id( ppds_index ), driver_string ) );
                 }
               }
             }
           }
         );
  if( size( driver_items ) == 0 )
  { // If the driver_items list is empty (e.g. because of a too restrictive driver_filter_string),
    // show a meaningful text as fallback entry.
    driver_string = _("No matching driver found. Try 'More Drivers' or 'All Drivers'.");
    driver_items =  [ `item( `id( -1 ), driver_string ) ];
    Popup::ClearFeedback();
    return driver_items;
  }
  // More feedback to stay in contact with the user
  // if the list of driver_items is very long
  // e.g. when all PPDs are shown (several thousand)
  // or when all PPDs for "HP" are shown (more than 1000)
  // or when all PPDs for "Epson" are shown (more than 500).
  // Then it takes some time to determine if a PPD can be preselected
  // and to sort the list.
  // Actually it is the sorting which takes most of the time but for the user
  // a feedback message like "sorting list of drivers" is meaningless.
  if( size( driver_items ) > 500 )
  { Popup::ShowFeedback( // No title for a simple busy message:
                         "",
                         // Busy message:
                         // Body of a Popup::ShowFeedback:
                         _("Processing many drivers. Please wait...")
                       );
    // Sleep half a second to let the user notice the feedback in any case:
    sleep( 500 );
  }
  // Preselect the entry in the driver_items list which matches
  // to the current value of selected_ppds_index
  // if such an entry exists in driver_items (e.g. because of the
  // driver_filter_string there may be no such entry in driver_items) and
  // if preselection should be done at all:
  integer driver_items_index = -1;
  integer selected_driver_items_index = -1;
  // Determine if such an entry exists:
  foreach( term driver_item,
           driver_items,
           { // Set the driver_items_index to the index number of the current driver_item:
             driver_items_index = driver_items_index + 1;
             // driver_item[0] is the term `id(ppds_index) and id[0] is the ppds_index
             // so that driver_item[0,0] is the ppds_index:
             if( selected_ppds_index == driver_item[0,0]:-1 )
             { selected_driver_items_index = driver_items_index;
               break;
             }
           }
         );
  if( preselection
      && selected_driver_items_index >= 0
    )
  { // Actually preselect the entry and set selected_ppds_index accordingly.
    // driver_items[selected_driver_items_index] is a driver_item and
    // driver_item[1] is the driver_string and
    // driver_item[0] is the term `id(ppds_index) and id[0] is the ppds_index
    // so that driver_item[0,0] is the ppds_index so that
    // driver_items[selected_driver_items_index,0,0] is the ppds_index:
    selected_ppds_index = driver_items[selected_driver_items_index,0,0]:-1;
    driver_string = driver_items[selected_driver_items_index,1]:"";
    driver_items[selected_driver_items_index] = `item( `id( selected_ppds_index ), driver_string, true );
    y2milestone( "Already preselected driver: '%1'", driver_string );
  }
  else
  { // Invalidate selected_ppds_index to be safe:
    selected_ppds_index = -1;
    y2milestone( "No driver preselected." );
  }
  // Sort the driver_items list.
  // There are two kind of sorting the driver_items list.
  // By default, the list is sorted according to the driver_string
  // which is basically sorting according to NickName (first part of driver_string)
  // which is basically sorting according to Manufacturer and ModelName (first parts of NickName).
  // But when all elements in the driver_items list belong to the same model,
  // it would be nicer to sort according to which PPD looks most suitable for the model
  // (i.e. according to the above step-by-step approach to preselect a PPD).
  // The real problem is that the NickName is a plain sequence of words which describe
  // manufacturer, model, driver, and optionally whether the driver is recommended
  // but there are no delimiters which mark where the model info begins and ends.
  // Some NickName examples (note the one missing ')' after recommended):
  //   Brother HL-10h Foomatic/lj4dith
  //   Canon BJC-600 Foomatic/bjc610a0.upp
  //   Canon S600 Foomatic/bj8pa06n.upp (recommended)
  //   DesignJet 5000PS (recommended)
  //   designjet 5500ps (recommended)
  //   EPSON AL-2600 PS3 v3016.103
  //   Epson E 100 - CUPS+Gutenprint v5.0.0 Simplified
  //   Epson Stylus Color 8 3 - CUPS+Gutenprint v5.0.0
  //   Epson Stylus Color PRO Foomatic/stcolor (recommended)
  //   EPSON Stylus Color Series CUPS v1.2
  //   Epson Stylus Photo EX - CUPS+Gutenprint v5.0.0 Simplified
  //   Epson Stylus Photo EX3 - CUPS+Gutenprint v5.0.0
  //   Generic IBM-Compatible Dot Matrix Printer Foomatic/ibmpro (recommended)
  //   Generic PCL 4 Printer - CUPS+Gutenprint v5.0.0 Simplified
  //   Gestetner MP1100/DSm7110 PS plain PostScript
  //   Gestetner P7026n PS PostScript+Foomatic (recommended)
  //   HP 2500CM Foomatic/hpijs
  //   HP Color LaserJet 2500 - CUPS+Gutenprint v5.0.0 black and white only
  //   HP Color LaserJet Series PCL 6 CUPS
  //   HP DesignJet 2500CP PS3 v3010.103 (recommended
  //   HP DeskJet 2500CM - CUPS+Gutenprint v5.0.0
  //   HP e-printer e20 Foomatic/hpijs (recommended)
  //   HP LaserJet 4 Foomatic/ljet4 (recommended)
  //   HP LaserJet 4 Plus v2013.111 Postscript (recommended)
  //   HP LaserJet 4/4M 600DPI Postscript (recommended)
  //   HP PSC 2500 Foomatic/hpijs (recommended)
  //   Kyocera FS-1000 Foomatic/ljet4
  //   Kyocera FS-1000+ Foomatic/Postscript
  //   Kyocera KM-3530 Foomatic/Postscript (recommended)
  //   Kyocera Mita KM-3530
  //   Kyocera Mita KM-4230/5230
  //   NRG 10515/10518/10512 Foomatic/pxlmono (recommended)
  //   NRG 10515/10518/10512 PXL Foomatic/pxlmono (recommended)
  //   OKI C5450 PS
  //   OKI C5700(PS)
  //   OKIPAGE 14i
  //   Oki Okipage 14ex Foomatic/ljet4
  //   Okidata Okipage 14ex - CUPS+Gutenprint v5.0.0
  //   TOSHIBA e-STUDIO3510c Series PS
  //   Toshiba e-Studio 3511 Foomatic/Postscript (recommended)
  //   Toshiba e-Studio 351c Foomatic/Postscript (recommended)
  // It is not possible to extract manufacturer and model reliable from the NickName.
  // Only a best-guess which is as fail-safe as possible can be done.
  // An usual full qualified model description looks like:
  //   ACME FunPrinter 1000
  //   ACME Fun Printer 1000
  //   ACME FunPrinter 1000XL
  //   ACME Fun Printer 1000 XL
  //   ACME Fun Printer 1000-XL
  //   ACME 1000XL
  //   ACME FunPrinter Pro 1000XL
  //   ACME Pro-1000-XL
  //   ACME Ltd. Fun Printer Pro 1000 XL
  // After at least one words which contains only letters (the manufacturer name)
  // there are none or up to two words which contain only letters and hyphens (the model name)
  // and then there is a word which contains at least one number (the model series).
  // Therefore the manufacturer and model sub-string can be assumed to be:
  //   One word which contains only letters,
  //   followed by at most two words which contain only letters and perhaps hyphens
  //   finished by one word which may start with letters and hyphens
  //   but it must contain at least one number followed by whatever characters.
  // It is crucial to take whatever (trailing) character in the model series into account
  // to be on the safe side to distinguish different models
  // (e.g. "HP LaserJet 4" versus "HP LaserJet 4/4M" or "Kyocera FS-1000" versus "Kyocera FS-1000+").
  // For example as egrep regular expression:
  //   lpinfo -m | cut -d' ' -f2-
  //   | egrep -o '^[[:alpha:]]+[[:space:]]+([[:alpha:]-]+[[:space:]]+){0,2}[[:alpha:]-]*[[:digit:]][^[:space:]]*'
  // Of course this best-guess is not 100% correct because it would result for example
  // that "ACME FunPrinter 1000" and "ACME FunPrinter 1000 XL" are considered to be the same model
  // but "ACME FunPrinter 1000XL" and "ACME FunPrinter 1000 XL" are considered to be different models.
  // The latter results no problem because the special sorting is only done
  // when all entries in the driver_items list seem to belong to the same model.
  // But the former results a small problem because the special sorting is done here
  // for different models with similar names.
  // To mitigate such problems, the special sorting is only done
  // when the driver_items list is short so that the user can easily survey the whole list.
  // For example the PPDs in openSUSE 10.2
  //   lpinfo -m | cut -d' ' -f2-
  //   | egrep -o '^[[:alpha:]]+[[:space:]]+([[:alpha:]-]+[[:space:]]+){0,2}[[:alpha:]-]*[[:digit:]][^[:space:]]*'
  //   | sort -f | uniq -i -c | sort -n
  // results that the maximum lenght of the driver_items list for the same model is 13
  // (in openSUSE 10.2 the 13 entries are for the "Kyocera FS-600").
  // In openSUSE 10.2 there are only 4 models (HP LaserJet 4, 4100, 9000 and the Kyocera FS-600)
  // for which more than 9 entries exist (11 for LaserJet 4100 and 12 for LaserJet 4 and 9000)
  // but there are 23 models with 9 entries (there is no no model with 10 entries)
  // so that a maximum of 10 entries for the special sorting should be o.k.:
  if( size( driver_items ) <= 10 )
  { // Test if all entries in the driver_items list seem to be for the same model.
    list< integer > position = [];
    string manufacturer_and_model = "";
    driver_items_index = -1;
    foreach( term driver_item,
             driver_items,
             { // Set the driver_items_index to the index number of the current driver_item:
               driver_items_index = driver_items_index + 1;
               if( 0 == driver_items_index )
               { // Determine the assumed manufacturer and model sub-string from the first driver item
                 // (driver_item[0] is `id(ppds_index) and driver_item[1] is the driver_string):
                 position = regexppos( driver_item[1]:"", "^[[:alpha:]]+[[:space:]]+([[:alpha:]-]+[[:space:]]+){0,2}[[:alpha:]-]*[[:digit:]][^[:space:]]*" );
                 // driver_item[1] is the driver_string which is nickname + ppd:
                 manufacturer_and_model = substring( driver_item[1]:"", position[0]:0, position[1]:0 );
                 // Break if manufacturer_and_model is empty or seems too short to be really meaningful
                 // (shortest manufacturer and model strings are e.g. "HP PSC 500", "Epson E 100", "Star LC 90"):
                 if( "" == manufacturer_and_model || size( manufacturer_and_model ) < 10 )
                 { driver_items_index = -1;
                   break;
                 }
               }
               else
               { // Test if the manufacturer_and_model string matches for all subsequent driver items:
                 string other_manufacturer_and_model = substring( driver_item[1]:"", position[0]:0, position[1]:0 );
                 other_manufacturer_and_model = filterchars( tolower( other_manufacturer_and_model ), lower_alnum_chars );
                 if( other_manufacturer_and_model != filterchars( tolower( manufacturer_and_model ), lower_alnum_chars ) )
                 { driver_items_index = -1;
                   break;
                 }
               }
             }
           );
    if( driver_items_index >= 0 )
    { // All entries in the driver_items list seem to belong to the same model:
      y2milestone( "All entries in the driver_items list seem to belong to the same model: '%1'", manufacturer_and_model );
      // Return a list which is sorted according to which PPD looks most suitable for the model.
      // Define the regular expression strings for comparisons which are
      // used for the special sorting of the drivers list.
      // Define also the matching weights for the special sorting of the drivers list.
      // The weight values are of the form 2^n so that the sum of all weights up to n-1
      // is less than the weight for the layer n comparison.
      // The smallest weight is 1 for the fallback alphabetical comparison.
      // Therefore the special comparisons here start with 2 up to whatever layer is needed.
      // The double \\ in YCP results a single \ in the actual string value
      // so that in the end there is \( and \) and \[ in the regular expression.
      // This is a PPD which was downloaded by the user:
      string downloaded = "\\[downloaded/";
      integer downloaded_weight = 32;
      // This is a recommended PPD:
      string recommended = "\\(recommended\\)";
      integer recommended_weight = 16;
      // This is an original PPD from a manufacturer:
      string manufacturerPPD = "\\[manufacturer-PPDs/";
      integer manufacturerPPD_weight = 8;
      // This is a PPD from the HPLIP project (HP Linux Imaging and Printing):
      string hplip = "/hplip/";
      integer hplip_weight = 4;
      // This is a PPD for a ESC/P2 driver from Gutenprint (formerly Gimp-Print)
      string gutenprint_escp2 = "\\[gutenprint/stp-escp2-";
      integer gutenprint_escp2_weight = 2;
      // This is a PPD for the ljet4 driver from OpenPrinting (formerly LinuxPrinting):
      string foomatic_ljet4 = "Foomatic/ljet4";
      integer foomatic_ljet4_weight = 2;
      // The comparison expression must evaluate to a boolean value and
      // it must be irreflexive (e.g. "<" instead of "<=").
      // Therefore the comparison expression calculates weights for both items
      // so that at the end a simple numerical comparison of the weights is sufficient.
      // (driver_item[0] is `id(ppds_index) and driver_item[1] is the driver_string):
      sorted_driver_items = sort( term one_item,
                                  term another_item,
                                  driver_items,
                                  { // Have short local variable names for shorter expressions
                                    // and avoid multiple complicated accesses of same elements in a list:
                                    string this = one_item[1]:"";
                                    string that = another_item[1]:"";
                                    integer this_weight = 0;
                                    integer that_weight = 0;
                                    // Sum up the weights:
                                    // Add the weight if it is a PPD which was downloaded by the user:
                                    if( regexpmatch( this, downloaded ) )
                                    { this_weight = this_weight + downloaded_weight;
                                    }
                                    if( regexpmatch( that, downloaded ) )
                                    { that_weight = that_weight + downloaded_weight;
                                    }
                                    // Add the weight if it is a recommended PPD:
                                    if( regexpmatch( this, recommended ) )
                                    { this_weight = this_weight + recommended_weight;
                                    }
                                    if( regexpmatch( that, recommended ) )
                                    { that_weight = that_weight + recommended_weight;
                                    }
                                    // Add the weight if it is an original PPD from a manufacturer:
                                    if( regexpmatch( this, manufacturerPPD ) )
                                    { this_weight = this_weight + manufacturerPPD_weight;
                                    }
                                    if( regexpmatch( that, manufacturerPPD ) )
                                    { that_weight = that_weight + manufacturerPPD_weight;
                                    }
                                    // Add the weight if it is a PPD from the HPLIP project:
                                    if( regexpmatch( this, hplip ) )
                                    { this_weight = this_weight + hplip_weight;
                                    }
                                    if( regexpmatch( that, hplip ) )
                                    { that_weight = that_weight + hplip_weight;
                                    }
                                    // Add the weight if it is a PPD for a ESC/P2 driver from Gutenprint:
                                    if( regexpmatch( this, gutenprint_escp2 ) )
                                    { this_weight = this_weight + gutenprint_escp2_weight;
                                    }
                                    if( regexpmatch( that, gutenprint_escp2 ) )
                                    { that_weight = that_weight + gutenprint_escp2_weight;
                                    }
                                    // Add the weight if it is a PPD for the ljet4 driver from OpenPrinting:
                                    if( regexpmatch( this, foomatic_ljet4 ) )
                                    { this_weight = this_weight + foomatic_ljet4_weight;
                                    }
                                    if( regexpmatch( that, foomatic_ljet4 ) )
                                    { that_weight = that_weight + foomatic_ljet4_weight;
                                    }
                                    // Add the weight 1 for the fallback alphabetical comparison:
                                    if( tolower(this) < tolower(that) )
                                    { this_weight = this_weight + 1;
                                    }
                                    if( tolower(that) < tolower(this) )
                                    { that_weight = that_weight + 1;
                                    }
                                    // Return the result of the numerical comparison of the weights.
                                    // Return true to get this alphabetically sorted before that:
                                    return this_weight > that_weight;
                                  }
                                );
      // If neither a downloaded PPD nor a recommended PPD nor a manufacturer PPD exists,
      // do not preselect any PPD because in this case there is nothing which indicates
      // that a particular PPD is known to work - i.e. it looks really problematic
      // so that now it is only the user who can make a decission in this case
      // (even if all he can do is guessing but then he knows at least what he did).
      // Because of the above sorting it is sufficient to test only the first entry in sorted_driver_items.
      // sorted_driver_items[0] is the first entry in sorted_driver_items and
      // sorted_driver_item[1] is the driver_string and
      // sorted_driver_item[0] is the term `id(ppds_index) and id[0] is the ppds_index
      // so that sorted_driver_item[0,0] is the ppds_index so that
      // sorted_driver_items[0,0,0] is the ppds_index:
      driver_string = sorted_driver_items[0,1]:"";
      // Preselect the first entry in sorted_driver_items
      // if preselection should be done at all and
      // if there is not alredy an entry preselected and if a preselectable PPD exists:
      if( preselection
          && -1 == selected_ppds_index
          && ( regexpmatch( driver_string, downloaded )
               || regexpmatch( driver_string, recommended )
               || regexpmatch( driver_string, manufacturerPPD )
             )
        )
      { // Preselect the first entry and set selected_ppds_index accordingly.
        selected_ppds_index = sorted_driver_items[0,0,0]:-1;
        sorted_driver_items[0] = `item( `id( selected_ppds_index ), driver_string, true );
        y2milestone( "Preselected driver: '%1'", driver_string );
      }
      // The specially sorted_driver_items list has a maximum of 10 entries which is o.k. for the log:
      y2milestone( "sorted_driver_items: %1", sorted_driver_items );
      Popup::ClearFeedback();
      return sorted_driver_items;
    }
  }
  // Return a list which is sorted according to the driver_string which is basically
  // sorting according to Nickname which is the first part of the driver_string
  // (driver_item[0] is `id(ppds_index) and driver_item[1] is the driver_string).
  sorted_driver_items = sort( term one_item,
                              term another_item,
                              driver_items,
                              { return tolower(one_item[1]:"") < tolower(another_item[1]:"");
                              }
                            );
  Popup::ClearFeedback();
  return sorted_driver_items;
}

/**
 * Add new queue or overwrite existing queue
 * @return true on success
 */
global boolean AddQueue( string queue_name )
{ string uri = connections[selected_connections_index,"uri"]:"";
  string ppd = ppds[selected_ppds_index,"ppd"]:"";
  // Delete ' characters because they are used for quoting in the bash commandline below:
  string model = deletechars( connections[selected_connections_index,"model"]:"", "'" );
  string description = deletechars( ppds[selected_ppds_index,"nickname"]:"", "'" );
  if( "" != model
      && "unknown" != tolower( model )
      && ! issubstring( filterchars( tolower( description ), lower_alnum_chars ),
                        filterchars( tolower( model ), lower_alnum_chars )
                      )
    )
  { description = model + " with driver " + description;
  }
  if( "" == uri || "" == ppd || "" == queue_name )
  { return false;
  }
  // Note the bash quotings of the queue_name and description strings with ' characters:
  string commandline = "/usr/sbin/lpadmin -h localhost -p '" + queue_name + "' -v " + uri + " -m " + ppd + " -D '" + description + "' -E";
  if( ! Printerlib::ExecuteBashCommand( commandline ) )
  { return false;
  }
  return true;
}

/**
 * Delete queue
 * @return true on success
 */
global boolean DeleteQueue( string queue_name )
{ if( "" == queue_name )
  { queue_name = queues[selected_queues_index,"name"]:"";
    if( "local" != queues[selected_queues_index,"config"]:"remote" )
    { return false;
    }
  }
  if( "" == queue_name )
  { return false;
  }
  // To be safe invalidate selected_queues_index in any case:
  selected_queues_index = -1;
  // Note the bash quoting of the queue_name string with ' characters:
  string commandline = "/usr/sbin/lpadmin -h localhost -x '" + queue_name + "'";
  if( ! Printerlib::ExecuteBashCommand( commandline ) )
  { return false;
  }
  return true;
}

/**
 * Create a list of tree widget items from the driver_options
 * which is used for the tree widget in the DriverOptionsDialog
 * @param selected_keyword string of an already selected keyword
 *        to have the matching values list opened by default in the tree
 * @param selected_value string of a selected value which matches to the selected_keyword string
 *        to show this value in the tree (which might be different than the value of the queue)
 * @return list of driver options items for a tree widget
 */
global list DriverOptionItems( string selected_keyword, string selected_value )
{ // Run DetermineDriverOptions if the driver_options list is empty:
  if( size( driver_options ) < 1 )
  { if( ! DetermineDriverOptions( "" ) )
    { Report::Error( // Message of a Report::Error.
                     // Only a simple message because this is only a fallback case
                     // which should not happen at all:
                     _("Failed to determine the driver options.")
                   );
      // Return at least a list with only a fallback string so that the user is informed:
      return [ _("No driver options available") ];
    }
  }
  list driver_options_tree_items_list = [];
  integer driver_options_index = -1;
  integer pagesize_option_index = -1;
  foreach( map< string, any > driver_option,
           driver_options,
           { // Set the driver_options_index to the index number of the actual driver_option in driver_options:
             driver_options_index = driver_options_index + 1;
             boolean opened = false;
             string keyword = driver_option["keyword"]:"";
             // Show only options with at least one real value.
             // Even if there is no choice when there is only one value,
             // the user should at least see what the setting is.
             // Test for '>1' because last entry in the "values" list is always an emtpy string.
             // Additionally do not show the PageRegion option because
             // the media size should usually only be set via the PageSize option
             // and the PageRegion has a special purpose (see the Adobe PPD spec.)
             // so that from the user's point of view PageRegion looks like
             // a confusing duplicate of PageSize:
             if( "" != keyword
                 && size( driver_option["values"]:[] ) > 1
                 && "PageRegion" != keyword
               )
             { if( "PageSize" == keyword )
               { pagesize_option_index = driver_options_index;
               }
               if( selected_keyword == keyword )
               { opened = true;
               }
               string option_name = keyword;
               if( "" != driver_option["translation"]:"" )
               { option_name = option_name + " / " + driver_option["translation"]:"";
               }
               // Provide the values as list of items i.e. specified as `item("string"):
               list value_items_list = [];
               string current_value_setting = "";
               foreach( string value,
                        driver_option["values"]:[],
                        { // At least the last value is always the emtpy string.
                          // Do not show an emtpy string as possible choice to the user:
                          if( "" != value )
                          { if( "*" == substring( value, 0, 1 ) )
                            { // The currently set value for the queue is marked by a leading '*'.
                              // Do not show the leading '*' to the user:
                              value = substring( value, 1 );
                              current_value_setting = value;
                            }
                            if( selected_keyword == keyword
                                && selected_value == value
                              )
                            { // Dummy info for a currently selected item:
                              string dummy_info = _("currently selected");
                              if( current_value_setting == value  )
                              { // Info when a currently selected item is already set:
                                dummy_info = _("current setting of the print queue");
                              }
                              // It seems to be impossible to preselect the currently selected item.
                              // In particular `item( value, true) does not preselect it.
                              // Therefore a dirty hack is used to mark the currently selected item
                              // only by means of the user interface because changing the content
                              // of the string value (e.g. like ">> value <<") is even more evil
                              // because then the content is no longer a valid option value keyword.
                              // Therefore a dummy item list is added (an empty list doesn't work)
                              // which lets the user interface show a '+' before the value
                              // but because the added item list is meaningless we keep it closed:
                              value_items_list = add( value_items_list, `item( value, false, [ dummy_info ] ) );
                            }
                            else
                            { value_items_list = add( value_items_list, `item( value ) );
                            }
                          }
                        }
                      );
               // Have the value list opened for the currently selected keyword:
               if( selected_keyword == keyword )
               { opened = true;
                 // If the user had selected another value for this keyword
                 // store it so that if is know for subsequent DriverOptionItems calls:
                 if( "" != selected_value )
                 { driver_options[driver_options_index] = add( driver_options[driver_options_index]:$[],
                                                               "selected",
                                                               selected_value
                                                             );
                 }
               }
               // Override the current_value_setting if the user has selected another value:
               if( "" != driver_options[driver_options_index,"selected"]:"" )
               { current_value_setting = driver_options[driver_options_index,"selected"]:"";
               }
               if( "" != current_value_setting )
               { // Show the currently set value at the tree item name of the particular option
                 // so that the user can see it even when the respective tree item is not opened.
                 // By default the option items are not opened to provide a concise overview:
                 option_name = option_name + " : " + current_value_setting;
               }
               driver_options_tree_items_list = add( driver_options_tree_items_list,
                                                     `item( `id( keyword ),
                                                            option_name,
                                                            opened,
                                                            value_items_list
                                                          )
                                                    );
             }
           }
         );
  // Have the PageSize option topmost:
  if( pagesize_option_index >= 0 )
  { term pagesize_option_tree_item = driver_options_tree_items_list[pagesize_option_index]:`item("no PageSize option");
    driver_options_tree_items_list = remove( driver_options_tree_items_list, pagesize_option_index );
    driver_options_tree_items_list = prepend( driver_options_tree_items_list, pagesize_option_tree_item );
  }
  if( size( driver_options_tree_items_list ) < 1 )
  { // Return at least a list with only a fallback string so that the user is informed:
    return [ _("No driver options available") ];
  }
  return driver_options_tree_items_list;
}

/**
 * Get all printer settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings) {
    // TODO FIXME: your code here (fill the above mentioned variables)...
    return true;
}

/**
 * Dump the printer settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
    // TODO FIXME: your code here (return the above mentioned variables)...
    return $[];
}

/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages() {
    // TODO FIXME: your code here...
    return $[ "install":[], "remove":[] ];
}

/* EOF */
}
