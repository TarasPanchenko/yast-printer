/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	clients/printer_proposal.ycp
 * Package:	Configuration of printer
 * Summary:	Proposal function dispatcher.
 * Authors:	Johannes Meixner <jsmeix@suse.de>
 *
 * $Id: printer_proposal.ycp 27914 2006-02-13 14:32:08Z locilka $
 *
 * Proposal function dispatcher for printer configuration.
 * See source/installation/proposal/proposal-API.txt
 */

{

textdomain "printer";

import "Printer";
import "Printerlib";
import "Progress";
import "String";
import "Mode";
import "Stage";
import "Service";
import "Popup";

y2milestone("----------------------------------------");
y2milestone("Printer proposal started");

any ret = nil;
string func = "";
map param = $[];

// Check arguments:
if( size( WFM::Args() ) > 0
    && is( WFM::Args(0), string )
  )
{ func = (string)WFM::Args(0);
  if( size( WFM::Args() ) > 1
      && is( WFM::Args(1), map )
    )
  { param = (map)WFM::Args(1);
  }
}
y2milestone("Printer proposal func='%1'", func);
y2milestone("Printer proposal param='%1'", param);


// Create a textual proposal and write it instantly to the system:
if( func == "MakeProposal" )
{ list<string> proposal = [];
  string warning = nil;
  symbol warning_level = nil;
  boolean force_reset = param["force_reset"]:false;
  if( force_reset )
  { // Do not call Printer::Read() here to
    // avoid that the hardware proposal asks the user
    // to install the packages cups-client and cups, see
    // https://bugzilla.novell.com/show_bug.cgi?id=445719#c13
    y2milestone("Not calling Printer::Read() to avoid that the proposal asks to install cups-client and cups.");
  }
  // Propose configuration for each local printer:
  // Check if the packages cups-client and cups are installed
  // and skip the automated queue setup if one of them is missing, see
  // https://bugzilla.novell.com/show_bug.cgi?id=445719#c13
  // If cups-client is missing, it would run into an endless sequence of errors.
  // If cups is missing, there can be no local running cupsd which is
  // mandatory to set up local print queues.
  if( ! Printerlib::TestAndInstallPackage( "cups-client", "installed" ) )
  { y2milestone("Skipped automated queue setup because the package cups-client is not installed.");
    proposal = [ _("Cannot configure printing (required package cups-client is not installed).") ];
  }
  else
  { if( ! Printerlib::TestAndInstallPackage( "cups", "installed" ) )
    { y2milestone("Skipped automated queue setup because the package cups is not installed.");
      proposal = [ _("Cannot configure local printers (required package cups is not installed).") ];
    }
    else
    { // Determine whether or not it is currently a real client-only config
      // (i.e. a ServerName != "localhost/127.0.0.1" in /etc/cups/client.conf)
      // and ignore when it fails (i.e. use the fallback value silently):
      Printerlib::DetermineClientOnly();
      // Skip automated queue setup when it is a client-only config:
      if( Printerlib::client_only )
      { y2milestone("Skipped automated queue setup because it is a client-only config.");
        proposal = [ sformat( _("No local printer accessible (using remote CUPS server '%1' for printing)."),
                              Printerlib::client_conf_server_name
                            )
                   ];
      }
      else
      { // Determine whether or not a local cupsd is accessible:
        if( ! Printerlib::GetAndSetCupsdStatus( "" ) )
        { // Only in the second stage of the system installation
          // try to make silently sure that a local cupsd is running
          // (i.e. start the cupsd without user confirmation)
          // because it is needed for automated queue setup
          // see https://bugzilla.novell.com/show_bug.cgi?id=418585
          // Note that because of Mode::installation() this happens only
          // if we are doing a fresh installation (but e.g. not for an update)
          // and because of Stage::cont() we are continuing the installation
          // in the target system (but we are e.g. not in the inst-sys system)
          // so that it should be sufficiently safe to (re)-start and enable
          // the cupsd without user confirmation here:
          if( Mode::installation() && Stage::cont() )
          { y2milestone("Silently start and enable the cupsd because we are continuing a fresh installation in the target system.");
            if( Service::Status( "cups" ) != 0 )
            { Service::Start( "cups" );
            }
            else
            { // Restart the cupsd when it seems to run according to Service::Status
              // but actually it is not accessible according to GetAndSetCupsdStatus.
              // For example the cupsd may run but failed to bind to the IPP port 631
              // because whatever other service grabbed this port for a short while
              // so that a restart could help here (a known ypbind/portmapper issue):
              Service::Restart( "cups" );
            }
            Service::Enable( "cups" );
            // Wait until the cupsd is actually accessible.
            // In particular for the very first start of the cupsd it may take several seconds
            // (up to more than a minute on a slow machine) until it is actually accessible,
            // compare https://bugzilla.novell.com/show_bug.cgi?id=429397
            // Sleep one second in any case so that the new started cupsd can become ready to operate:
            sleep( 1000 );
            if( ! Printerlib::GetAndSetCupsdStatus( "" ) )
            { // The cupsd is not yet accessible.
              // Sleep 9 seconds so that the new started cupsd has more time to become ready to operate:
              sleep( 9000 );
            }
            if( ! Printerlib::GetAndSetCupsdStatus( "" ) )
            { // After waiting 10 seconds without user notification, become verbose now.
              // Wait half a minute for a new started cupsd:
              Popup::TimedMessage( _("Started the CUPS daemon.
Waiting half a minute for the CUPS daemon to get ready to operate...
"),
                                   30
                                 );
            }
            if( ! Printerlib::GetAndSetCupsdStatus( "" ) )
            { // It can take up to a few minutes when a cupsd is started
              // for the very first time (e.g. on a new installed system)
              // until the cupsd is actually ready to operate.
              // E.g. because parsing of thousands of PPDs may need much time.
              // Therefore enforce waiting one minute now.
              // (Plain busy message without title.)
              Popup::ShowFeedback( "", _("The CUPS daemon is not yet accessible.\nWaiting one minute so that it is ready to operate...") );
              sleep( 60000 );
              Popup::ClearFeedback();
            }
          }
        }
        // Skip automated queue setup when the cupsd is not accessible up to now.
        // A special case is when the cupsd does not listen on the official IANA IPP port (631).
        // Then Printerlib::GetAndSetCupsdStatus("") returns false because it calls
        // "lpstat -h localhost -r" which fails ("-h localhost:port" would have to be used).
        // The YaST printer module does not support when the cupsd listens on a non-official port
        // so that also in this special case no automated queue setup is done.
        if( ! Printerlib::GetAndSetCupsdStatus( "" ) )
        { y2milestone("Skipped automated queue setup because there is no local cupsd accessible (via port 631).");
          proposal = [ _("Cannot configure local printers (no local cupsd accessible).") ];
        }
        else
        { list<term> detected_printers = filter( term row,
                                                 (list<term>)Printer::ConnectionItems( "BasicAddDialog" ),
                                                 { // Printer::ConnectionItems does not return entries
                                                   // with an empty URI (i.e. no need to test this here)
                                                   // but Printer::ConnectionItems adds trailing spaces
                                                   // because the current YaST UI has almost no additional
                                                   // space between table columns:
                                                   string model = String::CutBlanks(row[1]:"");
                                                   return( ! issubstring( tolower( model ), "unknown" ) );
                                                 }
                                               );
          y2milestone( "Detected local printers: %1", detected_printers );
          if( size(detected_printers) < 1 )
          { y2milestone("Skipped automated queue setup because there is no local printer detected.");
            proposal = [ _("No local printer detected.") ];
          }
          else
          { y2milestone("Local printers detected, will set up queues for them:");
            list<string> initially_existing_queues = [];
            list<string> already_set_up_uris = [];
            // An empty list of autodetected queues is the fallback which is correct:
            Printer::AutodetectQueues();
            foreach( map< string, string > queue,
                     Printer::queues,
                     { if( "" != queue["name"]:"" )
                       { initially_existing_queues = add( initially_existing_queues, queue["name"]:"" );
                       }
                       if( "" != queue["uri"]:"" )
                       { already_set_up_uris = add( already_set_up_uris, queue["uri"]:"" );
                       }
                     }
                   );
            foreach( term printer,
                     detected_printers,
                     { // Printer::ConnectionItems adds trailing spaces because the current YaST UI
                       // has almost no additional space between table columns:
                       string model = String::CutBlanks(printer[1]:"");
                       if( "" != model && "unknown" != tolower( model ) )
                       { string uri = String::CutBlanks(printer[2]:"");
                         if( "" != uri )
                         { y2internal("Setting up a queue for URI '%1'", uri);
                           // See basicadd.ycp how a queue_name_proposal is set there:
                           string queue_name = Printer::NewQueueName( tolower( model ) );
                           if( contains( already_set_up_uris, uri ) )
                           { y2internal("Skipping printer '%1' because a queue with the same URI already exists.", printer);
                             continue;
                           }
                           y2milestone("Proposed queue name: %1", queue_name);
                           // See basicadd.ycp how driver_filter_input_text and driver_filter_string are set there.
                           // The same is done here so that the proposal results the same as if the user
                           // would have blindly clicked [OK] in the BasicAddDialog:
                           string driver_filter_input_text = Printer::DeriveModelName( model, 0 );
                           string driver_filter_string = Printer::DeriveDriverFilterString( driver_filter_input_text );
                           if( "" != driver_filter_string )
                           { list drivers = Printer::DriverItems( driver_filter_string, true );
                             // Printer::DriverItems may result a drivers list with one single element
                             //   [ `item( `id( -1 ), _("No matching driver found.") ) ]
                             // to show at least a meaningful text as fallback entry to the user
                             // or Printer::DriverItems may result a drivers list with the first item
                             //   [ `item( `id( -1 ), _("Select a driver.") ), ... ]
                             // when Printer::DriverItems could not preselect a driver item.
                             // In contrast if a valid driver was found and preselected, there would be
                             // a non-negative id value of the first element which is drivers[0,0,0]
                             // (id[0] is the value of the id, see the comment in Printer::DriverItems).
                             // Only a test if both selected_ppds_index and selected_connections_index
                             // are non-negative makes sure that there is a valid driver and a valid connection.
                             y2internal("Available drivers: %1", drivers);
                             Printer::selected_ppds_index = drivers[0,0,0]:-1;
                             Printer::selected_connections_index = printer[0,0]:-1;
                             if( Printer::selected_ppds_index >= 0
                                 && Printer::selected_connections_index >= 0
                               )
                             { y2internal("Selected driver: %1", drivers[0]:nil);
                               // An empty default_paper_size results CUPS's default paper size
                               // (see the Printer::AddQueue function) so that the proposal results the same
                               // as if the user would have blindly clicked [OK] in the BasicAddDialog.
                               // The BasicAddDialog does by default not set the default queue
                               // to avoid that a possibly existing default queue gets overwritten.
                               boolean is_default_queue = false;
                               string default_paper_size = "";
                               if( Printer::AddQueue( queue_name, is_default_queue, default_paper_size ) )
                               { already_set_up_uris = add( already_set_up_uris, uri );
                                 // Since CUPS 1.4 the new DirtyCleanInterval directive controls
                                 // the delay when cupsd updates config files (see basicadd.ycp).
                                 if( ! Printerlib::WaitForUpdatedConfigFiles( _("Creating New Printer Setup") ) )
                                 { // It returns false if the user had interrupted the waiting for updated config files:
                                   Popup::ErrorDetails( // Message of a Popup::ErrorDetails:
                                                        _("New Printer Configuration not yet Stored in the System"),
                                                        // Explanation details of a Popup::ErrorDetails.
                                                        _("This may result broken printer configurations.")
                                                      );
                                 }
                                 // Autodetect queues again so that Printer::NewQueueName
                                 // can compare with existing queue names but ignore whatever failures
                                 // (an empty list of autodetected queues is the fallback result):
                                 Printer::AutodetectQueues();
                               }
                             }
                             else
                             { y2error("No available drivers for printer %1", printer);
                             }
                           }
                         }
                       }
                     }
                   );
            foreach( term queue,
                     (list<term>)Printer::QueueItems( true, false ),
                     { // Printer::QueueItems adds trailing spaces because the current YaST UI
                       // has almost no additional space between table columns:
                       string name = String::CutBlanks(queue[2]:"");
                       string description = String::CutBlanks(queue[3]:"");
                       string configuration = name;
                       if( description != "" )
                       { configuration = configuration + " : " + description;
                       }
                       if( contains( initially_existing_queues, name ) )
                       { // The automated printer setup found an already existing configuration:
                         proposal = add( proposal, _("Found existing configuration") + " : " + configuration );
                       }
                       else
                       { // The automated printer setup created a new configuration:
                         proposal = add( proposal, _("Created configuration") + " : " + configuration );
                       }
                     }
                   );
          }
        }
      }
    }
  }
  proposal = filter( string p, proposal, { return p != ""; } );
  if( size(proposal) == 0 )
  { proposal = [ _("No local printer configured.") ];
  }
  ret = $[ "raw_proposal" : proposal,
           "warning_level" : warning_level,
           "warning" : warning,
         ];
}
// Run the full printer module dialogs:
else if(func == "AskUser")
{ // Call Printer::Read() here (compare "MakeProposal" above)
  // to make sure that when the full printer module dialogs are launched
  // it asks the user to install the packages cups-client and cups:
  boolean progress_orig = Progress::set( false );
  Printer::Read();
  Progress::set( progress_orig );
  // In printer.ycp the .propose argument calls PrinterAutoSequence and
  // PrinterAutoSequence in wizards.ycp runs only the MainSequence
  // which are all the usual dialogs (starting with the "Overview")
  // but without running before ReadDialog (which calls only Printer::Read)
  // and running afterwards WriteDialog (which calls only Printer::Write)
  // which is the reason that Printer::Read is called explicitly above.
  symbol seq = (symbol) WFM::CallFunction("printer", [.propose]);
  y2debug("seq=%1",seq);
  ret = $[ "workflow_sequence" : seq ];
}
// Create titles:
else if(func == "Description")
{ ret = $[ /* Rich text title for Printer in proposals */
           "rich_text_title" : _("Printer"),
           /* Menu title for Printer in proposals */
           "menu_title" : _("&Printer"),
           "id" : "printer",
         ];
}
// Dummy function to write the proposal (it is already written in the "MakeProposal" function):
else if(func == "Write")
{ // There is no need to call Printer::Write() here because
  // it does actually nothing except to exit verbosely, see
  // http://en.opensuse.org/YaST/Development/Printer_Enhancement#Basic_Implementation_Principles:
  // for background information.
  y2milestone("No need to call Printer::Write() because it does nothing.");
}
// Unknown function:
else
{ y2error("Unknown function: %1", func);
}

y2debug("ret=%1",ret);
y2milestone("Printer proposal finished");
y2milestone("----------------------------------------");
return ret;

/* EOF */
}

