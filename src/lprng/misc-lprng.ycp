/**
 * File:
 *  misc.ycp
 *
 * Module:
 *  Printer configurator
 *
 * Summary:
 *  Miscelaneous defines.
 *
 * Authors:
 *  Petr Blahos <pblahos@suse.cz>
 *  Jiri Srain <jsrain@suse.cz>   2002
 *
 * $Id$
 *
 * Miscelaneous defines.
 */

{
    textdomain "printer";
    import "Printer";
    import "Printerlib";
    import "Report";

    include "printer/testpage.ycp";
    include "printer/ppds.ycp";

    /**
     * Write the .upp file and the configuration.
     * @param entry Entry for printer to save.
     * @return boolean true if successful
     */
    global define boolean createUppFile (map entry) ``{
	// FIXME
	string pagesize = "a4";
	// FIXME
	string resolution = "1800x1800";
        string upp_file = sformat (
	    "-sDEVICE=pswrite\n-sPAPERSIZE=%1\n-r%2\n", pagesize, resolution);
        string name = lookup (entry, "name", "");

        // Save the .upp file
        SCR::Execute (.target.mkdir, sformat ("/etc/lpdfilter/%1", name));
        string fname = sformat ("/etc/lpdfilter/%1/upp", name);
        if (!SCR::Write (.target.string, fname, upp_file))
        {
            // message box %1 is filename
            Report::Error (sformat (_("Cannot write %1."), fname));
            return false;
        }
	SCR::Execute (.target.bash, sformat ("/bin/chmod 644 %1", fname));
	fname = sformat ("/etc/lpdfilter/%1/post", name);
	string post_file = sformat (
	    "foomatic-rip --ppd /etc/lpdfilter/%1/ppd", name);
        if (!SCR::Write (.target.string, fname, post_file))
        {
            // message box %1 is filename
            Report::Error (sformat (_("Cannot write %1."), fname));
            return false;
        }
	SCR::Execute (.target.bash, sformat ("/bin/chmod 755 %1", fname));

	string ppd = lookup (entry, "ppd", "");
        if (ppd != "" && -1 == SCR::Read (.target.size, ppd))
        {
            y2error ("Unexsistent PPD file: %1", ppd);
                // error popup
            Report::Error (sformat (_("An error occurred while saving queue %1.

The specified PPD file does not exist.
"), name));
            return false;
        }

	entry = getUpdatedPpdFile (entry);
	if (entry == nil)
	    return false;

	string from = entry["ppd"]:"";
	string to = sformat ("/etc/lpdfilter/%1/ppd", name);
	SCR::Execute (.target.bash, sformat ("/bin/cp %1 %2", from, to));
        return true;
    }


    /**
     * Add a remote printer to the printcap.
     * @param entry Entry for printer to save.
     * @return boolean true if successful
     */
    global define boolean createRemoteEntry (map entry) ``{
        string uri = lookup (entry, "uri", "");
        string hostname = Printerlib::getUriHost (uri);
        string queue = Printerlib::getUriRemoteQueue (uri);
        string name = lookup (entry, "name", "");
        string tail = "";
        if (!lookup (entry, "ff", false))
            tail = " -sf";

        y2milestone ("%1", uri);
        y2milestone ("%1", entry);
        if (hostname != "" && queue != "" && name != "")
        {
            if (callLprsetup (sformat ("/usr/lib/lpdfilter/bin/lprsetup -lprng -overwrite %1 -host %2 -rp %3 -raw -color", name, hostname, queue) + tail))
                return true;
        }
        // message box
        Report::Error (_("Unable configure a remote
queue. The internal structure
is not completed properly.
"));

        return false;
    }


    /**
     * Add a yast2 printer to the printcap
     * @param entry Entry for printer to save.
     * @return boolean true if successful
     */
    global define boolean createEntry (map entry) ``{
        string uri = lookup (entry, "uri", "");
        string name = lookup (entry, "name", "");
        string device = "/dev/null";
        string baudrate_str = "";
        string tail = " -driver upp -own -color";
        if (lookup (entry, "raw", false))
            tail = " -raw";
        else if (lookup (entry, "ascii", false)) //Queue mustn't be ascii AND raw
            tail = tail + " -ascii";
        if (!lookup (entry, "ff", false))
            tail = tail + " -sf";

        string con_type = Printerlib::getUriType (uri);
        if (con_type == "parallel" ||
            con_type == "serial" ||
            con_type == "usb" ||
            con_type == "irda")
        {
            device = Printerlib::getUriDevice (uri);
            if (con_type == "serial")
            {
                integer baudrate = Printerlib::getUriBaudrate (uri);
                if (baudrate != 0)
                {
                    baudrate_str = sformat ("-br %1", baudrate);
                }
            }
            if (con_type == "serial")
            {
                string ser_opt = Printerlib::getUriValue (uri, "ty");
                if (filterchars (ser_opt, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-") == "")
                    ser_opt = "ixon -imaxbel -ixany -ixoff -crtscts";
                tail = tail + sformat (" -ty \"%1\"", ser_opt);;
            }
            if (callLprsetup (sformat ("/usr/lib/lpdfilter/bin/lprsetup -lprng -overwrite %1 -device %2 %3", name, device, baudrate_str) + tail)
)
                return true;
        }
        else if (con_type == "samba" || con_type == "novell")
        {
            // create file redirect
            string ret = getRemoteEntry (uri);
            string fn = "/etc/lpdfilter/" + name + "/redirect";
            SCR::Write (.target.string, fn, ret);
            SCR::Execute (.target.bash, sformat ("chmod 0750 %1 ; chown lp:lp %1", fn));
            if (callLprsetup (sformat ("/usr/lib/lpdfilter/bin/lprsetup -lprng -overwrite %1 -device /dev/null", name) + tail))
                return true;
        }
        else if (con_type == "pipe")
        {
            if (callLprsetup (sformat ("/usr/lib/lpdfilter/bin/lprsetup -lprng -overwrite %1 -redirect '%2' -device /dev/null", name, Printerlib::getUriDevice (uri)) + tail))
                return true;
        }
        else if (con_type == "ipp")
        {
            string queue = Printerlib::getUriRemoteQueue (uri);
            if ("printers/" == substring (queue, 0, 9))
                queue = substring (queue, 9);
            if (callLprsetup (sformat ("/usr/lib/lpdfilter/bin/lprsetup -lprng -overwrite %1 -device '| -$ /usr/bin/lp.cups -d %3 -h %2'", name, Printerlib::getUriHost (uri), queue) + tail))
                return true;
        }
        else if (con_type == "filtering")
        {
            if (callLprsetup (sformat ("/usr/lib/lpdfilter/bin/lprsetup -lprng -overwrite %1 -host %2 -rp %3", name, Printerlib::getUriHost (uri), Printerlib::getUriRemoteQueue (uri)) + tail))
                return true;
        }
        else if (con_type == "socket")
        {
            if (callLprsetup (sformat ("/usr/lib/lpdfilter/bin/lprsetup -lprng -overwrite %1 -host %2 -port %3", name, Printerlib::getUriHost (uri), Printerlib::getUriPort (uri)) + tail))
//Printerlib::getUriRemoteQueue (uri)) + tail))
                return true;
        }
        // message box
        Report::Error (_("Unable configure a printer
queue. The internal structure
is not completed properly.
"));
        return false;
    }
    /**
     * Call lprsetup
     * @param command command to call
     * @return boolean true if successful
     */
    global define boolean callLprsetup (string command) ``{
        integer succ = SCR::Execute (.target.bash, command);
	if (succ != 0 && regexpmatch (command, "^.* -overwrite .*$"))
	{
	    // Ugly hack - workaround of lprsetup problems (#24979)
	    command = regexpsub (command, "^(.*) -overwrite (.*)$",
		"\\1 -add \\2");
	    succ = SCR::Execute (.target.bash, command);
	}
        if (succ != 0 || (-1 == SCR::Read(.target.size, "/etc/printcap")))
	{
	    // Ugly hack - workaround of lprsetup problems (#24979)
	    if (! regexpmatch (command, "^.* -delete .*$"))
            {
                // message box
                Report::Error (sformat (_("Running lprsetup (%1) was not successful."), command));
                return false;
            }
	}
        return true;
    }

    /**
     * Write one printer.
     * Only for LPRng
     * @param entry printer to write.
     * @return boolean success?
     */
    global define boolean writeLpdPrinter (map entry) ``{
        if (entry["database"]:"" == "foomatic")
        {
            loadFoomaticIfNeeded ();
        }
        else
        {
            Report::Error (sformat (_("Only foomatic queues are supported: %1"),
                entry["name"]:""));
        }
        map saved = lookup (entry, "saved", $[]);
        string printcap_part =     lookup (saved, "printcap_part", "");
        map conf = lookup (entry, "conf", $[]);
        string upp_fname = lookup (saved, "upp_fname", "");
        string upp_orig =  lookup (saved, "upp", "");
        string uri = lookup (entry, "uri", "");
        string name = lookup (entry, "name", "");
        string uri_type = Printerlib::getUriType (uri);

        if (lookup (entry, "type", "yast2") != "yast2")
            return false;
        if (lookup (entry, "uri", "class") == "class")
        {
            return false;
        }
        if ("void" == lookup (entry, "lprng-state", "changed"))
        {
            return false;
        }

        //
        // new or renamed printer?
        //
        if (printcap_part != "" && !lookup (entry, "recreate", false))
        {
            // We have a part of the printcap from previous configuration...
            if (lookup (entry, "type", "yast2") == "yast2" && Printerlib::getUriType (uri) != "lpd")
            {
                if ("" != upp_fname && "" != upp_orig)
                {
                    // We have saved upp file. Save it.
                    // Why do we save it when it was already saved? Because printer could be renamed.
                    SCR::Write (.target.string, upp_fname, upp_orig);
                }
                else
                {
                    // upp file changed (or did not exist). Save it again.
                    if (!createUppFile (entry))
                    {
			// message box
                        UI::MessagePopup (sformat (_("Error occurred while saving queue %1."), name));
                        return false;
                    }
                }
            }
            SCR::Execute (.target.bash, sformat ("/bin/echo -n '%1' >> /etc/printcap", printcap_part));
        }
        else
        {
            // New entry - we must do everything
            if (lookup (entry, "type", "yast2") == "yast2")
            {
                SCR::Execute (.target.mkdir, "/etc/lpdfilter/" + name);
                if (Printerlib::getUriType (uri) == "lpd")
                {
                    if (!createRemoteEntry (entry))
                    {
			// message box
                        UI::MessagePopup (sformat (_("Error occurred while saving queue %1."), name));
                        return false;
                    }
                }
                else
                {
                    if (!createEntry (entry))
                    {
			// message box
                        UI::MessagePopup (sformat (_("Error occurred while saving queue %1."), name));
                        return false;
                    }
                    if ("" != upp_orig)
                    {
                        // create rc file name
                        upp_fname = sformat ("/etc/lpdfilter/%1/upp", name);
                        // We have saved upp file. Save it.
                        // Why do we save it when it was already saved? Because printer could be renamed.
                        SCR::Write (.target.string, upp_fname, upp_orig);
                    }
                    else
                    {
                        // upp file changed (or did not exist). Save it again.
                        if (!createUppFile (entry))
                        {
			    // message box
                            UI::MessagePopup (sformat (_("Error occurred while saving queue %1."), name));
                            return false;
                        }
                    }
                }
            }
        }

        // conf file...
        if (lookup (entry, "type", "yast2") == "yast2" && Printerlib::getUriType (uri) != "lpd" || lookup (entry, "type", "") == "aps")
        {
            // create rc file name
            string conf_fname = sformat ("/etc/lpdfilter/%1/conf", name);
            // Is it Epson Stylus on USB? Add magic sequence to be printed before each job.
            if ("usb" == Printerlib::getUriType (uri) && issubstring (tolower (lookup (entry,"vendor","")),"epson"))
            {
                conf = add (conf, "reset_before",// this must stay as one line
                                  "\\x0\\x0\\x0\\x1b\\x01\\x40\\x45\\x4a\\x4c\\x20\\x31\\x32\\x38\\x34\\x2e\\x34\\x0a\\x40\\x45\\x4a\\x4c\\x20\\x20\\x20\\x20\\x20\\x0a");
            }
            writeConf (conf_fname, conf);
        }
        return true;
    }


}
