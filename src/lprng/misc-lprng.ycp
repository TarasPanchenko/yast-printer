/**
 * File:
 *  misc.ycp
 *
 * Module:
 *  Printer configurator
 *
 * Summary:
 *  Miscelaneous defines.
 *
 * Authors:
 *  Petr Blahos <pblahos@suse.cz>
 *  Jiri Srain <jsrain@suse.cz>   2002
 *
 * $Id$
 *
 * Miscelaneous defines.
 */

{
    textdomain "printer";

    import "Popup";
    import "Printerdb";
    import "Printerlib";
    import "Report";

    /**
     * Write conf file onto disk.
     * @param fn filename
     * @param conf file contents
     */
    global define void writeConf (string fn, map conf) ``{
	string s = "#\n# for documentation see /usr/lib/lpdfilter/global/optional.options\n#\n\n";
	foreach (`k, `v, conf, ``{
	    s = s + sformat ("%1=\"%2\"\n", k, v);
	});
	SCR::Write (.target.string, fn, s);
	SCR::Execute (.target.bash, sformat ("/bin/chmod 660 %1 ; /bin/chown lp:lp %1", fn));
    }

    /**
     * Write the .upp file and the configuration.
     * @param entry Entry for printer to save.
     * @return boolean true if successful
     */
    global define boolean createUppFile (map entry) ``{
	// save modified PPD file
        entry = Printerdb::getUpdatedPpdFile (entry);
        if (entry == nil)
            return false;

        string from = entry["ppd"]:"";
        string to = sformat ("/etc/lpdfilter/%1/ppd", name);
        SCR::Execute (.target.bash, sformat ("/bin/cp %1 %2", from, to));

	string pagesize = tolower (entry["options", "PageSize"]:"a4");
	map out = SCR::Execute (.target.bash_output, sformat (
	    "/usr/lib/YaST2/bin/real_resolution %1", to));
	string resolution = "1800x1800";
	if (out["exit"]:-1 == 0)
	    resolution = tolower (out["stdout"]:resolution);
	integer nl_index = findfirstof (resolution, "\n\t ");
	if (nl_index != nil)
	{
	    resolution = substring (resolution, 0, nl_index);
	}
        string upp_file = sformat (
	    "-sDEVICE=PS\n-sPAPERSIZE=%1\n-r%2\n", pagesize, resolution);
        string name = lookup (entry, "name", "");

        // Save the .upp file
        string fname = sformat ("/etc/lpdfilter/%1/upp", name);
        if (!SCR::Write (.target.string, fname, upp_file))
        {
            // message box %1 is filename
            Report::Error (sformat (_("Cannot write %1."), fname));
            return false;
        }
	SCR::Execute (.target.bash, sformat ("/bin/chmod 644 %1", fname));
	fname = sformat ("/etc/lpdfilter/%1/post", name);
	string post_file = sformat (
	    "foomatic-rip --ppd /etc/lpdfilter/%1/ppd", name);
        if (!SCR::Write (.target.string, fname, post_file))
        {
            // message box %1 is filename
            Report::Error (sformat (_("Cannot write %1."), fname));
            return false;
        }
	SCR::Execute (.target.bash, sformat ("/bin/chmod 755 %1", fname));

	string ppd = lookup (entry, "ppd", "");
        if (ppd != "" && -1 == SCR::Read (.target.size, ppd))
        {
            y2error ("Unexsistent PPD file: %1", ppd);
                // error popup
            Report::Error (sformat (_("An error occurred while saving queue %1.

The specified PPD file does not exist."), name));
            return false;
        }

        return true;
    }


    /**
     * Add a yast2 printer to the printcap
     * @param entry Entry for printer to save.
     * @return boolean true if successful
     */
    global define boolean createEntry (map entry) ``{
        string uri = lookup (entry, "uri", "");
        string name = lookup (entry, "name", "");
        string device = "/dev/null";
        string baudrate_str = "";
        string tail = " -driver upp -own -color";
        if (lookup (entry, "raw", false))
            tail = " -raw";
        else if (lookup (entry, "ascii", false)) //Queue mustn't be ascii AND raw
            tail = tail + " -ascii";
        if (!lookup (entry, "ff", false))
            tail = tail + " -sf";

        string con_type = Printerlib::getUriType (uri);
        if (con_type == "parallel" ||
            con_type == "serial" ||
            con_type == "usb" ||
            con_type == "irda")
        {
            device = Printerlib::getUriDevice (uri);
            if (con_type == "serial")
            {
                integer baudrate = Printerlib::getUriBaudrate (uri);
                if (baudrate != 0)
                {
                    baudrate_str = sformat ("-br %1", baudrate);
                }
                string ser_opt = Printerlib::getUriValue (uri, "ty");
                if (filterchars (ser_opt, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-") == "")
                    ser_opt = "ixon -imaxbel -ixany -ixoff -crtscts";
                tail = tail + sformat (" -ty \"%1\"", ser_opt);;
            }
            if (callLprsetup (sformat ("/usr/lib/lpdfilter/bin/lprsetup -lprng -overwrite %1 -device %2 %3", name, device, baudrate_str) + tail))
                return true;
        }
        else if (con_type == "samba" || con_type == "novell")
        {
            // create file redirect
            string ret = getRemoteEntry (uri);
            string fn = "/etc/lpdfilter/" + name + "/redirect";
            SCR::Write (.target.string, fn, ret);
            SCR::Execute (.target.bash, sformat ("chmod 0750 %1 ; chown lp:lp %1", fn));
            if (callLprsetup (sformat ("/usr/lib/lpdfilter/bin/lprsetup -lprng -overwrite %1 -device /dev/null", name) + tail))
                return true;
        }
        else if (con_type == "pipe")
        {
            if (callLprsetup (sformat ("/usr/lib/lpdfilter/bin/lprsetup -lprng -overwrite %1 -redirect '%2' -device /dev/null", name, Printerlib::getUriDevice (uri)) + tail))
                return true;
        }
        else if (con_type == "lpd")
        {
            if (callLprsetup (sformat ("/usr/lib/lpdfilter/bin/lprsetup -lprng -overwrite %1 -host %2 -rp %3", name, Printerlib::getUriHost (uri), Printerlib::getUriRemoteQueue (uri)) + tail))
                return true;
        }
        else if (con_type == "socket")
        {
            if (callLprsetup (sformat ("/usr/lib/lpdfilter/bin/lprsetup -lprng -overwrite %1 -host %2 -port %3", name, Printerlib::getUriHost (uri), Printerlib::getUriPort (uri)) + tail))
                return true;
        }
        // message box
        Report::Error (_("Unable configure a printer
queue. The internal structure
is not completed properly."));
        return false;
    }
    /**
     * Call lprsetup
     * @param command command to call
     * @return boolean true if successful
     */
    global define boolean callLprsetup (string command) ``{
        integer succ = SCR::Execute (.target.bash, command);
	if (succ != 0 && regexpmatch (command, "^.* -overwrite .*$"))
	{
	    // Ugly hack - workaround of lprsetup problems (#24979)
	    command = regexpsub (command, "^(.*) -overwrite (.*)$",
		"\\1 -add \\2");
	    succ = SCR::Execute (.target.bash, command);
	}
        if (succ != 0 || (-1 == SCR::Read(.target.size, "/etc/printcap")))
	{
	    // Ugly hack - workaround of lprsetup problems (#24979)
	    if (! regexpmatch (command, "^.* -delete .*$"))
            {
                // message box
                Report::Error (sformat (_("Running lprsetup (%1) was not successful."), command));
                return false;
            }
	}
        return true;
    }

    /**
     * Write one printer.
     * Only for LPRng
     * @param entry printer to write.
     * @return boolean success?
     */
    global define boolean writeLpdPrinter (map entry) ``{
        Printerdb::loadFoomaticIfNeeded ();
        map conf = entry["conf"]:$[];
        string uri = entry["uri"]:"";
        string name = entry["name"]:"";

        if (entry["type"]:"yast2" != "yast2")
            return false;

	SCR::Execute (.target.mkdir, "/etc/lpdfilter/" + name);
	if (! (createEntry (entry) && createUppFile (entry)))
	{
	    Popup::Message (sformat (
		// message box
		_("Error occurred while saving queue %1."), name));
	    return false;
	}

	// conf file...
	string conf_fname = sformat ("/etc/lpdfilter/%1/conf", name);
	// Is it Epson Stylus on USB?
	// Add magic sequence to be printed before each job.
	if ("usb" == Printerlib::getUriType (uri)
	    && entry["ppd_info", "manufacturer_db"]:"" == "EPSON")
	{
	    conf["reset_before"] = // this must stay as one line
		"\\x0\\x0\\x0\\x1b\\x01\\x40\\x45\\x4a\\x4c\\x20\\x31\\x32\\x38\\x34\\x2e\\x34\\x0a\\x40\\x45\\x4a\\x4c\\x20\\x20\\x20\\x20\\x20\\x0a";
	}
	writeConf (conf_fname, conf);
	return true;
    }


}
