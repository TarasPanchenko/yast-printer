
{

module "Printerlib";
textdomain "printer";

import "Popup";
import "Report";
import "Service";

// Fortunately the tools are for all architectures always
// installed in /usr/lib/YaST2/bin/ (i.e. no "lib64").
// I tested this on Thu Aug 28 2008 using the command
// rpm -qlp /work/CDs/all/full-sle10-sp2*/suse/*/yast2-printer.rpm | grep '/YaST2/bin/' | grep -v '/usr/lib/YaST2/bin/'
global string yast_bin_dir = "/usr/lib/YaST2/bin/";

// The result map is used as a simple common local store for whatever additional results
// (in particular commandline exit code, stdout, stderr, and whatever messages)
// so that the local functions in this module can be of easy-to-use boolean type.
// The following keys are used:
// result["exit"]:<integer> for exit codes
// result["stdout"]:<string> for stdout and whatever non-error-messages
// result["stderr"]:<string> for stderr and whatever error-messages
global map result = $[ "exit":0,
                       "stdout":"",
                       "stderr":""
                     ];

/**
 * Wrapper for SCR::Execute to execute a bash command to increase verbosity via y2milestone.
 * It reports the command via y2milestone in any case and it reports exit code, stdout
 * and stderr via y2milestone in case of non-zero exit code.
 * @param bash_commandline string of the bash command to be executed
 * @return true on success
 */
global boolean ExecuteBashCommand( string bash_commandline )
{ y2milestone( "Executing bash commandline: %1", bash_commandline );
  // Enforce a hopefully sane environment before running the actual command:
  bash_commandline = "export PATH='/sbin:/usr/sbin:/usr/bin:/bin' ; export LC_ALL='POSIX' ; export LANG='POSIX' ; umask 022 ; " + bash_commandline;
  result = (map)SCR::Execute( .target.bash_output, bash_commandline );
  if( result["exit"]:9999 != 0 )
  { y2warning( "'%1' exit code is: %2", bash_commandline, result["exit"]:9999 );
    y2warning( "'%1' stdout is: %2", bash_commandline, result["stdout"]:"" );
    y2warning( "'%1' stderr is: %2", bash_commandline, result["stderr"]:"" );
    return false;
  }
  return true;
}

// By default there is a local running cupsd.
// But to be on the safe side, assume it is not:
global boolean local_cupsd_accessible = false;

global boolean GetAndSetCupsdStatus( string new_status )
{ // Determine whether or not a local cupsd is accessible.
  // The value 'false' is also the right one when the command itself fails
  // (e.g. when there is no /usr/bin/lpstat binary or whatever broken stuff):
  string local_cupsd_accessible_commandline = "/usr/bin/lpstat -h localhost -r";
  local_cupsd_accessible = ExecuteBashCommand( local_cupsd_accessible_commandline );
  // Start cupsd:
  if( "start" == new_status )
  { if( local_cupsd_accessible )
    { // Do not start an already running (i.e. accessible) cupsd:
      return true;
    }
    if( ! Service::Start( "cups" ) )
    { Report::Error( // Message of a Report::Error.
                     // Only a simple message because this error does not happen on a normal system
                     // (i.e. a system which is not totally broken or totally messed up).
                     _("Failed to start the CUPS daemon.")
                   );
      return false;
    }
    else
    { Popup::TimedMessage( _("Started the CUPS daemon.\nWaiting one minute so that it is ready to operate..."),
                           60
                         );
    }
    local_cupsd_accessible = ExecuteBashCommand( local_cupsd_accessible_commandline );
    if( ! local_cupsd_accessible )
    { Report::Error( // Message of a Report::Error.
                     // Only a simple message because this error does not happen on a normal system
                     // (i.e. a system which is not totally broken or totally messed up).
                     _("No local running CUPS daemon is accessible.")
                   );
      return false;
    }
    return true;
  }
  // Restart cupsd:
  if( "restart" == new_status )
  { if( ! Service::Restart( "cups" ) )
    { Report::Error( // Message of a Report::Error.
                     // Only a simple message because this error does not happen on a normal system
                     // (i.e. a system which is not totally broken or totally messed up).
                     _("Failed to restart the CUPS daemon.")
                   );
      return false;
    }
    else
    { Popup::TimedMessage( _("Restarted the CUPS daemon.\nWaiting one minute so that it is ready to operate..."),
                           60
                         );
    }
    local_cupsd_accessible = ExecuteBashCommand( local_cupsd_accessible_commandline );
    if( ! local_cupsd_accessible )
    { Report::Error( // Message of a Report::Error.
                     // Only a simple message because this error does not happen on a normal system
                     // (i.e. a system which is not totally broken or totally messed up).
                     _("No local running CUPS daemon is accessible.")
                   );
      return false;
    }
    return true;
  }
  // Stop cupsd:
  if( "stop" == new_status )
  { // To be on the safe side try to stop the cupsd regardless if it is accessible or not
    // and ignore possible errors from Service::Stop when it is already stopped
    // (the local_cupsd_accessible test below should be sufficient):
    Service::Stop( "cups" );
    // Wait one second to make sure that cupsd has really finished (it may do some cleanup):
    sleep( 1000 );
    local_cupsd_accessible = ExecuteBashCommand( local_cupsd_accessible_commandline );
    if( local_cupsd_accessible )
    { Report::Error( // Message of a Report::Error.
                     // Only a simple message because this error does not happen on a normal system
                     // (i.e. a system which is not totally broken or totally messed up).
                     _("A local running CUPS daemon is still accessible.")
                   );
      return false;
    }
    return true;
  }
  // If new_status is neither "start" nor "restart" nor "stop",
  // return whether or not the local cupsd is accessible:
  return local_cupsd_accessible;
}

// By default there is no active "ServerName" entry in /etc/cups/client.conf:
global string client_conf_server_name = "";
global boolean client_only = false;

global boolean DetermineClientOnly()
{ // Determine the 'ServerName' value in /etc/cups/client.conf:
  if( ExecuteBashCommand( yast_bin_dir + "cups_client_only" ) )
  { client_conf_server_name = result["stdout"]:"";
    if( "" != client_conf_server_name
        && "localhost" != client_conf_server_name
        && "127.0.0.1" != client_conf_server_name )
    { // Note that even 'localhost' or '127.0.0.1' is a valid ServerName value
      // which is used to force client tools (e.g. lpadmin, lpinfo, lpstat)
      // to ask the local cupsd via the IPP port on localhost (127.0.0.1:631)
      // and not via the domain socket (/var/run/cups/cups.sock) because
      // the latter failed in the past for certain third-party clients (e.g. Java).
      // If the ServerName value in /etc/cups/client.conf is 'localhost'
      // it is actually no client-only config because the local cupsd is used.
      client_only = true;
    }
    else
    { client_only = false;
    }
  }
  else
  { // Use fallback values when the command above failed:
    client_conf_server_name = "";
    client_only = false;
    return false;
  }
  return true;
}

// By default there is "Browsing On" in /etc/cups/cupsd.conf
// which is even the fallback if there is no "Browsing" entry at all
// or when the "Browsing" entry is deactivated by a leading '#' character.
// Therefore browsing_on is only false if "Browsing Off" or "Browsing No"
// is explicitely set in /etc/cups/cupsd.conf.
global boolean browsing_on = true;

global boolean DetermineBrowsing()
{ // Determine the 'Browsing [ On | Off ]' value in /etc/cups/cupsd.conf:
  if( ExecuteBashCommand( yast_bin_dir + "modify_cupsd_conf Browsing" ) )
  { string browsing = tolower( result["stdout"]:"On" );
    if( "off" == browsing || "no" == browsing )
    { browsing_on = false;
    }
    else
    { browsing_on = true;
    }
  }
  else
  { // Use fallback value when the command above failed:
    browsing_on = true;
    return false;
  }
  return true;
}

// By default there is "BrowseAllow all" in /etc/cups/cupsd.conf
// which is even the fallback if there is no "BrowseAllow" entry at all
// or when the "BrowseAllow" entries are deactivated by a leading '#' character.
// Multiple BrowseAllow lines are allowed, e.g.:
//   BrowseAllow from @LOCAL
//   BrowseAllow from 192.168.200.1
//   BrowseAllow from 192.168.100.0/255.255.255.0
// so that each BrowseAllow line value is stored as one string
// in the cupsd_conf_browse_allow list of strings:
global list< string > cupsd_conf_browse_allow = [ "all" ];

global boolean DetermineBrowseAllow()
{  // Determine the 'BrowseAllow [ all | none | @LOCAL | IP-address[/netmask] ]' values in /etc/cups/cupsd.conf:
  if( ExecuteBashCommand( yast_bin_dir + "modify_cupsd_conf BrowseAllow" ) )
  { // The command outputs a line where multiple BrowseAllow values are separated by space
    // but possible duplicate BrowseAllow values are not removed in the command output:
    cupsd_conf_browse_allow = toset( splitstring( Printerlib::result["stdout"]:"all", " " ) );
  }
  else
  { // Use fallback value when the command above failed:
    cupsd_conf_browse_allow = [ "all" ];
    return false;
  }
  return true;
}

global map<string, any> operation_policy = $[];

global map<string, any> cups_autoconfig = $[];

global void Read()
{ // Determine the 'Browsing [ On | Off ]' value in /etc/cups/cupsd.conf
  // and ignore when it fails (i.e. use the fallback value silently):
  DetermineBrowsing();
  // Determine the 'BrowseAllow [ all | none | @LOCAL | IP-address[/netmask] ]'
  // values in /etc/cups/cupsd.conf and ignore when it fails (i.e. use the fallback value silently):
  DetermineBrowseAllow();
  // Determine the 'ServerName' value in /etc/cups/client.conf
  // and ignore when it fails (i.e. use the fallback value silently):
  DetermineClientOnly();
  // Read cups-autoconfiguration settings:
  cups_autoconfig = (map<string, any>)SCR::Read(.etc.cups-auto.all);
  y2internal("read cups-auto %1", cups_autoconfig);
}

global void Write()
{ // Write cups-autoconfiguration settings:
  y2milestone("Writing cups-autoconfig.conf\n%1", cups_autoconfig);
  SCR::Write(.etc.cups-auto.all, cups_autoconfig);
}

}

