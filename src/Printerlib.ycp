
{

module "Printerlib";
textdomain "printer";

// Fortunately the tools are for all architectures always
// installed in /usr/lib/YaST2/bin/ (i.e. no "lib64").
// I tested this on Thu Aug 28 2008 using the command
// rpm -qlp /work/CDs/all/full-sle10-sp2*/suse/*/yast2-printer.rpm | grep '/YaST2/bin/' | grep -v '/usr/lib/YaST2/bin/'
global string yast_bin_dir = "/usr/lib/YaST2/bin/";

// The result map is used as a simple common local store for whatever additional results
// (in particular commandline exit code, stdout, stderr, and whatever messages)
// so that the local functions in this module can be of easy-to-use boolean type.
// The following keys are used:
// result["exit"]:<integer> for exit codes
// result["stdout"]:<string> for stdout and whatever non-error-messages
// result["stderr"]:<string> for stderr and whatever error-messages
global map result = $[ "exit":0,
                       "stdout":"",
                       "stderr":""
                     ];

/**
 * Wrapper for SCR::Execute to execute a bash command to increase verbosity via y2milestone.
 * It reports the command via y2milestone in any case and it reports exit code, stdout
 * and stderr via y2milestone in case of non-zero exit code.
 * @param bash_commandline string of the bash command to be executed
 * @return true on success
 */
global boolean ExecuteBashCommand( string bash_commandline )
{ y2milestone( "Executing bash commandline: %1", bash_commandline );
  result = (map)SCR::Execute( .target.bash_output, bash_commandline );
  if( result["exit"]:9999 != 0 )
  { y2warning( "'%1' exit code is: %2", bash_commandline, result["exit"]:9999 );
    y2warning( "'%1' stdout is: %2", bash_commandline, result["stdout"]:"" );
    y2warning( "'%1' stderr is: %2", bash_commandline, result["stderr"]:"" );
    return false;
  }
  return true;
}

// By default there is no active "ServerName" entry in /etc/cups/client.conf:
global string client_conf_server_name = "";
global boolean client_only = false;

global boolean DetermineClientOnly()
{ // Determine the 'ServerName' value in /etc/cups/client.conf:
  if( ExecuteBashCommand( yast_bin_dir + "cups_client_only" ) )
  { client_conf_server_name = result["stdout"]:"";
    if( "" != client_conf_server_name
        && "localhost" != client_conf_server_name
        && "127.0.0.1" != client_conf_server_name )
    { // Note that even 'localhost' or '127.0.0.1' is a valid ServerName value
      // which is used to force client tools (e.g. lpadmin, lpinfo, lpstat)
      // to ask the local cupsd via the IPP port on localhost (127.0.0.1:631)
      // and not via the domain socket (/var/run/cups/cups.sock) because
      // the latter failed in the past for certain third-party clients (e.g. Java).
      // If the ServerName value in /etc/cups/client.conf is 'localhost'
      // it is actually no client-only config because the local cupsd is used.
      client_only = true;
    }
    else
    { client_only = false;
    }
  }
  else
  { client_conf_server_name = "";
    client_only = false;
  }
  // Ignore when it fails:
  return true;
}

// By default there is "Browsing On" in /etc/cups/cupsd.conf
// which is even the fallback if there is no "Browsing" entry at all
// or when the "Browsing" entry is deactivated by a leading '#' character.
// Therefore browsing_on is only false if "Browsing Off" or "Browsing No"
// is explicitely set in /etc/cups/cupsd.conf.
global boolean browsing_on = true;

global boolean DetermineBrowsing()
{ // Determine the 'Browsing [ On | Off ]' value in /etc/cups/cupsd.conf:
  if( ExecuteBashCommand( yast_bin_dir + "modify_cupsd_conf Browsing" ) )
  { string browsing = tolower( result["stdout"]:"On" );
    if( "off" == browsing || "no" == browsing )
    { browsing_on = false;
    }
    else
    { browsing_on = true;
    }
  }
  // Ignore when it fails:
  return true;
}

// By default there is "BrowseAllow all" in /etc/cups/cupsd.conf
// which is even the fallback if there is no "BrowseAllow" entry at all
// or when the "BrowseAllow" entries are deactivated by a leading '#' character.
// Multiple BrowseAllow lines are allowed, e.g.:
//   BrowseAllow from @LOCAL
//   BrowseAllow from 192.168.200.1
//   BrowseAllow from 192.168.100.0/255.255.255.0
// so that each BrowseAllow line value is stored as one string
// in the cupsd_conf_browse_allow list of strings:
global list< string > cupsd_conf_browse_allow = [ "all" ];

global boolean DetermineBrowseAllow()
{  // Determine the 'BrowseAllow [ all | none | @LOCAL | IP-address[/netmask] ]' values in /etc/cups/cupsd.conf:
  if( ExecuteBashCommand( yast_bin_dir + "modify_cupsd_conf BrowseAllow" ) )
  { // The command outputs a line where multiple BrowseAllow values are separated by space
    // but possible duplicate BrowseAllow values are not removed in the command output:
    cupsd_conf_browse_allow = toset( splitstring( Printerlib::result["stdout"]:"all", " " ) );
  }
  else
  { cupsd_conf_browse_allow = [ "all" ];
  }
  // Ignore when it fails:
  return true;
}

global map<string, any> operation_policy = $[];

global map<string, any> cups_autoconfig = $[];

global void Read()
{ // Determine the 'Browsing [ On | Off ]' value in /etc/cups/cupsd.conf and ignore when it fails:
  DetermineBrowsing();
  // Determine the 'BrowseAllow [ all | none | @LOCAL | IP-address[/netmask] ]'
  // values in /etc/cups/cupsd.conf and ignore when it fails:
  DetermineBrowseAllow();
  // Determine the 'ServerName' value in /etc/cups/client.conf and ignore when it fails:
  DetermineClientOnly();
  // Read cups-autoconfiguration settings:
  cups_autoconfig = (map<string, any>)SCR::Read(.etc.cups-auto.all);
  y2internal("read cups-auto %1", cups_autoconfig);
}

global void Write()
{ // Write cups-autoconfiguration settings:
  y2milestone("Writing cups-autoconfig.conf\n%1", cups_autoconfig);
  SCR::Write(.etc.cups-auto.all, cups_autoconfig);
}

}

