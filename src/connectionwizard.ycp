/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:        include/printer/connectionwizard.ycp
 * Package:     Configuration of printer
 * Summary:     Connection Wizard
 * Authors:     Michal Zugec <mzugec@suse.de>
 *              Johannes Meixner <jsmeix@suse.de>
 *
 * $Id: connectionwizard.ycp 27914 2006-02-13 14:32:08Z locilka $
 */

{

textdomain "printer";

import "Label";
import "Printer";
import "Printerlib";
import "Popup";
import "Wizard";

include "printer/helps.ycp";

string connection_uri="";
string connection_model="";
list< string > manufacturers_for_using_driver = prepend( add( Printer::known_manufacturers, "Raw Queue" ), "" );
list< string > manufacturers_for_raw_queue = prepend( Printer::known_manufacturers, "Raw Queue" );

string getCurrentDeviceURI()
{ if( "" != Printer::connections[Printer::selected_connections_index,"uri"]:"")
  { return Printer::connections[Printer::selected_connections_index,"uri"]:"";
  }
  return Printer::queues[Printer::selected_queues_index,"uri"]:"";
}

term getContentFromCurrentModel()
{ term content = nil;
  string current_model_info = Printer::connections[Printer::selected_connections_index,"model"]:"";
  if( "" == current_model_info
      || "unknown" == tolower( current_model_info )
    )
  { current_model_info = Printer::queues[Printer::selected_queues_index,"description"]:"";
    if( "" != current_model_info
        && "unknown" != tolower( current_model_info )
      )
    { list <string> description_words = splitstring( current_model_info, " " );
      if( size( description_words ) > 2 )
      { current_model_info = description_words[0]:"" + " "
                             + description_words[1]:"" + " "
                             + description_words[2]:"";
      }
      if( size( description_words ) == 2 )
      { current_model_info = description_words[0]:"" + " "
                             + description_words[1]:"";
      }
      if( size( description_words ) == 1 )
      { current_model_info = description_words[0]:"";
      }
    }
  }
  if( "" != current_model_info
      && "unknown" != tolower( current_model_info )
    )
  { content = `Left
              ( `ComboBox
                ( `id("manufacturers_combo_box"),
                  `opt(`editable),
                  // Header for a ComboBox to keep the printer model or select another manufacturer:
                  _("Keep the printer model or select another &manufacturer"),
                  prepend( add( Printer::known_manufacturers, "Raw Queue" ), current_model_info )
                )
              );
  }
  else
  { content = `Left
              ( `ComboBox
                ( `id("manufacturers_combo_box"),
                  `opt(`editable),
                  // Header for a ComboBox to select the printer manufacturer:
                  _("Select the printer &manufacturer"),
                  manufacturers_for_using_driver
                )
              );
  }
  return content;
}

term getContentFromBackend( string backend )
{ list items = [];
  backend = sformat( "%1:/", backend );
  foreach( term row,
           (list<term>)Printer::ConnectionItems( "" ),
           { if( backend == substring( row[2]:"", 0, size(backend) ) )
             { items = add( items, row );
             }
           }
         );
  term content = `VBox
                 ( `Table
                   ( `id(`connection_selection),
                     // By default there is no UserInput()
                     // if only something was selected in the Table
                     // (without clicking additionally a button)
                     // but the notify and immediate options
                     // forces UserInput() in this case:
                     `opt(`notify, `immediate, `keepSorting),
                     // Headers of a Table with a list of printer connections:
                     `header
                     ( // Header of a Table column with a list of printer connections.
                       // Printer model name:
                       _("Model"),
                       // Header of a Table column with a list of printer connections.
                       // Connection of the printer (e.g. via USB or via parallel port):
                       _("Connection"),
                       // Header of a Table column with a list of printer connections.
                       // Additional description of the printer or its particular connection:
                       _("Description")
                     ),
                     items
                   )
                 );
  return content;
}

term getNetworkContent( list<string>text )
{ if( size(text) != 3 )
  { y2error( "To create content for Network dialog it needs 3 strings : %1", text );
    return nil;
  }
  term content = `VBox
                 ( `Left
                   ( `HBox
                     ( `ComboBox
                       ( `id(`hostname),
                         `opt(`editable),
                         // TRANSLATORS: Text entry to fill IP or hostname of remote server
                         _("&IP Address or Host Name")
                       ),
                       `MenuButton
                       ( // TRANSLATORS: Label for menu to search for remote servers
                         _("Look Up"),
                         [ `item( `id(`scan), text[0]:"" ),
                           // TRANSLATORS: Button to search for remote servers
                           `item( `id(`scan_all), _("Look Up for All Hosts") )
                         ]
                       )
                     )
                   ),
                   `Left
                   ( `InputField( `id(`port_or_queue), text[1]:"", text[2]:"" )
                   ),
                   `Left
                   ( // TRANSLATORS: Button to test remote printer machine
                     `PushButton( `id(`test), _("&Test Connection") )
                   )
                 );
  return content;
}

void changeSettingsDialog( symbol selected )
{ term content = nil;
  term connection_content = nil;
  term model_content = nil;
  term model_for_using_driver_content = `Left
                                        ( `ComboBox
                                          ( `id("manufacturers_combo_box"),
                                            `opt(`editable),
                                            // Header for a ComboBox to select the printer manufacturer:
                                            _("Select the printer &manufacturer"),
                                            manufacturers_for_using_driver
                                          )
                                        );
  term model_for_raw_queue_content = `Left
                                     ( `ComboBox
                                       ( `id("manufacturers_combo_box"),
                                         `opt(`editable),
                                         // Header for a ComboBox to optionally select the printer manufacturer.
                                         // Do not change or translate "raw", it is a technical term
                                         // when no driver is used for a print queue.
                                         _("You may select a printer &manufacturer if no 'raw queue' should be set up"),
                                         manufacturers_for_raw_queue
                                       )
                                     );
  switch(selected)
  { // directly connected
    case(`parallel):
          content = getContentFromBackend("parallel");
          break;
    case(`usb):
          content = getContentFromBackend("usb");
          break;
    case(`hplip):
          if( ! Printerlib::TestAndInstallPackage( "hplip", "installed" ) )
          // Only a notification but no installation of HPLIP in the Connection Wizard.
          // Installing the package hplip can pull in tons of required packages
          // because the hplip package does not only provide the 'hp' backend but is a
          // full featured multifunction solution with GUI for HP printers and all-in-one devices.
          // HPLIP supports printing, scanning, faxing, photo card access, and device management.
          // Additionally installing hplip can become very complicated (see driveradd.ycp).
          // Therefore the Connection Wizard is not bloated with installing HPLIP.
          { Popup::Message( // Popup::Message when the user had selected "HP Devices (HPLIP)"
                            // in the Connection Wizard but the RPM package hplip is not installed:
                            _("To access a HP device via the 'hp' backend,\nthe RPM package hplip must be installed.")
                          );
            content = `VBox
                      ( `Left
                        ( `Label
                          ( _("The RPM package hplip is not installed.") )
                        )
                      );
            break;
          }
          content = getContentFromBackend("hp");
          break;
    case(`serial):
          content = `VBox
                    ( `Left
                      ( `ComboBox
                        ( `id(`serial_device_node),
                          // This ComboBox is editable because there could be
                          // any kind of serial device node name "/dev/whatever":
                          `opt(`editable),
                          // Label for an editable ComboBox where
                          // a serial device node (e.g. /dev/ttyS0 or /dev/ttyS1)
                          // can be selected or entered:
                          _("&Serial device"),
                          [ // Have nothing preselected to be on the safe side because
                            // the CUPS serial backend may blindly write to the device,
                            // (see backend/serial.c in the CUPS 1.3.9 sources):
                            `item( `id(""), "", true ),
                            `item( `id("/dev/ttyS0"), "/dev/ttyS0" ),
                            `item( `id("/dev/ttyS1"), "/dev/ttyS1" ),
                            `item( `id("/dev/ttyS2"), "/dev/ttyS2" ),
                            `item( `id("/dev/ttyS3"), "/dev/ttyS3" ),
                            `item( `id("/dev/ttyS4"), "/dev/ttyS4" ),
                            `item( `id("/dev/ttyS5"), "/dev/ttyS5" ),
                            `item( `id("/dev/ttyS6"), "/dev/ttyS6" ),
                            `item( `id("/dev/ttyS7"), "/dev/ttyS7" )
                          ]
                        )
                      ),
                      `Left
                      ( `ComboBox
                        ( `id(`serial_baud_rate),
                          // The backend/serial.c in the CUPS 1.3.9 sources
                          // supports only the preset values below.
                          // Nevertheless this ComboBox is editable to be future-proof:
                          `opt(`editable),
                          // Label for an editable ComboBox where
                          // the baud rate for a serial device
                          // can be selected or entered:
                          _("&Baud rate"),
                          // The preset values are from backend/serial.c
                          // in the CUPS 1.3.9 sources:
                          [ // Have nothing preselected to be on the safe side because the baud rate
                            // may have to be exactly what is set in the printer (e.g. via DIP switches):
                            `item( `id(""), "", true ),
                            `item( `id("1200"), "1200" ),
                            `item( `id("2400"), "2400" ),
                            `item( `id("4800"), "4800" ),
                            `item( `id("9600"), "9600" ),
                            `item( `id("19200"), "19200" ),
                            `item( `id("38400"), "38400" ),
                            `item( `id("57600"), "57600" ),
                            `item( `id("115200"), "115200" ),
                            `item( `id("230400"), "230400" )
                          ]
                        )
                      ),
                      `Left
                      ( `ComboBox
                        ( `id(`serial_data_bits),
                          // The backend/serial.c in the CUPS 1.3.9 sources
                          // supports only the preset values below (7 and 8).
                          // Nevertheless this ComboBox is editable to be future-proof
                          // because according to http://en.wikipedia.org/wiki/Serial_port
                          // a serial port might also have 5, 6, or 9 data bits.
                          `opt(`editable),
                          // Label for an editable ComboBox where
                          // the number of data bits for a serial device
                          // can be selected or entered:
                          _("&Data bits"),
                          // The preset values are from backend/serial.c
                          // in the CUPS 1.3.9 sources:
                          [ `item( `id(""), "", true ),
                            `item( `id("7"), "7" ),
                            `item( `id("8"), "8" )
                          ]
                        )
                      ),
                      `Left
                      ( `ComboBox
                        ( `id(`serial_parity),
                          // The backend/serial.c in the CUPS 1.3.9 sources
                          // supports only the preset values below.
                          // Nevertheless this ComboBox is editable to be future-proof:
                          `opt(`editable),
                          // Label for an editable ComboBox where
                          // the parity checking for a serial device
                          // can be selected or entered:
                          _("&Parity checking"),
                          // The preset values are from backend/serial.c
                          // in the CUPS 1.3.9 sources:
                          [ `item( `id(""), "", true ),
                            `item( `id("even"), "even" ),
                            `item( `id("odd"), "odd" ),
                            `item( `id("none"), "none" ),
                            `item( `id("space"), "space" ),
                            `item( `id("mark"), "mark" )
                          ]
                        )
                      ),
                      `Left
                      ( `ComboBox
                        ( `id(`serial_flow_control),
                          // The backend/serial.c in the CUPS 1.3.9 sources
                          // supports only the preset values below.
                          // Nevertheless this ComboBox is editable to be future-proof
                          // because according to http://en.wikipedia.org/wiki/Flow_control
                          // a serial port might also have another kind of flow control.
                          `opt(`editable),
                          // Label for an editable ComboBox where
                          // the flow control for a serial device
                          // can be selected or entered:
                          _("&Flow control"),
                          // The preset values are from backend/serial.c
                          // in the CUPS 1.3.9 sources:
                          [ `item( `id(""), "", true ),
                            `item( `id("none"), "none" ),
                            `item( `id("soft"), "XON/XOFF (software)" ),
                            `item( `id("hard"), "RTS/CTS (hardware)" ),
                            `item( `id("dtrdsr"), "DTR/DSR (hardware)" )
                          ]
                        )
                      ),
                      `Left
                      ( `ComboBox
                        ( `id(`serial_stop_bits),
                          // The backend/serial.c in the CUPS 1.3.9 sources
                          // supports only the preset values below.
                          // Nevertheless this ComboBox is editable to be future-proof:
                          `opt(`editable),
                          // Label for an editable ComboBox where
                          // the number of stop bits for a serial device
                          // can be selected or entered:
                          _("S&top bits"),
                          // The preset values are from backend/serial.c
                          // in the CUPS 1.3.9 sources:
                          [ `item( `id(""), "", true ),
                            `item( `id("1"), "1" ),
                            `item( `id("2"), "2" )
                          ]
                        )
                      ),
                      model_for_using_driver_content
                    );
          break;
    case(`bluetooth):
          if( ! Printerlib::TestAndInstallPackage( "bluez-cups", "installed" ) )
          { if( Popup::ContinueCancel( _("To access a bluetooth printer, the RPM package bluez-cups must be installed.") ) )
            { Printerlib::TestAndInstallPackage( "bluez-cups", "install" );
            }
            // The user can also decide during the actual installation not to install it
            // or the installation may have failed for whatever reason
            // so that we test again whether or not it is now actually installed:
            if( ! Printerlib::TestAndInstallPackage( "bluez-cups", "installed" ) )
            { content = `VBox
                        ( `Left
                          ( `Label
                            ( _("The RPM package bluez-cups is not installed.") )
                          )
                        );
              break;
            }
          }
          // Fallback message what the user may run manually when it fails
          // to generate a valid list of bluetooth device IDs:
          string  bluetooth_device_list = _("It seems there are no bluetooth device IDs.\nRun 'hcitool scan' to get the bluetooth device IDs.\nEnter the ID without colons like '1A2B3C4D5E6F'.");
          Popup::ShowFeedback( // No title for a simple busy message:
                               "",
                               // Busy message:
                               // Body of a Popup::ShowFeedback:
                               _("Retrieving bluetooth device IDs...")
                             );
          // The command "hcitool scan" might need very much time or hang up.
          // To kill exactly hcitool there is the workaround via the temporary file because
          // hcitool scan | grep '...' & sleep 10 ; kill -9 $!
          // would kill only grep and
          // ( hcitool scan | grep '...' ) & sleep 10 ; kill -9 $!
          // would kill only the sub shell.
          if( ! Printerlib::ExecuteBashCommand( "hcitool scan >/tmp/hcitool_scan.out & sleep 10 ; kill -9 $! ; grep '..:..:..:..:..:..' /tmp/hcitool_scan.out | tr -s ' ' ; rm -f /tmp/hcitool_scan.out" ) )
          { // Will probably never fail because the final "rm -f ..." should exit successfully in any case:
            Popup::ErrorDetails( // Popup::ErrorDetails message:
                                 _("Failed to get a list of bluetooth device IDs."),
                                 "hcitool scan" + "\n" + Printerlib::result["stderr"]:""
                               );
          }
          else
          { if( "" != Printerlib::result["stdout"]:"" )
            { bluetooth_device_list = Printerlib::result["stdout"]:"";
            }
          }
          Popup::ClearFeedback();
          y2milestone( "bluetooth_device_list '%1'", bluetooth_device_list );
          // Have an empty string preselected to be on the safe side because
          // the bluetooth backend may blindly write to the device:
          list <term> bluetooth_device_id_items = [ `item( `id(""), "", true ) ];
          foreach( string word,
                   splitstring( bluetooth_device_list, " " ),
                   { if( regexpmatch( word, "..:..:..:..:..:..") )
                     { // A bluetooth device ID has the form 1A:2B:3C:4D:5E:6F
                       // but the bluetooth backend needs it without the colons ':'
                       // in its DeviceURI which has the form bluetooth://1A2B3C4D5E6F
                       string hexnumber = filterchars( word, "0123456789ABCDEFabcdef" );
                       if( "" != hexnumber )
                       { bluetooth_device_id_items = add( bluetooth_device_id_items, `item( `id( hexnumber ), hexnumber ) );
                       }
                     }
                   }
                 );
          content = `VBox
                    ( `Left
                      ( `ComboBox
                        ( `id(`bluetooth_device_id),
                          `opt(`editable),
                          // Label for an editable ComboBox where
                          // a bluetooth device ID
                          // can be selected or entered:
                          _("&Bluetooth device ID"),
                          bluetooth_device_id_items
                        )
                      ),
                      `Left
                      ( `Frame
                        ( // TRANSLATORS: Frame label for a list of bluetooth device IDs:
                          _("Currently available bluetooth device IDs"),
                          // The RichText widget is required here to get scroll bars if needed
                          // (a Label cuts the content because it does not provide scroll bars):
                          `RichText( "<pre>" + bluetooth_device_list + "</pre>" )
                        )
                      ),
                      model_for_using_driver_content
                    );
          break;
    case(`scsi):
          // Fallback message what the user may run manually when it fails
          // to generate the current list of SCSI generic device nodes:
          string scsi_device_list = _("It seems there are no SCSI generic devices (/dev/sg...).\nRun 'lsscsi -g' to get a list of SCSI generic devices.");
          if( ! Printerlib::ExecuteBashCommand( "lsscsi -g | tr -s ' ' | cut -s -d ' ' -f 3- | grep '/dev/sg' || echo 'no SCSI generic device found' 1>&2" ) )
          { // Will probably never fail because the final "echo" should exit successfully in any case:
            Popup::ErrorDetails( // Popup::ErrorDetails message:
                                 _("Failed to get a list of SCSI generic devices."),
                                 "lsscsi -g" + "\n" + Printerlib::result["stderr"]:""
                               );
          }
          else
          { if( "" != Printerlib::result["stdout"]:"" )
            { scsi_device_list = Printerlib::result["stdout"]:"";
            }
          }
          y2milestone( "scsi_device_list '%1'", scsi_device_list );
          content = `VBox
                    ( `Left
                      ( `ComboBox
                        ( `id(`scsi_device_node),
                          `opt(`editable),
                          // Label for an editable ComboBox where
                          // a SCSI generic device node (e.g. /dev/sg0 or /dev/sg1)
                          // can be selected or entered:
                          _("&SCSI generic device"),
                          [ // Have nothing preselected to be on the safe side because
                            // the CUPS scsi backend may blindly write to the device,
                            // (see backend/scsi-linux.c in the CUPS 1.3.9 sources):
                            `item( `id(""), "", true ),
                            `item( `id("/dev/sg0"), "/dev/sg0" ),
                            `item( `id("/dev/sg1"), "/dev/sg1" ),
                            `item( `id("/dev/sg2"), "/dev/sg2" ),
                            `item( `id("/dev/sg3"), "/dev/sg3" ),
                            `item( `id("/dev/sg4"), "/dev/sg4" ),
                            `item( `id("/dev/sg5"), "/dev/sg5" ),
                            `item( `id("/dev/sg6"), "/dev/sg6" ),
                            `item( `id("/dev/sg7"), "/dev/sg7" )
                          ]
                        )
                      ),
                      `Left
                      ( `Frame
                        ( // TRANSLATORS: Frame label for a list of SCSI generic devices:
                          _("Currently available SCSI generic devices"),
                          // The RichText widget is required here to get scroll bars if needed
                          // (a Label cuts the content because it does not provide scroll bars):
                          `RichText( "<pre>" + scsi_device_list + "</pre>" )
                        )
                      ),
                      model_for_using_driver_content
                    );
          break;
    // network printer
    case(`tcp):
          connection_content = getNetworkContent( [ // TRANSLATORS: List of input field labels,
                                                    // first for network scan button,
                                                    // second for the TCP port number:
                                                    _("Scan for Direct Socket Servers"),
                                                    _("TCP Port Number"),
                                                    "9100"
                                                  ]
                                                );
          content = `VBox( connection_content, model_for_using_driver_content );
          break;
    case(`lpd):
          connection_content = getNetworkContent( [ // TRANSLATORS: List of input field labels,
                                                    // first for network scan button,
                                                    // second for name of printer queue
                                                    _("Scan for LPD Servers"),
                                                    _("Queue Name (see the printer's manual)"),
                                                    "LPT1"
                                                  ]
                                                );
          content = `VBox( connection_content, model_for_using_driver_content );
          break;
    case(`ipp):
          content = `VBox
                    ( `Left
                      ( `InputField
                        ( `id(`uri),
                          // TRANSLATORS: Input field label
                          _("URI (see the printer's manual)"),
                          "ipp://ip-address:port-number/resource"
                        )
                      ),
                      model_for_using_driver_content
                    );
          break;
    // print via
    case(`smb):
          if( ! Printerlib::TestAndInstallPackage( "samba-client", "installed" ) )
          { if( Popup::ContinueCancel( _("To access a SMB printer share, the RPM package samba-client must be installed.") ) )
            { Printerlib::TestAndInstallPackage( "samba-client", "install" );
            }
            // The user can also decide during the actual installation not to install it
            // or the installation may have failed for whatever reason
            // so that we test again whether or not it is now actually installed:
            if( ! Printerlib::TestAndInstallPackage( "samba-client", "installed" ) )
            { content = `VBox
                        ( `Left
                          ( `Label
                            ( _("The RPM package samba-client is not installed.") )
                          )
                        );
              break;
            }
          }
          content = `VBox
                    ( `Left
                      ( `HBox
                        ( `ComboBox
                          ( `id(`hostname),
                            `opt(`editable),
                            // TRANSLATORS: Text entry for remote server name
                            _("Server (NetBIOS Host Name)")
                          //),
                          //`MenuButton
                          //( // TRANSLATORS: Label for menu to search for remote servers
                          //  _("Look Up"),
                          //  [ `item( `id(`scan), _("Scan for samba printers") ),
                          //    // TRANSLATORS: Buttonto search for remote servers
                          //    `item( `id(`scan_all), _("Look Up for All Hosts") )
                          //  ]
                          )
                        )
                      ),
                      `Left
                      ( `InputField
                        ( `id(`printer),
                          // TRANSLATORS: Text entry for printer name
                          _("Printer (Share Name)")
                        )
                      ),
                      `Left
                      ( `HBox
                        ( `ComboBox
                          ( `id(`domain),
                            `opt(`editable),
                            // TRANSLATORS: Text entry for samba domain
                            _("Workgroup (Domain Name)")
                          //),
                          //PushButton
                          //( `id(`scan_domain),
                          //  _("Scan for Windows Share Domains")
                          //)
                          )
                        )
                      ),
                      `Left
                      ( `Frame
                        ( // TRANSLATORS: Frame label for authentication
                          _("Authenticate As"),
                          `VBox
                          ( `InputField
                            ( `id(`user),
                              // TRANSLATORS: Text entry for username (authentication)
                              _("User")
                            ),
                            `Password
                            ( `id(`pass),
                              // TRANSLATORS: Text entry for password (authentication)
                              _("&Password")
                            )
                          )
                        )
                      ),
                      `Left
                      ( `PushButton
                        ( `id(`test),
                          // TRANSLATORS: Button to test remote printer machine
                          _("&Test Connection")
                        )
                      ),
                      model_for_using_driver_content
                    );
          break;
    case(`lpr):
          connection_content = getNetworkContent( [ // TRANSLATORS: List of input field labels,
                                                    // first for network scan button,
                                                    // second for name of printer queue
                                                    _("Scan for LPD Servers"),
                                                    _("Queue Name"),
                                                    ""
                                                  ]
                                                );
          content = `VBox( connection_content, model_for_raw_queue_content );
          break;
    case(`cups):
          content = `VBox
                    ( `Left
                      ( `HBox
                        ( `ComboBox
                          ( `id(`hostname),
                            `opt(`editable),
                            // TRANSLATORS: Text entry for IP or hostname of remote server
                            _("IP Address or Host Name")
                          ),
                          `MenuButton
                          ( // TRANSLATORS: Label for menu to search for remote servers
                            _("Look Up"),
                            [ `item( `id(`scan), _("Scan for IPP Servers") ),
                              `item( `id(`scan_broadcast), _("Scan for IPP Broadcasts") ),
                              `item( `id(`scan_all), _("Look Up for All Hosts") )
                            ]
                          )
                        )
                      ),
                      `Left
                      ( `InputField( `id(`queue), _("Queue Name") )
                      ),
                      `Left
                      ( `PushButton
                        ( `id(`test),
                          // TRANSLATORS: Button to test remote printer machine
                          _("&Test Connection")
                        )
                      ),
                      model_for_raw_queue_content
                    );
          break;
    case(`ipx):
          if( ! Printerlib::TestAndInstallPackage( "ncpfs", "installed" ) )
          { if( Popup::ContinueCancel( _("To access an IPX print queue, the RPM package ncpfs must be installed.") ) )
            { Printerlib::TestAndInstallPackage( "ncpfs", "install" );
            }
            // The user can also decide during the actual installation not to install it
            // or the installation may have failed for whatever reason
            // so that we test again whether or not it is now actually installed:
            if( ! Printerlib::TestAndInstallPackage( "ncpfs", "installed" ) )
            { content = `VBox
                        ( `Left
                          ( `Label
                            ( _("The RPM package ncpfs is not installed.") )
                          )
                        );
              break;
            }
          }
          content = `VBox
                    ( `Left
                      ( `InputField
                        ( `id(`hostname),
                          // TRANSLATORS: Text entry for IP or hostname of remote server
                          _("IP Address or Host Name")
                        )
                      ),
                      `Left
                      ( `InputField
                        ( `id(`queue),
                          // TRANSLATORS: Text entry for name of remote printer queue
                          _("Queue Name")
                        )
                      ),
                      `Left
                      ( `Frame
                        ( // TRANSLATORS: Frame label for authentication
                          _("Authenticate As"),
                          `VBox
                          ( `InputField
                            ( `id(`user),
                              // TRANSLATORS: Text entry for username (authentication)
                              _("User")
                            ),
                            `Password
                            ( `id(`pass),
                              // TRANSLATORS: Text entry for password (authentication)
                              _("&Password")
                            )
                          )
                        )
                      ),
                      `Left
                      ( `PushButton
                        ( `id(`test),
                          // TRANSLATORS: Button to test remote printer machine
                          _("&Test Connection")
                        )
                      ),
                      model_for_using_driver_content
                    );
          break;
    // special
    case(`uri):
          model_content = getContentFromCurrentModel();
          content = `VBox
                    ( `Left
                      ( `InputField
                        ( `id(`uri),
                          // TRANSLATORS: Text entry for URI (Uniform Resource Identifier)
                          _("URI (Uniform Resource Identifier)"),
                          getCurrentDeviceURI()
                        )
                      ),
                      model_content
                    );
          break;
    case(`pipe):
          if( ! Printerlib::TestAndInstallPackage( "cups-backends", "installed" ) )
          { if( Popup::ContinueCancel( _("To print via 'pipe', the RPM package cups-backends must be installed.") ) )
            { Printerlib::TestAndInstallPackage( "cups-backends", "install" );
            }
            // The user can also decide during the actual installation not to install it
            // or the installation may have failed for whatever reason
            // so that we test again whether or not it is now actually installed:
            if( ! Printerlib::TestAndInstallPackage( "cups-backends", "installed" ) )
            { content = `VBox
                        ( `Left
                          ( `Label
                            ( _("The RPM package cups-backends is not installed.") )
                          )
                        );
              break;
            }
          }
          content = `VBox
                    ( `Left
                      ( `InputField
                        ( `id(`program),
                          // TRANSLATORS: Text entry for program name that will be called via pipe
                          _("Program Name")
                        )
                      ),
                      model_for_raw_queue_content
                    );
          break;
    case(`beh):
          if( ! Printerlib::TestAndInstallPackage( "cups-backends", "installed" ) )
          { if( Popup::ContinueCancel( _("To use 'beh', the RPM package cups-backends must be installed.") ) )
            { Printerlib::TestAndInstallPackage( "cups-backends", "install" );
            }
            // The user can also decide during the actual installation not to install it
            // or the installation may have failed for whatever reason
            // so that we test again whether or not it is now actually installed:
            if( ! Printerlib::TestAndInstallPackage( "cups-backends", "installed" ) )
            { content = `VBox
                        ( `Left
                          ( `Label
                            ( _("The RPM package cups-backends is not installed.") )
                          )
                        );
              break;
            }
          }
          model_content = getContentFromCurrentModel();
          content = `VBox
                    ( `Left
                      ( `InputField
                        ( `id(`queue),
                          // TRANSLATORS: Text entry for device URI (Uniform Resource Identifier)
                          _("Device URI (for which 'beh' should be applied)"),
                          getCurrentDeviceURI()
                        )
                      ),
                      `Left
                      ( `CheckBox
                        ( `id(`beh_do_not_disable),
                          // TRANSLATORS: Check box
                          _("Never Disable the Queue"),
                          true
                        )
                      ),
                      `Left
                      ( `InputField
                        ( `id(`beh_attempts),
                          // TRANSLATORS: Text entry
                          _("Number of Retries ('0' means infinite retries)"),
                          "0"
                        )
                      ),
                      `Left
                      ( `InputField
                        ( `id(`beh_delay),
                          // TRANSLATORS: Text entry
                          _("Delay in Seconds Between Two Retries"),
                          "30"
                        )
                      ),
                      model_content
                    );
          break;
    case(`directly):
    case(`network):
    case(`server):
    case(`special):
          content = `VBox
                    ( `Left
                      ( `Label
                        ( _("Select a specific connection type.") )
                      )
                    );
          break;
    default:
          y2error( "Unknown selected item %1", selected );
  }
  UI::ReplaceWidget( `connection_settings_replace_point, content );
}

any ConnectionWizardDialog()
{ term contents = `VBox
                  ( `HBox
                    ( `HWeight
                      ( 1,
                        `Tree
                        ( `id(`tree_selection),
                          `opt(`notify),
                          // TRANSLATORS: Label for tree widget description
                          _("&Connection Type"),
                          [ `item
                            ( `id(`directly),
                              // TRANSLATORS: Tree widget item
                              _("Directly Connected Device"),
                              true,
                              [ // TRANSLATORS: Tree widget item
                                `item( `id(`parallel), _("Parallel Port") ),
                                // TRANSLATORS: Tree widget item
                                `item(`id(`usb), _("USB Port") ),
                                // TRANSLATORS: Tree widget item
                                `item( `id(`hplip), _("HP Devices (HPLIP)") ),
                                // TRANSLATORS: Tree widget item
                                `item( `id(`serial), _("Serial Port") ),
                                // TRANSLATORS: Tree widget item
                                `item( `id(`bluetooth), _("Bluetooth") ),
                                // TRANSLATORS: Tree widget item
                                `item( `id(`scsi), _("SCSI") )
                              ]
                            ),
                            `item
                            ( `id(`network),
                              // TRANSLATORS: Tree widget item
                              _("Access Network Printer or Printserver Box via"),
                              true,
                              [ // TRANSLATORS: Tree widget item
                                `item( `id(`tcp), _("TCP Port (AppSocket/JetDirect)") ),
                                // TRANSLATORS: Tree widget item
                                `item( `id(`lpd), _("Line Printer Daemon (LPD) Protocol") ),
                                // TRANSLATORS: Tree widget item
                                `item( `id(`ipp), _("Internet Printing Protocol (IPP)") )
                              ]
                            ),
                            `item
                            ( `id(`server),
                              // TRANSLATORS: Tree widget item
                              _("Print Via Print Server Machine"),
                              true,
                              [ // TRANSLATORS: Tree widget item
                                `item( `id(`smb), _("Microsoft Windows/SAMBA (SMB/CIFS)") ),
                                // TRANSLATORS: Tree widget item
                                `item( `id(`lpr), _("Traditional UNIX Server (LPR)") ),
                                // `item( `id(`iprint), _("iPrint (Novell OES)") ),
                                // TRANSLATORS: Tree widget item
                                `item( `id(`cups), _("CUPS Server") ),
                                // TRANSLATORS: Tree widget item
                                `item( `id(`ipx), _("Novell Netware Print Server (IPX)") )
                              ]
                            ),
                            `item
                            ( `id(`special),
                              // TRANSLATORS: Tree widget item
                              _("Special"),
                              true,
                              [ // TRANSLATORS: Tree widget item
                                `item( `id(`uri), _("Specify Arbitrary Device URI") ),
                                // TRANSLATORS: Tree widget item
                                `item( `id(`pipe), _("Send Print Data to Other Program (pipe)") ),
                                // TRANSLATORS: Tree widget item
                                `item( `id(`beh), _("Daisy-chain Backend Error Handler (beh)") )
                              ]
                            )
                          ]
                        )
                      ),
                      `HWeight
                      ( 1,
                        `VBox
                        ( `VStretch(),
                          `Frame
                          ( // TRANSLATORS: Connection details widget
                            _("Connection Settings"),
                            `ReplacePoint( `id(`connection_settings_replace_point),
                                           `VBox
                                           ( `Left
                                             ( `Label
                                               ( _("Select a specific connection type.") )
                                             )
                                           )
                                         )
                          ),
                          `VStretch()
                        )
                      )
                    )
                  );
  // According to http://en.opensuse.org/YaST/Style_Guide#Single_Configuration.2FOverview.2FEdit_Dialog
  // there is no longer a "abort" functionality which exits the whole module.
  // Instead this button is now named "Cancel" and its functionality is
  // to go back to the Overview dialog (i.e. what the "back" button would do)
  // because it reads "Cancel - Closes the window and returns to the overview."
  // In this case the "overview" is not the actual Overview dialog but the dialog
  // from which this DriverOptionsDialog was called i.e. BasicModifyDialog.
  // Therefore the button with the "abort" functionality is not shown at all
  // and the button with the "back" functionality is named "Cancel".
  // According to http://en.opensuse.org/YaST/Style_Guide#Single_Configuration.2FOverview.2FEdit_Dialog
  // the "finish" button in a single (step) configuration dialog must now be named "OK".
  Wizard::SetContentsButtons( // TRANSLATORS: Connection wizard header
                              _("Connection Wizard"),
                              contents,
                              HELPS["connection_wizard_dialog"]:"",
                              // Set a new label for the "back" button, see the comment above:
                              Label::CancelButton(),
                              // Set a new label for the "next" button, see the comment above:
                              Label::OKButton()
                            );
  Wizard::HideAbortButton();

boolean validateSettingsDialog( symbol type )
{ boolean valid=false;
  connection_uri="";
  connection_model="";
  switch(type)
  { case(`parallel):
    case(`usb):
    case(`hplip):
          integer selected_connection_index = (integer)UI::QueryWidget( `id(`connection_selection), `CurrentItem );
          if( nil == selected_connection_index )
          { Popup::AnyMessage( // Header of a Popup::AnyMessage when no connection was selected:
                               _("No Connection Selected"),
                               // Body of a Popup::AnyMessage when no connection was selected:
                               _("Select a connection.")
                             );
            break;
          }
          connection_uri = Printer::connections[selected_connection_index,"uri"]:"";
          connection_model = Printer::connections[selected_connection_index,"model"]:"Unknown";
          if( "" != connection_uri )
          { valid = true;
          }
          break;
    case(`serial):
          string serial_device_node = (string)UI::QueryWidget( `serial_device_node, `Value );
          string serial_baud_rate = (string)UI::QueryWidget( `serial_baud_rate, `Value );
          string serial_data_bits = (string)UI::QueryWidget( `serial_data_bits, `Value );
          string serial_parity = (string)UI::QueryWidget( `serial_parity, `Value );
          string serial_flow_control = (string)UI::QueryWidget( `serial_flow_control, `Value );
          string serial_stop_bits = (string)UI::QueryWidget( `serial_stop_bits, `Value );
          if( size( serial_device_node ) == 0
              || size( serial_baud_rate ) == 0
            )
          { Popup::Error( _("Serial device and baud rate could not be empty.") );
          }
          else
          { if( "space" == serial_parity && "7" != serial_data_bits )
            { Popup::Error( _("The 'space' parity checking is only supported with 7 data bits.") );
            }
            else
            { if( "mark" == serial_parity && "7" != serial_data_bits && "1" != serial_stop_bits )
              { Popup::Error( _("The 'mark' parity checking is only supported with 7 data bits and 1 stop bit.") );
              }
              else
              { connection_uri = "serial:" + serial_device_node + "?baud=" + serial_baud_rate;
                if( size( serial_data_bits ) > 0 )
                { connection_uri = connection_uri + "+bits=" + serial_data_bits;
                }
                if( size( serial_parity ) > 0 )
                { connection_uri = connection_uri + "+parity=" + serial_parity;
                }
                if( size( serial_flow_control ) > 0 )
                { connection_uri = connection_uri + "+flow=" + serial_flow_control;
                }
                if( size( serial_stop_bits ) > 0 )
                { connection_uri = connection_uri + "+stop=" + serial_stop_bits;
                }
                valid = true;
              }
            }
          }
          if( valid )
          { connection_model = (string)UI::QueryWidget( `id("manufacturers_combo_box"), `Value );
            if( "" == connection_model )
            { valid = false;
              Popup::Error( _("Select a manufacturer.") );
            }
          }
          break;
    case(`bluetooth):
          string bluetooth_device_id = (string)UI::QueryWidget( `bluetooth_device_id, `Value );
          if( size( bluetooth_device_id ) == 0 )
          { Popup::Error( _("Bluetooth device ID could not be empty.") );
          }
          else
          { connection_uri = "bluetooth://" + bluetooth_device_id;
            valid = true;
          }
          if( valid )
          { connection_model = (string)UI::QueryWidget( `id("manufacturers_combo_box"), `Value );
            if( "" == connection_model )
            { valid = false;
              Popup::Error( _("Select a manufacturer.") );
            }
          }
          break;
    case(`scsi):
          string scsi_device_node = (string)UI::QueryWidget( `scsi_device_node, `Value );
          if( size( scsi_device_node ) == 0 )
          { Popup::Error( _("SCSI generic device could not be empty.") );
          }
          else
          { connection_uri = "scsi:" + scsi_device_node;
            valid = true;
          }
          if( valid )
          { connection_model = (string)UI::QueryWidget( `id("manufacturers_combo_box"), `Value );
            if( "" == connection_model )
            { valid = false;
              Popup::Error( _("Select a manufacturer.") );
            }
          }
          break;
    case(`uri):
          connection_uri = (string)UI::QueryWidget( `uri, `Value );
          if( size( connection_uri ) > 0 )
          { valid = true;
          }
          else
          { Popup::Error( _("URI could not be empty.") );
          }
          if( valid )
          { connection_model = (string)UI::QueryWidget( `id("manufacturers_combo_box"), `Value );
            if( "" == connection_model )
            { valid = false;
              Popup::Error( _("Select a manufacturer.") );
            }
          }
          break;
    case(`ipp):
          connection_uri = (string)UI::QueryWidget( `uri, `Value );
          if( size( connection_uri ) > 0 )
          { valid = true;
          }
          else
          { Popup::Error( _("URI could not be empty.") );
          }
          if( valid )
          { connection_model = (string)UI::QueryWidget( `id("manufacturers_combo_box"), `Value );
            if( "" == connection_model )
            { valid = false;
              Popup::Error( _("Select a manufacturer.") );
            }
          }
          break;
    case(`smb):
          map<string, any> smb = $[ "hostname" : UI::QueryWidget( `hostname, `Value ),
                                    "printer" : UI::QueryWidget( `printer, `Value ),
                                    "domain" : UI::QueryWidget( `domain, `Value ),
                                    "user" : UI::QueryWidget( `user, `Value ),
                                    "pass" : UI::QueryWidget( `pass, `Value )
                                  ];
          if( size( smb["hostname"]:"" ) == 0
              || size( smb["printer"]:"" ) == 0
            )
          { Popup::Error( _("Servername and printer could not be empty.") );
          }
          else
          { if( ( size( smb["user"]:"" ) > 0 && size( smb["pass"]:"" ) == 0 )
                || ( size( smb["user"]:"" ) == 0 && size( smb["pass"]:"" ) > 0 )
              )
            { Popup::Error( _("Both user and password must be specified.") );
            }
            else
            { connection_uri = "smb://";
              if( size( smb["user"]:"" ) > 0
                  && size( smb["pass"]:"" ) > 0
                )
              { connection_uri = sformat( "%1%2:%3@",
                                          connection_uri,
                                          smb["user"]:"",
                                          smb["pass"]:""
                                        );
              }
              if( size( smb["domain"]:"" ) > 0 )
              { connection_uri = sformat( "%1%2/",
                                          connection_uri,
                                          smb["domain"]:""
                                        );
              }
              connection_uri = sformat( "%1%2/%3",
                                        connection_uri,
                                        smb["hostname"]:"",
                                        smb["printer"]:""
                                      );
              valid = true;
            }
          }
          if( valid )
          { connection_model = (string)UI::QueryWidget( `id("manufacturers_combo_box"), `Value );
            if( "" == connection_model )
            { valid = false;
              Popup::Error( _("Select a manufacturer.") );
            }
          }
          break;
    case(`tcp):
          map<string, any> tcp = $[ "hostname" : UI::QueryWidget( `hostname, `Value ),
                                    "port" : UI::QueryWidget( `port_or_queue, `Value )
                                  ];
          if( size( tcp["hostname"]:"" ) > 0
              && size( tcp["port"]:"" ) > 0
            )
          { connection_uri = sformat( "socket://%1:%2", tcp["hostname"]:"", tcp["port"]:"" );
            valid = true;
          }
          else
          { Popup::Error( _("Servername and port could not be empty.") );
          }
          if( valid )
          { connection_model = (string)UI::QueryWidget( `id("manufacturers_combo_box"), `Value );
            if( "" == connection_model )
            { valid = false;
              Popup::Error( _("Select a manufacturer.") );
            }
          }
          break;
    case(`lpd):
          map<string, any> lpd = $[ "hostname" : UI::QueryWidget( `hostname, `Value ),
                                    "queue" : UI::QueryWidget( `port_or_queue, `Value )
                                  ];
          if( size( lpd["hostname"]:"" ) > 0
              && size( lpd["queue"]:"" ) > 0
            )
          { connection_uri = sformat( "lpd://%1/%2", lpd["hostname"]:"", lpd["queue"]:"" );
            valid=true;
          }
          else
          { Popup::Error( _("Servername and queue name could not be empty.") );
          }
          if( valid )
          { connection_model = (string)UI::QueryWidget( `id("manufacturers_combo_box"), `Value );
            if( "" == connection_model )
            { valid = false;
              Popup::Error( _("Select a manufacturer.") );
            }
          }
          break;
    case(`lpr):
          map<string, any> lpr = $[ "hostname" : UI::QueryWidget( `hostname, `Value ),
                                    "queue" : UI::QueryWidget( `port_or_queue, `Value )
                                  ];
          if( size( lpr["hostname"]:"" ) > 0
              && size( lpr["queue"]:"" ) > 0
            )
          { connection_uri = sformat( "lpd://%1/%2", lpr["hostname"]:"", lpr["queue"]:"" );
            valid=true;
          }
          else
          { Popup::Error( _("Servername and queue name could not be empty.") );
          }
          if( valid )
          { connection_model = (string)UI::QueryWidget( `id("manufacturers_combo_box"), `Value );
            if( "" == connection_model )
            { valid = false;
              Popup::Error( _("Select a manufacturer.") );
            }
          }
          break;
    case(`cups):
          map<string, any> cups = $[ "hostname" : UI::QueryWidget( `hostname, `Value ),
                                     "queue" : UI::QueryWidget( `queue, `Value )
                                   ];
          if( size( cups["hostname"]:"" ) > 0
              && size( cups["queue"]:"" ) > 0
            )
          { connection_uri = sformat( "ipp://%1/printers/%2", cups["hostname"]:"", cups["queue"]:"" );
            valid=true;
          }
          else
          { Popup::Error( _("Servername and queue name could not be empty.") );
          }
          if( valid )
          { connection_model = (string)UI::QueryWidget( `id("manufacturers_combo_box"), `Value );
            if( "" == connection_model )
            { valid = false;
              Popup::Error( _("Select a manufacturer.") );
            }
          }
          break;
    case(`ipx):
          map<string, any> ipx = $[ "hostname" : UI::QueryWidget( `hostname, `Value ),
                                    "queue" : UI::QueryWidget( `queue, `Value ),
                                    "user" : UI::QueryWidget( `user, `Value ),
                                    "pass" : UI::QueryWidget( `pass, `Value )
                                  ];
          y2internal( "novell ipx map %1", ipx );
          if( size( ipx["hostname"]:"" ) == 0
              || size( ipx["queue"]:"" ) == 0
            )
          { Popup::Error( _("Servername and queue name could not be empty.") );
          }
          else
          { connection_uri = "novell://";
            if( size( ipx["user"]:"" ) > 0
                && size( ipx["pass"]:"" ) > 0
              )
            { connection_uri = sformat( "%1%2:%3@", connection_uri, ipx["user"]:"", ipx["pass"]:"" );
            }
            connection_uri = sformat("%1%2/%3", connection_uri, ipx["hostname"]:"", ipx["queue"]:"" );
            valid=true;
          }
          if( valid )
          { connection_model = (string)UI::QueryWidget( `id("manufacturers_combo_box"), `Value );
            if( "" == connection_model )
            { valid=false;
              Popup::Error( _("Select a manufacturer.") );
            }
          }
          break;
    case(`beh):
          map<string, any> beh = $[ "uri" : UI::QueryWidget( `queue, `Value ),
                                    "do_not_disable" : UI::QueryWidget( `beh_do_not_disable, `Value ),
                                    "attempts" : UI::QueryWidget( `beh_attempts, `Value ),
                                    "delay" : UI::QueryWidget( `beh_delay, `Value )
                                  ];
          y2internal( "beh map %1", beh );
          if( size( beh["uri"]:"") == 0
              || size( beh["attempts"]:"" ) == 0
              || size( beh["delay"]:"" ) == 0
            )
          { Popup::Error( _("Device URI, number of retries, and delay could not be empty." ) );
          }
          else
          { connection_uri = sformat( "beh:/%1/%2/%3/%4",
                                      ( beh["dont_disable"]:false ? "1" : "0" ),
                                      beh["attempts"]:"0",
                                      beh["delay"]:"30",
                                      beh["uri"]:""
                                    );
            valid = true;
          }
          if( valid )
          { connection_model = (string)UI::QueryWidget( `id("manufacturers_combo_box"), `Value );
            if( "" == connection_model )
            { valid = false;
              Popup::Error( _("Select a manufacturer.") );
            }
          }
          break;
    case(`pipe):
          string pipe = (string)UI::QueryWidget( `program, `Value );
          if( size( pipe ) > 0 )
          { connection_uri = sformat( "pipe:/%1", pipe );
            valid = true;
          }
          else
          { Popup::Error( _("Could not be empty.") );
          }
          if( valid )
          { connection_model = (string)UI::QueryWidget( `id("manufacturers_combo_box"), `Value );
            if( "" == connection_model )
            { valid = false;
              Popup::Error( _("Select a manufacturer.") );
            }
          }
          break;
    default:
          y2warning("Unknown type %1", type);
          break;
  }
  if( ! valid )
  { connection_uri="";
    connection_model="";
  }
  return valid;
}

void scanForServers( symbol selected, boolean all )
{ list<string> hosts = [];
  if( all )
  { hosts = (list<string>)SCR::Read(.net.hostnames);
  }
  else
  { switch(selected)
    { case(`tcp):
            hosts = (list<string>)SCR::Read (.net.hostnames, 9100);
            break;
      case(`smb):
            hosts = (list<string>)SCR::Read (.net.hostnames.samba);
            break;
      case(`lpr):
      case(`lpd):
            hosts = (list<string>)SCR::Read (.net.hostnames, 515);
            break;
      case(`cups):
      case(`ipp):
            hosts = (list<string>)SCR::Read (.net.hostnames, 631);
/*
            hosts = (list<string>)filter (string h, hosts, ``{
                list queues = (list<string>)SCR::Read (.cups.remote, h);
                return size (queues) > 0;
            });
*/
            break;
      default:
            y2warning( "Unknown value: %1", selected );
    }
  }
  UI::ChangeWidget( `hostname, `Items, hosts );
  y2milestone( "scanForServers selected:%1", selected );
  y2milestone( "hosts %1", hosts );
}

boolean testQueue( symbol selected )
{ string test_command = "";
  string timeout = "5";
  string host = "";
  string port = "";
  string queue = "";
  string workgroup = "";
  string user = "";
  string password = "";
  switch(selected)
  { case(`tcp):
          host = (string)UI::QueryWidget( `hostname, `Value );
          port = (string)UI::QueryWidget( `port_or_queue, `Value );
          test_command = sformat( "%1test_remote_socket \"%2\" \"%3\" %4",
                                  Printerlib::yast_bin_dir,
                                  host,
                                  port,
                                  timeout
                                );
          if( ! Printerlib::ExecuteBashCommand( test_command) )
          { Popup::ErrorDetails( sformat( // Message of a Popup::ErrorDetails
                                          // where %1 will be replaced by the port number
                                          // and %2 will be replaced by the host name:
                                          _("Access test failed for port '%1' on host '%2'."),
                                          port,
                                          host
                                        ),
                                 Printerlib::result["stderr"]:"" + "\n" + Printerlib::result["stdout"]:""
                               );
            return false;
          }
          break;
    case(`lpd):
    case(`lpr):
          host = (string)UI::QueryWidget( `hostname, `Value );
          queue = (string)UI::QueryWidget( `port_or_queue, `Value );
          port = "515";
          test_command = sformat( "%1test_remote_lpd \"%2\" \"%3\" %4",
                                  Printerlib::yast_bin_dir,
                                  host,
                                  queue,
                                  timeout
                                );
          if( ! Printerlib::ExecuteBashCommand( test_command) )
          { Popup::ErrorDetails( sformat( // Message of a Popup::ErrorDetails
                                          // where %1 will be replaced by the queue name
                                          // and %2 will be replaced by the host name:
                                          _("Access test failed for queue '%1' on host '%2'."),
                                          queue,
                                          host
                                        ),
                                 Printerlib::result["stderr"]:"" + "\n" + Printerlib::result["stdout"]:""
                               );
            return false;
          }
          break;
    case(`cups):
          host = (string)UI::QueryWidget( `hostname, `Value );
          queue = (string)UI::QueryWidget( `queue, `Value );
          test_command = sformat( "%1test_remote_ipp \"%2\" \"%3\" %4",
                                  Printerlib::yast_bin_dir,
                                  host,
                                  queue,
                                  timeout
                                );
          if( ! Printerlib::ExecuteBashCommand( test_command) )
          { Popup::ErrorDetails( sformat( // Message of a Popup::ErrorDetails
                                          // where %1 will be replaced by the queue name
                                          // and %2 will be replaced by the host name:
                                          _("Access test failed for queue '%1' on host '%2'."),
                                          queue,
                                          host
                                        ),
                                 Printerlib::result["stderr"]:"" + "\n" + Printerlib::result["stdout"]:""
                               );
            return false;
          }
          break;
    case(`smb):
          host = (string)UI::QueryWidget( `hostname, `Value );
          queue = (string)UI::QueryWidget( `printer, `Value );
          workgroup = (string)UI::QueryWidget( `domain, `Value );
          user = (string)UI::QueryWidget( `user, `Value );
          password = (string)UI::QueryWidget( `pass, `Value );
          test_command = sformat( "%1test_remote_smb \"%2\" \"%3\" \"%4\" \"%5\" \"%6\" %7",
                                  Printerlib::yast_bin_dir,
                                  workgroup,
                                  host,
                                  queue,
                                  user,
                                  password,
                                  timeout
                                );
          if( ! Printerlib::ExecuteBashCommand( test_command) )
          { Popup::ErrorDetails( sformat( // Message of a Popup::ErrorDetails
                                          // where %1 will be replaced by the SMB share name
                                          // and %2 will be replaced by the host name:
                                          _("Access test failed for share '%1' on host '%2'."),
                                          queue,
                                          host
                                        ),
                                 Printerlib::result["stderr"]:"" + "\n" + Printerlib::result["stdout"]:""
                               );
            return false;
          }
          break;
    case(`ipx):
          host = (string)UI::QueryWidget( `hostname, `Value );
          queue = (string)UI::QueryWidget( `queue, `Value );
          user = (string)UI::QueryWidget( `user, `Value );
          password = (string)UI::QueryWidget( `pass, `Value );
          test_command = sformat( "%1test_remote_novell \"%2\" \"%3\" \"%4\" \"%5\" %6",
                                  Printerlib::yast_bin_dir,
                                  host,
                                  queue,
                                  user,
                                  password,
                                  timeout
                                );
          if( ! Printerlib::ExecuteBashCommand( test_command) )
          { Popup::ErrorDetails( sformat( // Message of a Popup::ErrorDetails
                                          // where %1 will be replaced by the queue name
                                          // and %2 will be replaced by the host name:
                                          _("Access test failed for queue '%1' on host '%2'."),
                                          queue,
                                          host
                                        ),
                                 Printerlib::result["stderr"]:"" + "\n" + Printerlib::result["stdout"]:""
                               );
            return false;
          }
          break;
  }
  Popup::Message( _("Test OK") );
  return true;
}

boolean storeQueue( symbol selected )
{ if( "" == connection_uri )
  { return false;
  }
  string model = "Unknown";
  if( "" != connection_model )
  { model = connection_model;
  }
  y2internal( "Storing type '%1' with uri '%2' for model '%3'", selected, connection_uri, model );
  Printer::connections = add( Printer::connections,
                              $[ "uri" : connection_uri,
                                 "model" : model,
                                 "deviceID" : "",
                                 "info" : "created by the connection wizard",
                                 "class" : "ConnectionWizardDialog"
                               ]
                            );
  return true;
}

//UI::OpenDialog(content);
any ret = nil;
while( ret != `back && ret != `next )
{ ret = UI::UserInput();
  symbol selected = (symbol)UI::QueryWidget( `tree_selection, `Value );
  switch( (symbol)ret )
  { case(`tree_selection):
          changeSettingsDialog( selected );
          break;
    case(`next):
          if( validateSettingsDialog( selected ) )
          { y2milestone( "Writing settings" );
            storeQueue( selected );
          }
          else
          { y2error( "Could not validate %1", selected );
            ret=nil;
          }
          break;
    case(`scan_all):
          scanForServers( selected, true );
          break;
    case(`scan):
          scanForServers( selected, false );
          break;
    case(`test):
          if( validateSettingsDialog( selected ) )
          { testQueue( selected );
          }
          break;
    y2internal( "ret %1", ret );
  }
}
  return ret;
//UI::CloseDialog();
}
}

