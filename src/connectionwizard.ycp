/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:        include/printer/connectionwizard.ycp
 * Package:     Configuration of printer
 * Summary:     Connection Wizard
 * Authors:     Michal Zugec <mzugec@suse.de>
 *              Johannes Meixner <jsmeix@suse.de>
 *
 * $Id: connectionwizard.ycp 27914 2006-02-13 14:32:08Z locilka $
 */

{

textdomain "printer";

import "Label";
import "Printer";
import "Printerlib";
import "Popup";
import "Wizard";

include "printer/helps.ycp";

string connection_uri="";
string connection_model="";

// List of reserved URI characters ! # $ % & ' ( ) * + , / : ; = ? @ [ ]
// (the % character is separated as percentage_percent_encoding)
// plus the space character and their matching percent encodings
// where each percent encoding must be exactly three characters
// and uppercase letters, otherwise URIpercentDecoding would not work.
// It is crucial to have "%":"%25" first so that URIpercentEncoding works correctly
// because "%" must be replaced by "%25" first of all otherwise
// a duplicate encoding would happen "Foo Bar" -> "Foo%20Bar" -> "Foo%2520Bar"
// but only "Foo Bar" -> "Foo%20Bar" would be the correct encoding.
// It is crucial to have "%":"%25" last so that URIpercentDecoding works correctly
// because "%25" must be replaced by "%" last otherwise
// a duplicate dencoding would happen: "Foo%2520Bar" -> "Foo%20Bar" -> "Foo Bar".
// but only "Foo%2520Bar" -> "Foo%20Bar" would be the correct dencoding.
// Therefore "%":"%25" cannot be at all in this list but is
// separated as percentage_percent_encoding which is
// prepended to this list so that URIpercentEncoding works correctly and
// appended to this list so that URIpercentDecoding works correctly.
// Unfortunately a simple map like $[ "%":"%25", " ":"%20", ... ]
// does not work because in a map the ordering is not kept
// even when there is no operation which changes the map
// the internal ordering in a map is different
// from how it was specified here.
// It seems the internal ordering in a map is alphabetically sorted
// so that $[ "%":"%25", " ":"%20", ... ] -> $[ " ":"%20", ... "%":"%25", ... ]
// Therefore a list is used which keeps the initial ordering.
list< map< string, string > > uri_percent_encodings = [ $[ "character":" ",
                                                           "encoding":"%20"
                                                         ],
                                                        $[ "character":"!",
                                                           "encoding":"%21"
                                                         ],
                                                        $[ "character":"#",
                                                           "encoding":"%23"
                                                         ],
                                                        $[ "character":"$",
                                                           "encoding":"%24"
                                                         ],
                                                        $[ "character":"&",
                                                           "encoding":"%26"
                                                         ],
                                                        $[ "character":"'",
                                                           "encoding":"%27"
                                                         ],
                                                        $[ "character":"(",
                                                           "encoding":"%28"
                                                         ],
                                                        $[ "character":")",
                                                           "encoding":"%29"
                                                         ],
                                                        $[ "character":"*",
                                                           "encoding":"%2A"
                                                         ],
                                                        $[ "character":"+",
                                                           "encoding":"%2B"
                                                         ],
                                                        $[ "character":",",
                                                           "encoding":"%2C"
                                                         ],
                                                        $[ "character":"/",
                                                           "encoding":"%2F"
                                                         ],
                                                        $[ "character":":",
                                                           "encoding":"%3A"
                                                         ],
                                                        $[ "character":";",
                                                           "encoding":"%3B"
                                                         ],
                                                        $[ "character":"=",
                                                           "encoding":"%3D"
                                                         ],
                                                        $[ "character":"?",
                                                           "encoding":"%3F"
                                                         ],
                                                        $[ "character":"@",
                                                           "encoding":"%40"
                                                         ],
                                                        $[ "character":"[",
                                                           "encoding":"%5B"
                                                         ],
                                                        $[ "character":"]",
                                                           "encoding":"%5D"
                                                         ]
                                                      ];
map< string, string > percentage_percent_encoding = $[ "character":"%",
                                                       "encoding":"%25"
                                                     ];

string URIpercentEncoding( string input )
{ // Unfortunately URL::EscapeString(input,URL::transform_map_passwd)
  // cannot be used because URL::transform_map_passwd is insufficient because
  // the characters ! # ' ( ) * [ ] are missing in URL::transform_map_passwd.
  // URIpercentEncoding replaces the space character and
  // each reserved character ! # $ % & ' ( ) * + , / : ; = ? @ [ ]
  // in a value (component) of an URI with its matching percent encoding,
  // see https://bugzilla.novell.com/show_bug.cgi?id=512549
  // This function can only be used for percent encoding of the value
  // of a single URI component where no character in the input
  // is already percent encoded, otherwise e.g. "Foo%20Bar" results "Foo%2520Bar".
  // In particular this function cannot be used when the user can enter a whole URI
  // or the whole set of URI options (e.g. option1=value1&option2=value2).
  string output = input;
  foreach( map< string, string > current_encoding,
           prepend( uri_percent_encodings, percentage_percent_encoding ),
           { string character = current_encoding["character"]:"";
             string encoding = current_encoding["encoding"]:"";
             if( "" == character || "" == encoding )
             { continue;
             }
             output = mergestring( splitstring( output, character ), encoding );
           }
         );
  y2milestone( "URIpercentEncoding from '%1' to '%2'", input, output );
  return output;
}

string URIpercentDecoding( string input )
{ // Unfortunately URL::UnEscapeString(input,URL::transform_map_passwd)
  // cannot be used because URL::transform_map_passwd is insufficient because
  // the characters ! # ' ( ) * [ ] are missing in URL::transform_map_passwd
  // and URL::UnEscapeString("Foo%2525Bar") results "Foo%Bar" which is wrong
  // because URIpercentDecoding("Foo%2525Bar") results "Foo%25Bar".
  // URIpercentDecoding is the opposite of the URIpercentEncoding function
  // so that URIpercentDecoding(URIpercentEncoding(input)) == input
  string output = input;
  // Assume the input is "First%3aSecond%3AThird%2525Rest"
  // Character positions: 0123456789012345678901234567890
  foreach( map< string, string > current_encoding,
           add( uri_percent_encodings, percentage_percent_encoding ),
           { string character = current_encoding["character"]:"";
             string encoding = current_encoding["encoding"]:"";
             if( "" == character || "" == encoding )
             { continue;
             }
             // Process the output of the previous foreach loop as rest_of_input
             // and clear the output for the current foreach loop:
             string rest_of_input = output;
             output = "";
             integer position = search( rest_of_input, encoding );
             // For character = "%" and encoding = "%25"
             //   position = 22 = search( "First%3aSecond%3AThird%2525Rest", "%25" )
             // For character = ":" and encoding = "%3A"
             //   position = 14 = search( "First%3aSecond%3AThird%25Rest", "%3A" )
             integer position_lowercase = search( rest_of_input, tolower( encoding ) );
             // For character = "%" and encoding = "%25"
             //   position_lowercase = 22 = search( "First%3aSecond%3AThird%2525Rest", "%25" )
             // For character = ":" and actual percent encoding = "%3a"
             //   position = 5 = search( "First%3aSecond%3AThird%25Rest", "%3a" )
             if( ( position != nil && position_lowercase != nil && position_lowercase < position )
                 || ( position == nil && position_lowercase != nil )
               )
             { position = position_lowercase;
               // For character = ":" and actual percent encoding = "%3a"
               //   position = 5
             }
             // For character = "%" and encoding = "%25"
             //   position = 22
             while( position != nil )
             { // Each percent encoding is exactly three characters long so that
               // the first position characters are those up to the current percent encoding
               // and at position + 3 the rest after the current percent encoding starts:
               string characters_up_to_current_encoding = substring( rest_of_input, 0, position );
               output = output + characters_up_to_current_encoding + character;
               // For character = "%" and encoding = "%25"
               //   output = "First%3aSecond%3AThird%" = "" + "First%3aSecond%3AThird" + "%"
               // For character = ":" and actual percent encoding = "%3a"
               //   output = "First:" = "" + "First" + ":"
               // For character = ":" and encoding = "%3A"
               //   output = "First:Second:" = "First:" + "Second" + ":"
               rest_of_input = substring( rest_of_input, position + 3 );
               // For character = "%" and encoding = "%25"
               //   rest_of_input = "25Rest"
               // For character = ":" and actual percent encoding = "%3a"
               //   rest_of_input = "Second%3AThird%25Rest"
               // For character = ":" and encoding = "%3A"
               //   rest_of_input = "Third%25Rest"
               position = search( rest_of_input, encoding );
               // For character = "%" and encoding = "%25"
               //   position = nil = search( "25Rest", "%25" )
               // For character = ":" and encoding = "%3A"
               //   position = 6 = search( "Second%3AThird%25Rest", "%3A" )
               // For second while loop for character = ":" and encoding = "%3A"
               //   position = nil = search( "Third%25Rest", "%3A" )
               position_lowercase = search( rest_of_input, tolower( encoding ) );
               // For character = "%" and encoding = "%25"
               //   position_lowercase = nil = search( "25Rest", "%25" )
               // For character = ":" and actual percent encoding = "%3a"
               //   position = nil = search( "Second%3AThird%25Rest", "%3a" )
               // For second while loop for character = ":" and actual percent encoding = "%3a"
               //   position = nil = search( "Third%25Rest", "%3a" )
               if( ( position != nil && position_lowercase != nil && position_lowercase < position )
                   || ( position == nil && position_lowercase != nil )
                 )
               { position = position_lowercase;
               }
               // For character = "%" and encoding = "%25"
               //   position = nil
               // For character = ":" and encoding = "%3A"
               //   position = 6
               // For second while loop for character = ":" and encoding = "%3A"
               //   position = nil
             }
             // After replacing all occurrences of the current percent encoding
             // by its character append what is left as rest of the input:
             output = output + rest_of_input;
             // For character = "%" and encoding = "%25"
             //   output = "First%3aSecond%3AThird%25Rest"
             // For character = ":" and encoding = "%3A"
             //   output = "First:Second:Third%25Rest"
           }
         );
  // output = "First:Second:Third%25Rest"
  y2milestone( "URIpercentDecoding from '%1' to '%2'", input, output );
  return output;
}

string getCurrentDeviceURI()
{ if( "" != Printer::connections[Printer::selected_connections_index,"uri"]:"")
  { return Printer::connections[Printer::selected_connections_index,"uri"]:"";
  }
  return Printer::queues[Printer::selected_queues_index,"uri"]:"";
}

string getUriWithUsernameAndPassword( string uri, string scheme )
{ // CUPS' "lpstat -v" suppresses "username:password@" (if it exists)
  // so that I may have to retrieve it directly form /etc/cups/printers.conf
  // but only in this special case (and not in general via tools/autodetect_print_queues)
  // because I also do not want to show the password needlessly in any dialog
  // (and/or needlessly in /var/log/YaST2/y2log via "Autodetected queues").
  // But the URI may be not in /etc/cups/printers.conf
  // because there was no queue set up with this device URI
  // (e.g. because the URI is right now created by the connection wizard)
  // or several queues in /etc/cups/printers.conf may match
  // or the URI may already contain a "username:password@" part
  // because it was created by a previous run of the connection wizard dialog
  // and now "username:password@" in the URI should be changed.
  // Therefore I do nothing if the URI already contains a '@'
  // in its second part parts[1] (note that parts[0] = "<scheme>:")
  // which indicates that a "username:password@" part already exists:
  list<string> parts = splitstring( uri, "/" );
  // Remove empty parts (e.g. <scheme>://server results ["<scheme>:","","server"]):
  parts = filter( string part, parts, { return ( "" != part ); } );
  if( ! issubstring( parts[1]:"", "@" ) )
  { // Replace quotes and all special egrep characters by a simple '.':
    string special_chars = "'\"\\()[]{}|^$?*+";
    string part1 = mergestring( splitstring( parts[1]:"", special_chars ), "." );
    string part2 = mergestring( splitstring( parts[2]:"", special_chars ), "." );
    // Let the whole pipe fail if any of its commands fail (requires bash):
    string grepcommand = "set -o pipefail ; egrep '^DeviceURI " + scheme + "://[^:]+:[^@]+@" + part1 + "/" + part2;
    if( "lpd" == scheme )
    { // The CUPS lpd backend supports a fixed username (there is no authentication via LPD protocol)
      // to describe who requested a print job in the form lpd://username@ip-address-or-hostname/...
      // (i.e. grep only for "username@" instead of the usual "username:password@"):
      grepcommand = "set -o pipefail ; egrep '^DeviceURI " + scheme + "://[^@]+@" + part1 + "/" + part2;
    }
    if( "" != parts[3]:"" )
    { string part3 = mergestring( splitstring( parts[3]:"", special_chars ), "." );
      grepcommand = grepcommand + "/" + part3;
    }
    grepcommand = grepcommand + "$' /etc/cups/printers.conf";
    Printerlib::ExecuteBashCommand( grepcommand + " | sort -u | wc -l | tr -d '[:space:]'" );
    if( "1" == Printerlib::result["stdout"]:"" )
    { // The DeviceURIs in /etc/cups/printers.conf which match to current_device_uri
      // are unambiguous (exactly one or several exactly same such DeviceURIs)
      // so that I can actually get it form /etc/cups/printers.conf:
      if( Printerlib::ExecuteBashCommand( grepcommand + " | head -n 1 | cut -s -d ' ' -f 2 | tr -d '[:space:]'" ) )
      { return Printerlib::result["stdout"]:"";
      }
    }
  }
  // By default and as fallback return the unchanged URI:
  return uri;
}

term getContentFromCurrentModel( boolean no_default_raw_queue )
{ term content = nil;
  string current_model_info = Printer::connections[Printer::selected_connections_index,"model"]:"";
  if( "" == current_model_info
      || "unknown" == tolower( current_model_info )
    )
  { if( Printer::selected_queues_index >= 0 )
    { if( "local" == Printer::queues[Printer::selected_queues_index,"config"]:"" )
      { string ppd = Printer::queues[Printer::selected_queues_index,"ppd"]:"";
        // For a local raw queue ppd is the empty string.
        // For a local queue with a System V style interface script ppd is "/etc/cups/interfaces/<name-of-the-script>".
        // For a local queue with URI "ipp://server/printers/queue" ppd is "ipp://server/printers/queue.ppd".
        // For a normal local queue with URI "ipp://server/resource" ppd is "/etc/cups/ppd/<queue-name>.ppd".
        // For a normal local queue ppd is "/etc/cups/ppd/<queue-name>.ppd".
        // The leading part "/etc/" may vary depending on how the local cupsd
        // is installed or configured, see "/usr/bin/cups-config --serverroot".
        if( "" == ppd )
        { no_default_raw_queue = false;
        }
        else
        { no_default_raw_queue = true;
        }
        if( issubstring( ppd, "/cups/ppd/" ) )
        { // A "(recommended)" is removed because there is a special patch in CUPS
          // which suppresses it in certain "lpinfo -m" output.
          // Note the YCP quoting: \" becomes " and \\n becomes \n in the commandline.
          string commandline = "grep '^\*NickName' " + ppd + " | cut -s -d '\"' -f2 | sed -e 's/(recommended)//' -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' | tr -s ' ' | tr -d '\\n'";
          if( Printerlib::ExecuteBashCommand( commandline ) )
          { current_model_info = Printerlib::result["stdout"]:"";
          }
        }
      }
      if( "" == current_model_info
          || "unknown" == tolower( current_model_info )
        )
      { current_model_info = Printer::queues[Printer::selected_queues_index,"description"]:"";
      }
    }
  }
  if( "" != current_model_info
      && "unknown" != tolower( current_model_info )
    )
  { current_model_info = Printer::DeriveModelName( current_model_info, 0 );
    if( no_default_raw_queue )
    { content = `Left
                ( `ComboBox
                  ( `id("manufacturers_combo_box"),
                    `opt(`editable),
                    // Header for a ComboBox to keep the printer model or select another manufacturer:
                    _("Keep the printer model or select another &manufacturer"),
                    prepend( add( Printer::known_manufacturers, "Raw Queue" ), current_model_info )
                  )
                );
    }
    else
    { content = `Left
                ( `ComboBox
                  ( `id("manufacturers_combo_box"),
                    `opt(`editable),
                    // Header for a ComboBox to optionally
                    // keep the printer model or select a printer manufacturer.
                    // Do not change or translate "raw", it is a technical term
                    // when no driver is used for a print queue.
                    _("Keep the model or select a &manufacturer if no 'raw queue' should be set up"),
                    prepend( prepend( Printer::known_manufacturers, current_model_info ), "Raw Queue" )
                  )
                );
    }
  }
  else
  { if( no_default_raw_queue )
    { content = `Left
                ( `ComboBox
                  ( `id("manufacturers_combo_box"),
                    `opt(`editable),
                    // Header for a ComboBox to select the printer manufacturer:
                    _("Select the printer &manufacturer"),
                    prepend( add( Printer::known_manufacturers, "Raw Queue" ), "" )
                  )
                );
    }
    else
    { content = `Left
                ( `ComboBox
                  ( `id("manufacturers_combo_box"),
                    `opt(`editable),
                    // Header for a ComboBox to optionally select the printer manufacturer.
                    // Do not change or translate "raw", it is a technical term
                    // when no driver is used for a print queue.
                    _("You may select a printer &manufacturer if no 'raw queue' should be set up"),
                    prepend( Printer::known_manufacturers, "Raw Queue" )
                  )
                );
    }
  }
  return content;
}

term getContentFromBackend( string backend )
{ list connection_items = [];
  backend = backend + ":/";
  string current_device_uri = getCurrentDeviceURI();
  boolean current_device_uri_found = false;
  term current_connection_item = nil;
  foreach( term connection_item,
           (list<term>)Printer::ConnectionItems( "" ),
           { // A connection_item is `item( `id(connections_index), model, uri, info )
             // but Printer::ConnectionItems adds a trailing space character to model and uri
             // (because the current YaST UI has almost no additional space between table columns)
             // so that the last character must be removed to get the correct device URI value:
             string uri = connection_item[2]:"";
             uri = substring( uri, 0, size(uri) - 1 );
             if( backend == substring( uri, 0, size(backend) ) )
             { if( current_device_uri == uri )
               { current_device_uri_found = true;
                 current_connection_item = connection_item;
               }
               else
               { connection_items = add( connection_items, connection_item );
               }
             }
           }
         );
  if( backend == substring( current_device_uri, 0, size(backend) ) )
  { if( ! current_device_uri_found )
    { // The current connection is no longer vaild.
      // Nevertheless the current connection must be topmost to be preselected because
      // anything else which might be topmost and preselected (even an empty value)
      // would silently change the current connection to the preselected one
      // when the user clicks [OK]:
      connection_items = prepend( connection_items,
                                  // Add trailing spaces because the current YaST UI
                                  // has almost no additional space between table columns
                                  // in partitcular not where the widest entry in a column is:
                                  `item( `id( -1 ),
                                         "Unknown" + " ",
                                         current_device_uri + " ",
                                         "No longer valid (printer not connected?)"
                                       )
                                );
    }
    else
    { // Add the current connection topmost to be preselected
      // via the default Table widget preselection:
      connection_items = prepend( connection_items, current_connection_item );
    }
  }
  term content = `VBox
                 ( `Table
                   ( `id(`connection_selection),
                     // By default there is no UserInput()
                     // if only something was selected in the Table
                     // (without clicking additionally a button)
                     // but the notify and immediate options
                     // forces UserInput() in this case:
                     `opt(`notify, `immediate, `keepSorting),
                     // Headers of a Table with a list of printer connections:
                     `header
                     ( // Header of a Table column with a list of printer connections.
                       // Printer model name:
                       _("Model"),
                       // Header of a Table column with a list of printer connections.
                       // Connection of the printer (e.g. via USB or via parallel port):
                       _("Connection"),
                       // Header of a Table column with a list of printer connections.
                       // Additional description of the printer or its particular connection:
                       _("Description")
                     ),
                     connection_items
                   )
                 );
  return content;
}

term getNetworkContent( string hostname, string scan_hosts_label, string port_or_queue_label, string port_or_queue, string uri_options )
{ // TRANSLATORS: Text entry to fill IP or hostname of remote server
  string hostname_label = _("&IP Address or Host Name");
  // No URIpercentDecoding/Encondin(hostname) is done
  // when it contains a '@' because a lpd URI can be of the form
  //   lpd://username@ip-address-or-hostname/...
  // and a ipp/http URI can be of the form
  //   ipp://username:password@ip-address-or-hostname/...
  //   http://username:password@ip-address-or-hostname/...
  // see https://bugzilla.novell.com/show_bug.cgi?id=512549
  if( issubstring( hostname, "@" ) )
  { // TRANSLATORS: Text entry to fill IP or hostname of remote server
    hostname_label = _("&IP Address or Host Name [percent-encoded]");
  }
  term content = `VBox
                 ( `Left
                   ( `HBox
                     ( `ComboBox
                       ( `id(`hostname),
                         `opt(`editable),
                         hostname_label,
                         [ hostname ]
                       ),
                       `MenuButton
                       ( // TRANSLATORS: Label for menu to search for remote servers
                         _("Look Up"),
                         [ `item( `id(`scan), scan_hosts_label ),
                           // TRANSLATORS: Button to search for remote servers
                           `item( `id(`scan_all), _("Look Up for All Hosts") )
                         ]
                       )
                     )
                   ),
                   `Left
                   ( `InputField( `id(`port_or_queue), port_or_queue_label, port_or_queue )
                   ),
                   `Left
                   ( `InputField( `id(`uri_options),
                                  // Show it as wide as possible because it may have to contain
                                  // longer stuff like 'option1=value1&option2=value2':
                                  `opt(`hstretch),
                                  // TRANSLATORS: InputField for optional Device URI parameters:
                                  _("Optional 'option=value' parameter (usually empty) [percent-encoded]"),
                                  uri_options
                                )
                   ),
                   `Left
                   ( // TRANSLATORS: Button to test remote printer machine
                     `PushButton( `id(`test), _("&Test Connection") )
                   )
                 );
  return content;
}

void changeSettingsDialog( symbol selected )
{ term content = nil;
  term connection_content = nil;
  term model_content = nil;
  string current_device_uri = "";
  list<string> uri_parts = [];
  string hostname = "";
  string port_or_queue = "";
  string uri_options = "";
  string uri = "";
  string queue = "";
  string domain = "";
  string printer = "";
  string user = "";
  string pass = "";
  boolean beh_do_not_disable = true;
  string beh_attempts = "0";
  string beh_delay = "30";
  switch(selected)
  { // directly connected
    case(`parallel):
          content = getContentFromBackend("parallel");
          break;
    case(`usb):
          content = getContentFromBackend("usb");
          break;
    case(`hplip):
          if( ! Printerlib::TestAndInstallPackage( "hplip", "installed" ) )
          // Only a notification but no installation of HPLIP in the Connection Wizard.
          // Installing the package hplip can pull in tons of required packages
          // because the hplip package does not only provide the 'hp' backend but is a
          // full featured multifunction solution with GUI for HP printers and all-in-one devices.
          // HPLIP supports printing, scanning, faxing, photo card access, and device management.
          // Additionally installing hplip can become very complicated (see driveradd.ycp).
          // Therefore the Connection Wizard is not bloated with installing HPLIP.
          { Popup::Message( // Popup::Message when the user had selected "HP Devices (HPLIP)"
                            // in the Connection Wizard but the RPM package hplip is not installed:
                            _("To access a HP device via the 'hp' backend,\nthe RPM package hplip must be installed.")
                          );
            content = `VBox
                      ( `Left
                        ( `Label
                          ( _("The RPM package hplip is not installed.") )
                        )
                      );
            break;
          }
          content = getContentFromBackend("hp");
          break;
    case(`serial):
          current_device_uri = getCurrentDeviceURI();
          string current_serial_device_node = "";
          list <term> serial_device_node_items = [];
          if( "serial:/" == substring( current_device_uri, 0, size( "serial:/" ) ) )
          { // The Device URI has the form like:
            // serial:/dev/ttyS6?baud=115200+bits=7+parity=space+flow=hard+stop=1
            // remove the scheme 'serial:' so that only '/dev/ttyS6' is left:
            current_serial_device_node = mergestring( sublist( splitstring( current_device_uri, ":?" ), 1, 1 ), "" );

          }
          boolean current_serial_device_node_found = false;
          foreach( string device_node,
                   [ "/dev/ttyS0",
                     "/dev/ttyS1",
                     "/dev/ttyS2",
                     "/dev/ttyS3",
                     "/dev/ttyS4",
                     "/dev/ttyS5",
                     "/dev/ttyS6",
                     "/dev/ttyS7"
                   ],
                   { if( current_serial_device_node == device_node )
                     { current_serial_device_node_found = true;
                       // Have the current serial device node preselected:
                       serial_device_node_items = add( serial_device_node_items,
                                                       `item( `id( device_node ), device_node, true )
                                                     );
                     }
                     else
                     { serial_device_node_items = add( serial_device_node_items,
                                                       `item( `id( device_node ), device_node )
                                                     );
                     }
                   }
                 );
          if( ! current_serial_device_node_found )
          { if( "" == current_serial_device_node )
            { // Have an empty entry topmost and preselected to be on the safe side because
              // the CUPS serial backend may blindly write to any device:
              serial_device_node_items = prepend( serial_device_node_items, `item( `id(""), "", true ) );
            }
            else
            { // Have the current_serial_device_node topmost and preselected:
              serial_device_node_items = prepend( serial_device_node_items,
                                                   `item( `id( current_serial_device_node ),
                                                          current_serial_device_node,
                                                          true
                                                        )
                                                 );
            }
          }
          list <term> serial_baud_rate_items = [];
          list <term> serial_data_bits_items = [];
          list <term> serial_parity_items = [];
          list <term> serial_flow_control_items = [];
          list <term> serial_stop_bits_items = [];
          if( "serial:/" == substring( current_device_uri, 0, size( "serial:/" ) ) )
          { foreach( string parameter,
                     // The Device URI has the form like:
                     // serial:/dev/ttyS6?baud=115200+bits=7+parity=space+flow=hard+stop=1
                     // remove all before the '?' so that only the parameters 'baud=115200+bits=7...' are left
                     // as strings in a list like ["baud=115200","bits=7","parity=space","flow=hard","stop=1"]:
                     sublist( splitstring( current_device_uri, "?+" ), 1 ),
                     { list <string> keyword_value = splitstring( parameter, "=" );
                       string keyword = keyword_value[0]:"";
                       string value = keyword_value[1]:"";
                       boolean value_found = false;
                       if( "baud" == keyword )
                       { foreach( string item_value,
                                  // The preset values are from backend/serial.c in the CUPS 1.3.9 sources:
                                  [ "1200", "2400", "4800", "9600", "19200", "38400", "57600", "115200", "230400" ],
                                  { if( value == item_value )
                                    { value_found = true;
                                      // Have the current value preselected:
                                      serial_baud_rate_items = add( serial_baud_rate_items,
                                                                    `item( `id( item_value ), item_value, true )
                                                                  );
                                    }
                                    else
                                    { serial_baud_rate_items = add( serial_baud_rate_items,
                                                                    `item( `id( item_value ), item_value )
                                                                  );
                                    }
                                  }
                                );
                         if( ! value_found )
                         { if( "" == value )
                           { // Have an empty entry topmost and preselected to be on the safe side because
                             // the baud rate may have to be exactly what is set in the printer (e.g. via DIP switches):
                             serial_baud_rate_items = prepend( serial_baud_rate_items, `item( `id(""), "", true ) );
                           }
                           else
                           { // Only the above preset values are known to be supported by CUPS.
                             // If the current value is none of them, it might be invalid or a typo.
                             // Therefore the current value is added with an appropriate hint.
                             // Nevertheless the current value must be topmost and preselected because
                             // anything else which might be preselected (even an empty value)
                             // would silently change the current value to the preselected one
                             // when the user clicks [OK]:
                             serial_baud_rate_items = prepend( serial_baud_rate_items,
                                                               `item( `id( value ),
                                                                      value + " (might be invalid or a typo)",
                                                                      true
                                                                    )
                                                             );
                           }
                         }
                       }
                       if( "bits" == keyword )
                       { foreach( string item_value,
                                  // The preset values are from backend/serial.c in the CUPS 1.3.9 sources:
                                  [ "7", "8" ],
                                  { if( value == item_value )
                                    { value_found = true;
                                      // Have the current value preselected:
                                      serial_data_bits_items = add( serial_data_bits_items,
                                                                    `item( `id( item_value ), item_value, true )
                                                                  );
                                    }
                                    else
                                    { serial_data_bits_items = add( serial_data_bits_items,
                                                                    `item( `id( item_value ), item_value )
                                                                  );
                                    }
                                  }
                                );
                         if( ! value_found )
                         { if( "" == value )
                           { // Have an empty entry topmost and preselected to be on the safe side because
                             // the data bits may have to be exactly what is set in the printer (e.g. via DIP switches):
                             serial_data_bits_items = prepend( serial_data_bits_items, `item( `id(""), "", true ) );
                           }
                           else
                           { // Only the above preset values are known to be supported by CUPS.
                             // If the current value is none of them, it might be invalid or a typo.
                             // Therefore the current value is added with an appropriate hint.
                             // Nevertheless the current value must be topmost and preselected because
                             // anything else which might be preselected (even an empty value)
                             // would silently change the current value to the preselected one
                             // when the user clicks [OK]:
                             serial_data_bits_items = prepend( serial_data_bits_items,
                                                               `item( `id( value ),
                                                                      value + " (might be invalid or a typo)",
                                                                      true
                                                                    )
                                                             );
                           }
                         }
                       }
                       if( "parity" == keyword )
                       { foreach( string item_value,
                                  // The preset values are from backend/serial.c in the CUPS 1.3.9 sources:
                                  [ "even", "odd", "none", "space", "mark" ],
                                  { if( value == item_value )
                                    { value_found = true;
                                      // Have the current value preselected:
                                      serial_parity_items = add( serial_parity_items,
                                                                 `item( `id( item_value ), item_value, true )
                                                               );
                                    }
                                    else
                                    { serial_parity_items = add( serial_parity_items,
                                                                 `item( `id( item_value ), item_value )
                                                               );
                                    }
                                  }
                                );
                         if( ! value_found )
                         { if( "" == value )
                           { // Have an empty entry topmost and preselected to be on the safe side because
                             // the parity may have to be exactly what is set in the printer (e.g. via DIP switches):
                             serial_parity_items = prepend( serial_parity_items, `item( `id(""), "", true ) );
                           }
                           else
                           { // Only the above preset values are known to be supported by CUPS.
                             // If the current value is none of them, it might be invalid or a typo.
                             // Therefore the current value is added with an appropriate hint.
                             // Nevertheless the current value must be topmost and preselected because
                             // anything else which might be preselected (even an empty value)
                             // would silently change the current value to the preselected one
                             // when the user clicks [OK]:
                             serial_parity_items = prepend( serial_parity_items,
                                                            `item( `id( value ),
                                                                   value + " (might be invalid or a typo)",
                                                                   true
                                                                 )
                                                          );
                           }
                         }
                       }
                       if( "flow" == keyword )
                       { foreach( string item_value,
                                  // The preset values are from backend/serial.c in the CUPS 1.3.9 sources:
                                  [ "none", "soft", "hard", "dtrdsr" ],
                                  { string item_text = item_value;
                                    if( "soft" == item_value ) item_text = "XON/XOFF (software)";
                                    if( "hard" == item_value ) item_text = "RTS/CTS (hardware)";
                                    if( "dtrdsr" == item_value ) item_text = "DTR/DSR (hardware)";
                                    if( value == item_value )
                                    { value_found = true;
                                      // Have the current value preselected:
                                      serial_flow_control_items = add( serial_flow_control_items,
                                                                       `item( `id( item_value ), item_text, true )
                                                                     );
                                    }
                                    else
                                    { serial_flow_control_items = add( serial_flow_control_items,
                                                                       `item( `id( item_value ), item_text )
                                                                     );
                                    }
                                  }
                                );
                         if( ! value_found )
                         { if( "" == value )
                           { // Have an empty entry topmost and preselected to be on the safe side because the
                             // flow control may have to be exactly what is set in the printer (e.g. via DIP switches):
                             serial_flow_control_items = prepend( serial_flow_control_items, `item( `id(""), "", true ) );
                           }
                           else
                           { // Only the above preset values are known to be supported by CUPS.
                             // If the current value is none of them, it might be invalid or a typo.
                             // Therefore the current value is added with an appropriate hint.
                             // Nevertheless the current value must be topmost and preselected because
                             // anything else which might be preselected (even an empty value)
                             // would silently change the current value to the preselected one
                             // when the user clicks [OK]:
                             serial_flow_control_items = prepend( serial_flow_control_items,
                                                                  `item( `id( value ),
                                                                         value + " (might be invalid or a typo)",
                                                                         true
                                                                       )
                                                                );
                           }
                         }
                       }
                       if( "stop" == keyword )
                       { foreach( string item_value,
                                  // The preset values are from backend/serial.c in the CUPS 1.3.9 sources:
                                  [ "1", "2" ],
                                  { if( value == item_value )
                                    { value_found = true;
                                      // Have the current value preselected:
                                      serial_stop_bits_items = add( serial_stop_bits_items,
                                                                    `item( `id( item_value ), item_value, true )
                                                                  );
                                    }
                                    else
                                    { serial_stop_bits_items = add( serial_stop_bits_items,
                                                                    `item( `id( item_value ), item_value )
                                                                  );
                                    }
                                  }
                                );
                         if( ! value_found )
                         { if( "" == value )
                           { // Have an empty entry topmost and preselected to be on the safe side because the
                             // stop bits may have to be exactly what is set in the printer (e.g. via DIP switches):
                             serial_stop_bits_items = prepend( serial_stop_bits_items, `item( `id(""), "", true ) );
                           }
                           else
                           { // Only the above preset values are known to be supported by CUPS.
                             // If the current value is none of them, it might be invalid or a typo.
                             // Therefore the current value is added with an appropriate hint.
                             // Nevertheless the current value must be topmost and preselected because
                             // anything else which might be preselected (even an empty value)
                             // would silently change the current value to the preselected one
                             // when the user clicks [OK]:
                             serial_stop_bits_items = prepend( serial_stop_bits_items,
                                                               `item( `id( value ),
                                                                      value + " (might be invalid or a typo)",
                                                                      true
                                                                    )
                                                             );
                           }
                         }
                       }
                     }
                   );
          }
          model_content = getContentFromCurrentModel( true );
          content = `VBox
                    ( `Left
                      ( `ComboBox
                        ( `id(`serial_device_node),
                          // This ComboBox is editable because there could be
                          // any kind of serial device node name "/dev/whatever":
                          `opt(`editable),
                          // Label for an editable ComboBox where
                          // a serial device node (e.g. /dev/ttyS0 or /dev/ttyS1)
                          // can be selected or entered:
                          _("&Serial device"),
                          serial_device_node_items
                        )
                      ),
                      `Left
                      ( `ComboBox
                        ( `id(`serial_baud_rate),
                          // The backend/serial.c in the CUPS 1.3.9 sources
                          // supports only the preset values below.
                          // Nevertheless this ComboBox is editable to be future-proof:
                          `opt(`editable),
                          // Label for an editable ComboBox where
                          // the baud rate for a serial device
                          // can be selected or entered:
                          _("&Baud rate"),
                          serial_baud_rate_items
                        )
                      ),
                      `Left
                      ( `ComboBox
                        ( `id(`serial_data_bits),
                          // The backend/serial.c in the CUPS 1.3.9 sources
                          // supports only the preset values below (7 and 8).
                          // Nevertheless this ComboBox is editable to be future-proof
                          // because according to http://en.wikipedia.org/wiki/Serial_port
                          // a serial port might also have 5, 6, or 9 data bits.
                          `opt(`editable),
                          // Label for an editable ComboBox where
                          // the number of data bits for a serial device
                          // can be selected or entered:
                          _("&Data bits"),
                          serial_data_bits_items
                        )
                      ),
                      `Left
                      ( `ComboBox
                        ( `id(`serial_parity),
                          // The backend/serial.c in the CUPS 1.3.9 sources
                          // supports only the preset values below.
                          // Nevertheless this ComboBox is editable to be future-proof:
                          `opt(`editable),
                          // Label for an editable ComboBox where
                          // the parity checking for a serial device
                          // can be selected or entered:
                          _("&Parity checking"),
                          serial_parity_items
                        )
                      ),
                      `Left
                      ( `ComboBox
                        ( `id(`serial_flow_control),
                          // The backend/serial.c in the CUPS 1.3.9 sources
                          // supports only the preset values below.
                          // Nevertheless this ComboBox is editable to be future-proof
                          // because according to http://en.wikipedia.org/wiki/Flow_control
                          // a serial port might also have another kind of flow control.
                          `opt(`editable),
                          // Label for an editable ComboBox where
                          // the flow control for a serial device
                          // can be selected or entered:
                          _("&Flow control"),
                          serial_flow_control_items
                        )
                      ),
                      `Left
                      ( `ComboBox
                        ( `id(`serial_stop_bits),
                          // The backend/serial.c in the CUPS 1.3.9 sources
                          // supports only the preset values below.
                          // Nevertheless this ComboBox is editable to be future-proof:
                          `opt(`editable),
                          // Label for an editable ComboBox where
                          // the number of stop bits for a serial device
                          // can be selected or entered:
                          _("S&top bits"),
                          serial_stop_bits_items
                        )
                      ),
                      model_content
                    );
          break;
    case(`bluetooth):
          if( ! Printerlib::TestAndInstallPackage( "bluez-cups", "installed" ) )
          { if( Popup::ContinueCancel( _("To access a bluetooth printer, the RPM package bluez-cups must be installed.") ) )
            { Printerlib::TestAndInstallPackage( "bluez-cups", "install" );
            }
            // The user can also decide during the actual installation not to install it
            // or the installation may have failed for whatever reason
            // so that we test again whether or not it is now actually installed:
            if( ! Printerlib::TestAndInstallPackage( "bluez-cups", "installed" ) )
            { content = `VBox
                        ( `Left
                          ( `Label
                            ( _("The RPM package bluez-cups is not installed.") )
                          )
                        );
              break;
            }
          }
          // Fallback message what the user may run manually when it fails
          // to generate a valid list of bluetooth device IDs:
          string  bluetooth_device_list = _("It seems there are no bluetooth device IDs.\nRun 'hcitool scan' to get the bluetooth device IDs.\nEnter the ID without colons like '1A2B3C4D5E6F'.");
          Popup::ShowFeedback( // No title for a simple busy message:
                               "",
                               // Busy message:
                               // Body of a Popup::ShowFeedback:
                               _("Retrieving bluetooth device IDs...")
                             );
          // The command "hcitool scan" might need very much time or hang up.
          // To kill exactly hcitool there is the workaround via the temporary file because
          // hcitool scan | grep '...' & sleep 10 ; kill -9 $!
          // would kill only grep and
          // ( hcitool scan | grep '...' ) & sleep 10 ; kill -9 $!
          // would kill only the sub shell.
          if( ! Printerlib::ExecuteBashCommand( "hcitool scan >/tmp/hcitool_scan.out & sleep 10 ; kill -9 $! ; grep '..:..:..:..:..:..' /tmp/hcitool_scan.out | tr -s ' ' ; rm -f /tmp/hcitool_scan.out" ) )
          { // Will probably never fail because the final "rm -f ..." should exit successfully in any case:
            Popup::ErrorDetails( // Popup::ErrorDetails message:
                                 _("Failed to get a list of bluetooth device IDs."),
                                 "hcitool scan" + "\n" + Printerlib::result["stderr"]:""
                               );
          }
          else
          { if( "" != Printerlib::result["stdout"]:"" )
            { bluetooth_device_list = Printerlib::result["stdout"]:"";
            }
          }
          Popup::ClearFeedback();
          y2milestone( "bluetooth_device_list '%1'", bluetooth_device_list );
          current_device_uri = getCurrentDeviceURI();
          string current_bluetooth_device_id = "";
          list <term> bluetooth_device_id_items = [];
          if( "bluetooth:/" == substring( current_device_uri, 0, size( "bluetooth:/" ) ) )
          { // The Device URI has the form:
            // bluetooth://deviceID
            uri_parts = splitstring( current_device_uri, "/" );
            // Remove empty parts (e.g. bluetooth://deviceID results ["bluetooth:","","deviceID"]):
            uri_parts = filter( string part, uri_parts, { return ( "" != part ); } );
            y2milestone( "ConnectionWizardDialog uri_parts = '%1'", uri_parts );
            // Note that uri_parts[0] = "bluetooth:".
            if( "" != uri_parts[1]:"" )
            { current_bluetooth_device_id = uri_parts[1]:"";
            }
          }
          boolean current_bluetooth_device_id_found = false;
          foreach( string word,
                   splitstring( bluetooth_device_list, " " ),
                   { if( regexpmatch( word, "..:..:..:..:..:..") )
                     { // A bluetooth device ID has the form 1A:2B:3C:4D:5E:6F
                       // but the bluetooth backend needs it without the colons ':'
                       // in its DeviceURI which has the form bluetooth://1A2B3C4D5E6F
                       string hexnumber = filterchars( word, "0123456789ABCDEFabcdef" );
                       if( "" != hexnumber )
                       { if( current_bluetooth_device_id == hexnumber )
                         { current_bluetooth_device_id_found = true;
                           // Have the current bluetooth device id preselected:
                           bluetooth_device_id_items = add( bluetooth_device_id_items,
                                                            `item( `id( hexnumber ), hexnumber, true )
                                                          );
                         }
                         else
                         { bluetooth_device_id_items = add( bluetooth_device_id_items,
                                                            `item( `id( hexnumber ), hexnumber )
                                                          );
                         }
                       }
                     }
                   }
                 );
          if( ! current_bluetooth_device_id_found )
          { if( "" == current_bluetooth_device_id )
            { // Have an empty entry topmost and preselected to be on the safe side because
              // the bluetooth backend may blindly write to any bluetooth device:
              bluetooth_device_id_items = prepend( bluetooth_device_id_items, `item( `id(""), "", true ) );
            }
            else
            { // Have the current_bluetooth_device_id topmost and preselected:
              bluetooth_device_id_items = prepend( bluetooth_device_id_items,
                                                   `item( `id( current_bluetooth_device_id ),
                                                          current_bluetooth_device_id,
                                                          true
                                                        )
                                                 );
            }
          }
          model_content = getContentFromCurrentModel( true );
          content = `VBox
                    ( `Left
                      ( `ComboBox
                        ( `id(`bluetooth_device_id),
                          `opt(`editable),
                          // Label for an editable ComboBox where
                          // a bluetooth device ID
                          // can be selected or entered:
                          _("&Bluetooth device ID"),
                          bluetooth_device_id_items
                        )
                      ),
                      `Left
                      ( `Frame
                        ( // TRANSLATORS: Frame label for a list of bluetooth device IDs:
                          _("Currently available bluetooth device IDs"),
                          // The RichText widget is required here to get scroll bars if needed
                          // (a Label cuts the content because it does not provide scroll bars):
                          `RichText( "<pre>" + bluetooth_device_list + "</pre>" )
                        )
                      ),
                      model_content
                    );
          break;
    case(`scsi):
          // Fallback message what the user may run manually when it fails
          // to generate the current list of SCSI generic device nodes:
          string scsi_device_list = _("It seems there are no SCSI generic devices (/dev/sg...).\nRun 'lsscsi -g' to get a list of SCSI generic devices.");
          // Let the whole pipe fail if any of its commands fail (requires bash):
          if( ! Printerlib::ExecuteBashCommand( "set -o pipefail ; lsscsi -g | tr -s ' ' | cut -s -d ' ' -f 3- | grep '/dev/sg' || echo 'no SCSI generic device found' 1>&2" ) )
          { Popup::ErrorDetails( // Popup::ErrorDetails message:
                                 _("Failed to get a list of SCSI generic devices."),
                                 "lsscsi -g" + "\n" + Printerlib::result["stderr"]:""
                               );
          }
          else
          { if( "" != Printerlib::result["stdout"]:"" )
            { scsi_device_list = Printerlib::result["stdout"]:"";
            }
          }
          y2milestone( "scsi_device_list '%1'", scsi_device_list );
          current_device_uri = getCurrentDeviceURI();
          string current_scsi_device_node = "";
          list <term> scsi_device_node_items = [];
          if( "scsi:/" == substring( current_device_uri, 0, size( "scsi:/" ) ) )
          { // The Device URI has the form:
            // scsi:/dev/sg...
            // remove the scheme 'scsi:' so that only the '/dev/sg...' is left:
            current_scsi_device_node = mergestring( sublist( splitstring( current_device_uri, ":" ), 1 ), "" );

          }
          boolean current_scsi_device_node_found = false;
          foreach( string device_node,
                   [ "/dev/sg0", "/dev/sg1", "/dev/sg2", "/dev/sg3", "/dev/sg4", "/dev/sg5", "/dev/sg6", "/dev/sg7" ],
                   { if( current_scsi_device_node == device_node )
                     { current_scsi_device_node_found = true;
                       // Have the current scsi device node preselected:
                       scsi_device_node_items = add( scsi_device_node_items,
                                                     `item( `id( device_node ), device_node, true )
                                                   );
                     }
                     else
                     { scsi_device_node_items = add( scsi_device_node_items,
                                                     `item( `id( device_node ), device_node )
                                                   );
                     }
                   }
                 );

          if( ! current_scsi_device_node_found )
          { if( "" == current_scsi_device_node )
            { // Have an empty entry topmost and preselected to be on the safe side because
              // the CUPS scsi backend may blindly write to any device,
              // (see backend/scsi-linux.c in the CUPS 1.3.9 sources):
              scsi_device_node_items = prepend( scsi_device_node_items, `item( `id(""), "", true ) );
            }
            else
            { // Have the current_scsi_device_node topmost and preselected:
              scsi_device_node_items = prepend( scsi_device_node_items,
                                                `item( `id( current_scsi_device_node ), current_scsi_device_node, true )
                                              );
            }
          }
          model_content = getContentFromCurrentModel( true );
          content = `VBox
                    ( `Left
                      ( `ComboBox
                        ( `id(`scsi_device_node),
                          `opt(`editable),
                          // Label for an editable ComboBox where
                          // a SCSI generic device node (e.g. /dev/sg0 or /dev/sg1)
                          // can be selected or entered:
                          _("&SCSI generic device"),
                          scsi_device_node_items
                        )
                      ),
                      `Left
                      ( `Frame
                        ( // TRANSLATORS: Frame label for a list of SCSI generic devices:
                          _("Currently available SCSI generic devices"),
                          // The RichText widget is required here to get scroll bars if needed
                          // (a Label cuts the content because it does not provide scroll bars):
                          `RichText( "<pre>" + scsi_device_list + "</pre>" )
                        )
                      ),
                      model_content
                    );
          break;
    // network printer
    case(`tcp):
          hostname = "";
          port_or_queue = "9100";
          uri_options = "";
          current_device_uri = getCurrentDeviceURI();
          if( "socket:/" == substring( current_device_uri, 0, size( "socket:/" ) ) )
          { // The Device URI has the form ([...] is an optional part):
            // socket://ip-address-or-hostname[:port-number][?waiteof=false]
            uri_parts = splitstring( current_device_uri, ":/?" );
            // Remove empty parts (e.g. socket://server results ["socket","","","server"]):
            uri_parts = filter( string part, uri_parts, { return ( "" != part ); } );
            y2milestone( "ConnectionWizardDialog uri_parts = '%1'", uri_parts );
            // Note that uri_parts[0] = "socket".
            if( "" != uri_parts[1]:"" )
            { hostname = uri_parts[1]:"";
              if( "" != uri_parts[2]:"" )
              { if( issubstring( uri_parts[2]:"", "=" ) )
                { uri_options = uri_parts[2]:"";
                }
                else
                { port_or_queue = uri_parts[2]:"";
                  if( issubstring( uri_parts[3]:"", "=" ) )
                  { uri_options = uri_parts[3]:"";
                  }
                }
              }
            }
          }
          connection_content = getNetworkContent( URIpercentDecoding( hostname ),
                                                  // TRANSLATORS: List of input field labels,
                                                  // first for network scan button,
                                                  // second for the TCP port number:
                                                  _("Scan for Direct Socket Servers"),
                                                  _("TCP Port Number"),
                                                  URIpercentDecoding( port_or_queue ),
                                                  uri_options
                                                );
          model_content = getContentFromCurrentModel( true );
          content = `VBox( connection_content, model_content );
          break;
    case(`lpd):
          hostname = "";
          port_or_queue = "LPT1";
          uri_options = "";
          current_device_uri = getCurrentDeviceURI();
          if( "lpd:/" == substring( current_device_uri, 0, size( "lpd:/" ) ) )
          { // Even the DeviceURI for lpd can contain a fixed username
            // (there is no authentication via LPD protocol)
            // to describe who requested a print job in the form
            //   lpd://username@ip-address-or-hostname/...
            // but usage of this is really really not encouraged, see
            // https://bugzilla.novell.com/show_bug.cgi?id=512549
            // so that its setup not supported here but when
            // such an URI already exists, it should be shown correctly:
            // CUPS' "lpstat -v" suppresses "username:password@" (if it exists)
            // so that it may have to be retrieved form /etc/cups/printers.conf:
            current_device_uri = getUriWithUsernameAndPassword( current_device_uri, "lpd" );
            // The Device URI has the form ([...[...]...] are optional parts):
            // lpd://ip-address-or-hostname/queue[?option1=value1[&option2=value2...[&optionN=valueN]...]]
            uri_parts = splitstring( current_device_uri, ":/?" );
            // Remove empty parts (e.g. lpd://server results ["lpd","","","server"]):
            uri_parts = filter( string part, uri_parts, { return ( "" != part ); } );
            y2milestone( "ConnectionWizardDialog uri_parts = '%1'", uri_parts );
            // Note that uri_parts[0] = "lpd".
            if( "" != uri_parts[1]:"" )
            { hostname = uri_parts[1]:"";
              if( "" != uri_parts[2]:"" )
              { port_or_queue = uri_parts[2]:"";
                if( "" != uri_parts[3]:"" )
                { uri_options = uri_parts[3]:"";
                }
              }
            }
          }
          if( ! issubstring( hostname, "@" ) )
          { // It would be wrong to do URIpercentDecoding(hostname)
            // when it contains a '@' because a lpd URI can be of the form
            //   lpd://username@ip-address-or-hostname/...
            // see https://bugzilla.novell.com/show_bug.cgi?id=512549
            hostname = URIpercentDecoding( hostname );
          }
          connection_content = getNetworkContent( hostname,
                                                  // TRANSLATORS: List of input field labels,
                                                  // first for network scan button,
                                                  // second for name of printer queue
                                                  _("Scan for LPD Servers"),
                                                  _("Queue Name (see the printer's manual)"),
                                                  URIpercentDecoding( port_or_queue ),
                                                  uri_options
                                                );
          model_content = getContentFromCurrentModel( true );
          content = `VBox( connection_content, model_content );
          break;
    case(`ipp):
          uri = "";
          current_device_uri = getCurrentDeviceURI();
          if( "ipp:/" == substring( current_device_uri, 0, size( "ipp:/" ) )
              || "http:/" == substring( current_device_uri, 0, size( "http:/" ) )
            )
          { // Even the DeviceURI for ipp/http can contain
            // fixed username and password for authentication in the form
            //   ipp://username:password@ip-address-or-hostname/...
            //   http://username:password@ip-address-or-hostname/...
            // but usage of this is really really not encouraged, see
            // https://bugzilla.novell.com/show_bug.cgi?id=512549
            // so that its setup not supported here but when
            // such an URI already exists, it should be shown correctly:
            if( "ipp:/" == substring( current_device_uri, 0, size( "ipp:/" ) ) )
            { // CUPS' "lpstat -v" suppresses "username:password@" (if it exists)
              // so that it may have to be retrieved form /etc/cups/printers.conf:
              current_device_uri = getUriWithUsernameAndPassword( current_device_uri, "ipp" );
            }
            if( "http:/" == substring( current_device_uri, 0, size( "http:/" ) ) )
            { // CUPS' "lpstat -v" suppresses "username:password@" (if it exists)
              // so that it may have to be retrieved form /etc/cups/printers.conf:
              current_device_uri = getUriWithUsernameAndPassword( current_device_uri, "http" );
            }
            // A Device URI to print via CUPS server has the form "ipp://server/printers/queue"
            // while a Device URI to access a network printer via IPP
            // does probably not contain "/printers/" so that this is used here
            // as a best effort attempt to distinguish both cases:
            if( ! issubstring( current_device_uri, "/printers/" ) )
            { // The Device URI has the form ({either|or} and [...[...]...] are optional parts):
              // {ipp|http}://ip-address-or-hostname[:port-number]/resource[?option1=value1...[&optionN=valueN]...]
              uri = current_device_uri;
            }
          }
          model_content = getContentFromCurrentModel( true );
          content = `VBox
                    ( `Left
                      ( `InputField
                        ( `id(`uri),
                          // Show it as wide as possible because it may have to contain
                          // longer stuff like 'ipp://ip-address:port-number/resource':
                          `opt(`hstretch),
                          // TRANSLATORS: Input field label
                          _("URI (see the printer's manual) [percent-encoded]"),
                          uri
                        )
                      ),
                      model_content
                    );
          break;
    // print via
    case(`smb):
          if( ! Printerlib::TestAndInstallPackage( "samba-client", "installed" ) )
          { if( Popup::ContinueCancel( _("To access a SMB printer share, the RPM package samba-client must be installed.") ) )
            { Printerlib::TestAndInstallPackage( "samba-client", "install" );
            }
            // The user can also decide during the actual installation not to install it
            // or the installation may have failed for whatever reason
            // so that we test again whether or not it is now actually installed:
            if( ! Printerlib::TestAndInstallPackage( "samba-client", "installed" ) )
            { content = `VBox
                        ( `Left
                          ( `Label
                            ( _("The RPM package samba-client is not installed.") )
                          )
                        );
              break;
            }
          }
          hostname = "";
          domain = "";
          printer = "";
          user = "";
          pass = "";
          current_device_uri = getCurrentDeviceURI();
          if( "smb:/" == substring( current_device_uri, 0, size( "smb:/" ) ) )
          { // The Device URI has one of the forms ([...] is an optional part):
            // smb://server[:port]/share
            // smb://workgroup/server[:port]/share
            // smb://username:password@server[:port]/share
            // smb://username:password@workgroup/server[:port]/share
            // CUPS' "lpstat -v" suppresses "username:password@" (if it exists)
            // so that it may have to be retrieved form /etc/cups/printers.conf:
            current_device_uri = getUriWithUsernameAndPassword( current_device_uri, "smb" );
            // Here '/' is the only delimiter (so that username:password and server:port is one part):
            uri_parts = splitstring( current_device_uri, "/" );
            // Remove empty parts (e.g. smb://server results ["smb:","","server"]):
            uri_parts = filter( string part, uri_parts, { return ( "" != part ); } );
            y2milestone( "ConnectionWizardDialog uri_parts = '%1'", uri_parts );
            if( "" != uri_parts[1]:"" && "" != uri_parts[2]:"" )
            { // uri_parts[1] is server[:port] or workgroup or username:password@...
              if( issubstring( uri_parts[1]:"", "@" ) )
              { // smb://username:password@server[:port]/share
                // or
                // smb://username:password@workgroup/server[:port]/share
                if( "" != uri_parts[3]:"" )
                { // smb://username:password@workgroup/server[:port]/share
                  list<string> user_pass_domain = splitstring( uri_parts[1]:"", ":@" );
                  user = user_pass_domain[0]:"";
                  pass = user_pass_domain[1]:"";
                  domain = user_pass_domain[2]:"";
                  hostname = uri_parts[2]:"";
                  printer = uri_parts[3]:"";
                }
                else
                { // smb://username:password@server[:port]/share
                  list<string> user_pass_hostname = splitstring( uri_parts[1]:"", ":@" );
                  user = user_pass_hostname[0]:"";
                  pass = user_pass_hostname[1]:"";
                  hostname = user_pass_hostname[2]:"";
                  printer = uri_parts[2]:"";
                }
              }
              else
              { // smb://server[:port]/share
                // or
                // smb://workgroup/server[:port]/share
                if( "" != uri_parts[3]:"" )
                { // smb://workgroup/server[:port]/share
                  domain = uri_parts[1]:"";
                  hostname = uri_parts[2]:"";
                  printer = uri_parts[3]:"";
                }
                else
                { // smb://server[:port]/share
                  hostname = uri_parts[1]:"";
                  printer = uri_parts[2]:"";
                }
              }
            }
          }
          model_content = getContentFromCurrentModel( true );
          content = `VBox
                    ( `Left
                      ( `HBox
                        ( `ComboBox
                          ( `id(`hostname),
                            `opt(`editable),
                            // TRANSLATORS: Text entry for remote server name
                            _("Server (NetBIOS Host Name)"),
                            [ URIpercentDecoding( hostname ) ]
                          //),
                          //`MenuButton
                          //( // TRANSLATORS: Label for menu to search for remote servers
                          //  _("Look Up"),
                          //  [ `item( `id(`scan), _("Scan for samba printers") ),
                          //    // TRANSLATORS: Button to search for remote servers
                          //    `item( `id(`scan_all), _("Look Up for All Hosts") )
                          //  ]
                          )
                        )
                      ),
                      `Left
                      ( `InputField
                        ( `id(`printer),
                          // TRANSLATORS: Text entry for printer name
                          _("Printer (Share Name)"),
                          URIpercentDecoding( printer )
                        )
                      ),
                      `Left
                      ( `HBox
                        ( `ComboBox
                          ( `id(`domain),
                            `opt(`editable),
                            // TRANSLATORS: Text entry for samba domain
                            _("Workgroup (Domain Name)"),
                            [ URIpercentDecoding( domain ) ]
                          //),
                          //PushButton
                          //( `id(`scan_domain),
                          //  _("Scan for Windows Share Domains")
                          //)
                          )
                        )
                      ),
                      `Left
                      ( `Frame
                        ( // TRANSLATORS: Frame label for authentication
                          _("Authenticate As"),
                          `VBox
                          ( `InputField
                            ( `id(`user),
                              // TRANSLATORS: Text entry for username (authentication)
                              _("User"),
                              URIpercentDecoding( user )
                            ),
                            `Password
                            ( `id(`pass),
                              // TRANSLATORS: Text entry for password (authentication)
                              _("&Password"),
                              URIpercentDecoding( pass )
                            )
                          )
                        )
                      ),
                      `Left
                      ( `PushButton
                        ( `id(`test),
                          // TRANSLATORS: Button to test remote printer machine
                          _("&Test Connection")
                        )
                      ),
                      model_content
                    );
          break;
    case(`lpr):
          hostname = "";
          port_or_queue = "";
          uri_options = "";
          current_device_uri = getCurrentDeviceURI();
          if( "lpd:/" == substring( current_device_uri, 0, size( "lpd:/" ) ) )
          { // Even the DeviceURI for lpd can contain a fixed username
            // (there is no authentication via LPD protocol)
            // to describe who requested a print job in the form
            //   lpd://username@ip-address-or-hostname/...
            // but usage of this is really really not encouraged, see
            // https://bugzilla.novell.com/show_bug.cgi?id=512549
            // so that its setup not supported here but when
            // such an URI already exists, it should be shown correctly:
            // CUPS' "lpstat -v" suppresses "username:password@" (if it exists)
            // so that it may have to be retrieved form /etc/cups/printers.conf:
            current_device_uri = getUriWithUsernameAndPassword( current_device_uri, "lpd" );
            // The Device URI has the form ([...[...]...] are optional parts):
            // lpd://ip-address-or-hostname/queue[?option1=value1[&option2=value2...[&optionN=valueN]...]]
            uri_parts = splitstring( current_device_uri, ":/?" );
            // Remove empty parts (e.g. lpd://server results ["lpd","","","server"]):
            uri_parts = filter( string part, uri_parts, { return ( "" != part ); } );
            y2milestone( "ConnectionWizardDialog uri_parts = '%1'", uri_parts );
            // Note that uri_parts[0] = "lpd".
            if( "" != uri_parts[1]:"" )
            { hostname = uri_parts[1]:"";
              if( "" != uri_parts[2]:"" )
              { port_or_queue = uri_parts[2]:"";
                if( "" != uri_parts[3]:"" )
                { uri_options = uri_parts[3]:"";
                }
              }
            }
          }
          if( ! issubstring( hostname, "@" ) )
          { // It would be wrong to do URIpercentDecoding(hostname)
            // when it contains a '@' because a lpd URI can be of the form
            //   lpd://username@ip-address-or-hostname/...
            // see https://bugzilla.novell.com/show_bug.cgi?id=512549
            hostname = URIpercentDecoding( hostname );
          }
          connection_content = getNetworkContent( hostname,
                                                  // TRANSLATORS: List of input field labels,
                                                  // first for network scan button,
                                                  // second for name of printer queue
                                                  _("Scan for LPD Servers"),
                                                  _("Queue Name"),
                                                  URIpercentDecoding( port_or_queue ),
                                                  uri_options
                                                );
          model_content = getContentFromCurrentModel( false );
          content = `VBox( connection_content, model_content );
          break;
    case(`cups):
          hostname = "";
          queue = "";
          uri_options = "";
          current_device_uri = getCurrentDeviceURI();
          if( "ipp:/" == substring( current_device_uri, 0, size( "ipp:/" ) )
              || "http:/" == substring( current_device_uri, 0, size( "http:/" ) )
            )
          { // Even the DeviceURI for ipp/http can contain
            // fixed username and password for authentication in the form
            //   ipp://username:password@ip-address-or-hostname/...
            //   http://username:password@ip-address-or-hostname/...
            // but usage of this is really really not encouraged, see
            // https://bugzilla.novell.com/show_bug.cgi?id=512549
            // so that its setup not supported here but when
            // such an URI already exists, it should be shown correctly:
            if( "ipp:/" == substring( current_device_uri, 0, size( "ipp:/" ) ) )
            { // CUPS' "lpstat -v" suppresses "username:password@" (if it exists)
              // so that it may have to be retrieved form /etc/cups/printers.conf:
              current_device_uri = getUriWithUsernameAndPassword( current_device_uri, "ipp" );
            }
            if( "http:/" == substring( current_device_uri, 0, size( "http:/" ) ) )
            { // CUPS' "lpstat -v" suppresses "username:password@" (if it exists)
              // so that it may have to be retrieved form /etc/cups/printers.conf:
              current_device_uri = getUriWithUsernameAndPassword( current_device_uri, "http" );
            }
            // A Device URI to print via CUPS server has the form "ipp://server/printers/queue"
            // while a Device URI to access a network printer via IPP
            // does probably not contain "/printers/" so that this is used here
            // as a best effort attempt to distinguish both cases:
            if( issubstring( current_device_uri, "/printers/" ) )
            { // The Device URI has the form ({either|or} and [...[...]...] are optional parts):
              // {ipp|http}://ip-address-or-hostname[:port-number]/resource[?option1=value1...[&optionN=valueN]...]
              // where resource is something like /printers/queue on a CUPS server.
              // Here ':' is no delimiter so that ip-address-or-hostname:port-number is one part
              uri_parts = splitstring( current_device_uri, "/?" );
              // Remove empty parts (e.g. ipp://server results ["ipp:","","server"]):
              uri_parts = filter( string part, uri_parts, { return ( "" != part ); } );
              y2milestone( "ConnectionWizardDialog uri_parts = '%1'", uri_parts );
              // Note that uri_parts[0] = "{ipp:|http:}".
              if( "" != uri_parts[1]:"" )
              { hostname = uri_parts[1]:"";
                if( "printers" == uri_parts[2]:"" )
                { if( "" != uri_parts[3]:"" )
                  { queue = uri_parts[3]:"";
                    if( issubstring( uri_parts[4]:"", "=" ) )
                    { uri_options = uri_parts[4]:"";
                    }
                  }
                }
              }
            }
          }
          // TRANSLATORS: Text entry to fill IP or hostname of remote server
          string hostname_label = _("&IP Address or Host Name [percent-encoded]");
          if( ! issubstring( hostname, "@" ) )
          { // It would be wrong to do URIpercentDecoding(hostname)
            // when it contains a '@' because a ipp/http URI can be of the form
            //   ipp://username:password@ip-address-or-hostname/...
            //   http://username:password@ip-address-or-hostname/...
            // see https://bugzilla.novell.com/show_bug.cgi?id=512549
            hostname = URIpercentDecoding( hostname );
            // TRANSLATORS: Text entry to fill IP or hostname of remote server
            hostname_label = _("&IP Address or Host Name");
          }
          model_content = getContentFromCurrentModel( false );
          content = `VBox
                    ( `Left
                      ( `HBox
                        ( `ComboBox
                          ( `id(`hostname),
                            `opt(`editable),
                            hostname_label,
                            [ hostname ]
                          ),
                          `MenuButton
                          ( // TRANSLATORS: Label for menu to search for remote servers
                            _("Look Up"),
                            [ `item( `id(`scan), _("Scan for IPP Servers") ),
                              `item( `id(`scan_broadcast), _("Scan for IPP Broadcasts") ),
                              `item( `id(`scan_all), _("Look Up for All Hosts") )
                            ]
                          )
                        )
                      ),
                      `Left
                      ( // TRANSLATORS: InputField for a print queue name:
                        `InputField( `id(`queue), _("Queue Name"), URIpercentDecoding( queue ) )
                      ),
                      `Left
                      ( `InputField( `id(`uri_options),
                                     // Show it as wide as possible because it may have to contain
                                     // longer stuff like 'option1=value1&option2=value2':
                                     `opt(`hstretch),
                                     // TRANSLATORS: InputField for optional Device URI parameters:
                                     _("Optional 'option=value' parameter (usually empty) [percent-encoded]"),
                                     uri_options
                                   )
                      ),
                      `Left
                      ( `PushButton
                        ( `id(`test),
                          // TRANSLATORS: Button to test remote printer machine
                          _("&Test Connection")
                        )
                      ),
                      model_content
                    );
          break;
    case(`ipx):
          if( ! Printerlib::TestAndInstallPackage( "ncpfs", "installed" ) )
          { if( Popup::ContinueCancel( _("To access an IPX print queue, the RPM package ncpfs must be installed.") ) )
            { Printerlib::TestAndInstallPackage( "ncpfs", "install" );
            }
            // The user can also decide during the actual installation not to install it
            // or the installation may have failed for whatever reason
            // so that we test again whether or not it is now actually installed:
            if( ! Printerlib::TestAndInstallPackage( "ncpfs", "installed" ) )
            { content = `VBox
                        ( `Left
                          ( `Label
                            ( _("The RPM package ncpfs is not installed.") )
                          )
                        );
              break;
            }
          }
          hostname = "";
          queue = "";
          user = "";
          pass = "";
          current_device_uri = getCurrentDeviceURI();
          if( "novell:/" == substring( current_device_uri, 0, size( "novell:/" ) ) )
          { // The Device URI has one of the forms ([...] is an optional part):
            // novell://server/queue
            // novell://username:password@server/queue
            // CUPS' "lpstat -v" suppresses "username:password@" (if it exists)
            // so that it may have to be retrieved form /etc/cups/printers.conf.
            // Fortunately getSMBuriWithUsernameAndPassword works here too
            // because the forms of IPX and SMB device URIs match sufficienty:
            current_device_uri = getUriWithUsernameAndPassword( current_device_uri, "novell" );
            // Here '/' is the only delimiter (so that username:password and server:port is one part):
            uri_parts = splitstring( current_device_uri, "/" );
            // Remove empty parts (e.g. novell://server results ["novell:","","server"]):
            uri_parts = filter( string part, uri_parts, { return ( "" != part ); } );
            y2milestone( "ConnectionWizardDialog uri_parts = '%1'", uri_parts );
            if( "" != uri_parts[1]:"" && "" != uri_parts[2]:"" )
            { // uri_parts[1] is server[:port] or username:password@...
              if( issubstring( uri_parts[1]:"", "@" ) )
              { // novell://username:password@server/queue
                list<string> user_pass_hostname = splitstring( uri_parts[1]:"", ":@" );
                user = user_pass_hostname[0]:"";
                pass = user_pass_hostname[1]:"";
                hostname = user_pass_hostname[2]:"";
                queue = uri_parts[2]:"";
              }
              else
              { // novell://server/queue
                hostname = uri_parts[1]:"";
                queue = uri_parts[2]:"";
              }
            }
          }
          model_content = getContentFromCurrentModel( true );
          content = `VBox
                    ( `Left
                      ( `InputField
                        ( `id(`hostname),
                          // TRANSLATORS: Text entry for IP or hostname of remote server
                          _("IP Address or Host Name"),
                          hostname
                        )
                      ),
                      `Left
                      ( `InputField
                        ( `id(`queue),
                          // TRANSLATORS: Text entry for name of remote printer queue
                          _("Queue Name"),
                          queue
                        )
                      ),
                      `Left
                      ( `Frame
                        ( // TRANSLATORS: Frame label for authentication
                          _("Authenticate As"),
                          `VBox
                          ( `InputField
                            ( `id(`user),
                              // TRANSLATORS: Text entry for username (authentication)
                              _("User"),
                              user
                            ),
                            `Password
                            ( `id(`pass),
                              // TRANSLATORS: Text entry for password (authentication)
                              _("&Password"),
                              pass
                            )
                          )
                        )
                      ),
                      `Left
                      ( `PushButton
                        ( `id(`test),
                          // TRANSLATORS: Button to test remote printer machine
                          _("&Test Connection")
                        )
                      ),
                      model_content
                    );
          break;
    // special
    case(`uri):
          current_device_uri = getCurrentDeviceURI();
          if( "smb:/" == substring( current_device_uri, 0, size( "smb:/" ) ) )
          { // CUPS' "lpstat -v" suppresses "username:password@" (if it exists)
            // so that it may have to be retrieved form /etc/cups/printers.conf:
            current_device_uri = getUriWithUsernameAndPassword( current_device_uri, "smb" );
          }
          if( "novell:/" == substring( current_device_uri, 0, size( "novell:/" ) ) )
          { // CUPS' "lpstat -v" suppresses "username:password@" (if it exists)
            // so that it may have to be retrieved form /etc/cups/printers.conf:
            current_device_uri = getUriWithUsernameAndPassword( current_device_uri, "novell" );
          }
          // Even the DeviceURI for ipp/http can contain
          // fixed username and password for authentication in the form
          //   ipp://username:password@ip-address-or-hostname/...
          //   http://username:password@ip-address-or-hostname/...
          // but usage of this is really really not encouraged, see
          // https://bugzilla.novell.com/show_bug.cgi?id=512549
          // so that its setup not supported here but when
          // such an URI already exists, it should be shown correctly:
          if( "ipp:/" == substring( current_device_uri, 0, size( "ipp:/" ) ) )
          { // CUPS' "lpstat -v" suppresses "username:password@" (if it exists)
            // so that it may have to be retrieved form /etc/cups/printers.conf:
            current_device_uri = getUriWithUsernameAndPassword( current_device_uri, "ipp" );
          }
          if( "http:/" == substring( current_device_uri, 0, size( "http:/" ) ) )
          { // CUPS' "lpstat -v" suppresses "username:password@" (if it exists)
            // so that it may have to be retrieved form /etc/cups/printers.conf:
            current_device_uri = getUriWithUsernameAndPassword( current_device_uri, "http" );
          }
          // Even the DeviceURI for lpd can contain a fixed username
          // (there is no authentication via LPD protocol)
          // to describe who requested a print job in the form
          //   lpd://username@ip-address-or-hostname/...
          // but usage of this is really really not encouraged, see
          // https://bugzilla.novell.com/show_bug.cgi?id=512549
          // so that its setup not supported here but when
          // such an URI already exists, it should be shown correctly:
          if( "lpd:/" == substring( current_device_uri, 0, size( "lpd:/" ) ) )
          { // CUPS' "lpstat -v" suppresses "username:password@" (if it exists)
            // so that it may have to be retrieved form /etc/cups/printers.conf:
            current_device_uri = getUriWithUsernameAndPassword( current_device_uri, "lpd" );
          }
          model_content = getContentFromCurrentModel( true );
          content = `VBox
                    ( `Left
                      ( `InputField
                        ( `id(`uri),
                          // Show it as wide as possible because it may have to contain
                          // longer stuff like 'scheme://server:port/path/to/resource':
                          `opt(`hstretch),
                          // TRANSLATORS: Text entry for URI (Uniform Resource Identifier)
                          _("URI (Uniform Resource Identifier) [percent-encoded]"),
                          current_device_uri
                        )
                      ),
                      model_content
                    );
          break;
    case(`pipe):
          if( ! Printerlib::TestAndInstallPackage( "cups-backends", "installed" ) )
          { if( Popup::ContinueCancel( _("To print via 'pipe', the RPM package cups-backends must be installed.") ) )
            { Printerlib::TestAndInstallPackage( "cups-backends", "install" );
            }
            // The user can also decide during the actual installation not to install it
            // or the installation may have failed for whatever reason
            // so that we test again whether or not it is now actually installed:
            if( ! Printerlib::TestAndInstallPackage( "cups-backends", "installed" ) )
            { content = `VBox
                        ( `Left
                          ( `Label
                            ( _("The RPM package cups-backends is not installed.") )
                          )
                        );
              break;
            }
          }
          uri = "";
          current_device_uri = getCurrentDeviceURI();
          if( "pipe:/" == substring( current_device_uri, 0, size( "pipe:/" ) ) )
          { // The Device URI has the form ([...] is an optional part):
            // pipe:/path/to/command[?option1=value1&option2=value2...]
            // remove the scheme 'pipe:' so that only the '/path/to/command...' is left:
            uri = mergestring( sublist( splitstring( current_device_uri, ":" ), 1 ), "" );
          }
          model_content = getContentFromCurrentModel( false );
          content = `VBox
                    ( `Left
                      ( `InputField
                        ( `id(`program),
                          // Show it as wide as possible because it may have to contain
                          // longer stuff like 'path/to/command?option1=value1&option2=value2':
                          `opt(`hstretch),
                          // TRANSLATORS: Text entry for program name that will be called via pipe:
                          _("Program (/path/to/command?option=value) [percent-encoded]"),
                          uri
                        )
                      ),
                      model_content
                    );
          break;
    case(`beh):
          uri = "";
          beh_do_not_disable = true;
          beh_attempts = "0";
          beh_delay = "30";
          current_device_uri = getCurrentDeviceURI();
          if( "smb:/" == substring( current_device_uri, 0, size( "smb:/" ) ) )
          { // CUPS' "lpstat -v" suppresses "username:password@" (if it exists)
            // so that it may have to be retrieved form /etc/cups/printers.conf:
            current_device_uri = getUriWithUsernameAndPassword( current_device_uri, "smb" );
          }
          if( "novell:/" == substring( current_device_uri, 0, size( "novell:/" ) ) )
          { // CUPS' "lpstat -v" suppresses "username:password@" (if it exists)
            // so that it may have to be retrieved form /etc/cups/printers.conf:
            current_device_uri = getUriWithUsernameAndPassword( current_device_uri, "novell" );
          }
          // Even the DeviceURI for ipp/http can contain
          // fixed username and password for authentication in the form
          //   ipp://username:password@ip-address-or-hostname/...
          //   http://username:password@ip-address-or-hostname/...
          // but usage of this is really really not encouraged, see
          // https://bugzilla.novell.com/show_bug.cgi?id=512549
          // so that its setup not supported here but when
          // such an URI already exists, it should be shown correctly:
          if( "ipp:/" == substring( current_device_uri, 0, size( "ipp:/" ) ) )
          { // CUPS' "lpstat -v" suppresses "username:password@" (if it exists)
            // so that it may have to be retrieved form /etc/cups/printers.conf:
            current_device_uri = getUriWithUsernameAndPassword( current_device_uri, "ipp" );
          }
          if( "http:/" == substring( current_device_uri, 0, size( "http:/" ) ) )
          { // CUPS' "lpstat -v" suppresses "username:password@" (if it exists)
            // so that it may have to be retrieved form /etc/cups/printers.conf:
            current_device_uri = getUriWithUsernameAndPassword( current_device_uri, "http" );
          }
          // Even the DeviceURI for lpd can contain a fixed username
          // (there is no authentication via LPD protocol)
          // to describe who requested a print job in the form
          //   lpd://username@ip-address-or-hostname/...
          // but usage of this is really really not encouraged, see
          // https://bugzilla.novell.com/show_bug.cgi?id=512549
          // so that its setup not supported here but when
          // such an URI already exists, it should be shown correctly:
          if( "lpd:/" == substring( current_device_uri, 0, size( "lpd:/" ) ) )
          { // CUPS' "lpstat -v" suppresses "username:password@" (if it exists)
            // so that it may have to be retrieved form /etc/cups/printers.conf:
            current_device_uri = getUriWithUsernameAndPassword( current_device_uri, "lpd" );
          }
          uri = current_device_uri;
          if( "beh:/" == substring( current_device_uri, 0, size( "beh:/" ) ) )
          { // When it is already a "beh:/<dd>/<att>/<delay>/<originaluri>" URI
            // remove the beh-related stuff so that only the <originaluri> is left:
            uri = mergestring( sublist( splitstring( current_device_uri, "/" ), 4 ), "/" );
            uri_parts = splitstring( current_device_uri, "/" );
            // Remove possibly empty parts:
            uri_parts = filter( string part, uri_parts, { return ( "" != part ); } );
            y2milestone( "ConnectionWizardDialog uri_parts = '%1'", uri_parts );
            if( "" != uri_parts[1]:"" && "" != uri_parts[2]:"" && "" != uri_parts[3]:"" )
            { if( "0" == uri_parts[1]:"" )
              { beh_do_not_disable = false;
              }
              beh_attempts = uri_parts[2]:"";
              beh_delay = uri_parts[3]:"";
            }
          }
          model_content = getContentFromCurrentModel( true );
          content = `VBox
                    ( `Left
                      ( `InputField
                        ( `id(`beh_original_uri),
                          // Show it as wide as possible because it may have to contain
                          // longer stuff like 'scheme://server:port/path/to/resource':
                          `opt(`hstretch),
                          // TRANSLATORS: Text entry for device URI (Uniform Resource Identifier)
                          _("Device URI (for which 'beh' should be applied) [percent-encoded]"),
                          uri
                        )
                      ),
                      `Left
                      ( `CheckBox
                        ( `id(`beh_do_not_disable),
                          // TRANSLATORS: Check box
                          _("Never Disable the Queue"),
                          beh_do_not_disable
                        )
                      ),
                      `Left
                      ( `InputField
                        ( `id(`beh_attempts),
                          // TRANSLATORS: Text entry
                          _("Number of Retries ('0' means infinite retries)"),
                          beh_attempts
                        )
                      ),
                      `Left
                      ( `InputField
                        ( `id(`beh_delay),
                          // TRANSLATORS: Text entry
                          _("Delay in Seconds Between Two Retries"),
                          beh_delay
                        )
                      ),
                      model_content
                    );
          break;
    case(`directly):
    case(`network):
    case(`server):
    case(`special):
          content = `VBox
                    ( `Left
                      ( `Label
                        ( _("Select a specific connection type.") )
                      )
                    );
          break;
    default:
          y2error( "Unknown selected item %1", selected );
  }
  UI::ReplaceWidget( `connection_settings_replace_point, content );
}

any ConnectionWizardDialog()
{ term contents = `VBox
                  ( `HBox
                    ( `HWeight
                      ( 1,
                        `Tree
                        ( `id(`tree_selection),
                          `opt(`notify),
                          // TRANSLATORS: Label for tree widget description
                          _("&Connection Type"),
                          [ `item
                            ( `id(`directly),
                              // TRANSLATORS: Tree widget item
                              _("Directly Connected Device"),
                              true,
                              [ // TRANSLATORS: Tree widget item
                                `item( `id(`parallel), _("Parallel Port") ),
                                // TRANSLATORS: Tree widget item
                                `item(`id(`usb), _("USB Port") ),
                                // TRANSLATORS: Tree widget item
                                `item( `id(`hplip), _("HP Devices (HPLIP)") ),
                                // TRANSLATORS: Tree widget item
                                `item( `id(`serial), _("Serial Port") ),
                                // TRANSLATORS: Tree widget item
                                `item( `id(`bluetooth), _("Bluetooth") ),
                                // TRANSLATORS: Tree widget item
                                `item( `id(`scsi), _("SCSI") )
                              ]
                            ),
                            `item
                            ( `id(`network),
                              // TRANSLATORS: Tree widget item
                              _("Access Network Printer or Printserver Box via"),
                              true,
                              [ // TRANSLATORS: Tree widget item
                                `item( `id(`tcp), _("TCP Port (AppSocket/JetDirect)") ),
                                // TRANSLATORS: Tree widget item
                                `item( `id(`lpd), _("Line Printer Daemon (LPD) Protocol") ),
                                // TRANSLATORS: Tree widget item
                                `item( `id(`ipp), _("Internet Printing Protocol (IPP)") )
                              ]
                            ),
                            `item
                            ( `id(`server),
                              // TRANSLATORS: Tree widget item
                              _("Print Via Print Server Machine"),
                              true,
                              [ // TRANSLATORS: Tree widget item
                                `item( `id(`smb), _("Microsoft Windows/SAMBA (SMB/CIFS)") ),
                                // TRANSLATORS: Tree widget item
                                `item( `id(`lpr), _("Traditional UNIX Server (LPR/LPD)") ),
                                // `item( `id(`iprint), _("iPrint (Novell OES)") ),
                                // TRANSLATORS: Tree widget item
                                `item( `id(`cups), _("CUPS Server (IPP)") ),
                                // TRANSLATORS: Tree widget item
                                `item( `id(`ipx), _("Novell Netware Print Server (IPX)") )
                              ]
                            ),
                            `item
                            ( `id(`special),
                              // TRANSLATORS: Tree widget item
                              _("Special"),
                              true,
                              [ // TRANSLATORS: Tree widget item
                                `item( `id(`uri), _("Specify Arbitrary Device URI") ),
                                // TRANSLATORS: Tree widget item
                                `item( `id(`pipe), _("Send Print Data to Other Program (pipe)") ),
                                // TRANSLATORS: Tree widget item
                                `item( `id(`beh), _("Daisy-chain Backend Error Handler (beh)") )
                              ]
                            )
                          ]
                        )
                      ),
                      `HWeight
                      ( 1,
                        `VBox
                        ( `VStretch(),
                          `Frame
                          ( // TRANSLATORS: Connection details widget
                            _("Connection Settings"),
                            `ReplacePoint( `id(`connection_settings_replace_point),
                                           `VBox
                                           ( `Left
                                             ( `Label
                                               ( _("Select a specific connection type.") )
                                             )
                                           )
                                         )
                          ),
                          `VStretch()
                        )
                      )
                    )
                  );
  // According to http://en.opensuse.org/YaST/Style_Guide#Single_Configuration.2FOverview.2FEdit_Dialog
  // there is no longer a "abort" functionality which exits the whole module.
  // Instead this button is now named "Cancel" and its functionality is
  // to go back to the Overview dialog (i.e. what the "back" button would do)
  // because it reads "Cancel - Closes the window and returns to the overview."
  // In this case the "overview" is not the actual Overview dialog but the dialog
  // from which this DriverOptionsDialog was called i.e. BasicModifyDialog.
  // Therefore the button with the "abort" functionality is not shown at all
  // and the button with the "back" functionality is named "Cancel".
  // According to http://en.opensuse.org/YaST/Style_Guide#Single_Configuration.2FOverview.2FEdit_Dialog
  // the "finish" button in a single (step) configuration dialog must now be named "OK".
  Wizard::SetContentsButtons( // TRANSLATORS: Connection wizard header
                              _("Connection Wizard"),
                              contents,
                              HELPS["connection_wizard_dialog"]:"",
                              // Set a new label for the "back" button, see the comment above:
                              Label::CancelButton(),
                              // Set a new label for the "next" button, see the comment above:
                              Label::OKButton()
                            );
  Wizard::HideAbortButton();
  // Try to preselect an item which matches to the currently selected Device URI
  // from the previous "add queue" or "modify queue" dialogs or
  // which matches to the currently selected queue in the "overview" dialog.
  // But when the previous dialog was "printing via network"
  // there is no currently available Device URI.
  string current_device_uri = getCurrentDeviceURI();
  if( "" != current_device_uri )
  { if( "parallel:/" == substring( current_device_uri, 0, size( "parallel:/" ) ) )
    { UI::ChangeWidget( `tree_selection, `CurrentItem, `parallel );
      changeSettingsDialog( `parallel );
    }
    else if( "usb:/" == substring( current_device_uri, 0, size( "usb:/" ) ) )
    { UI::ChangeWidget( `tree_selection, `CurrentItem, `usb );
      changeSettingsDialog( `usb );
    }
    else if( "hp:/" == substring( current_device_uri, 0, size( "hp:/" ) ) )
    { UI::ChangeWidget( `tree_selection, `CurrentItem, `hplip );
      changeSettingsDialog( `hplip );
    }
    else if( "serial:/" == substring( current_device_uri, 0, size( "serial:/" ) ) )
    { UI::ChangeWidget( `tree_selection, `CurrentItem, `serial );
      changeSettingsDialog( `serial );
    }
    else if( "bluetooth:/" == substring( current_device_uri, 0, size( "bluetooth:/" ) ) )
    { UI::ChangeWidget( `tree_selection, `CurrentItem, `bluetooth );
      changeSettingsDialog( `bluetooth );
    }
    else if( "scsi:/" == substring( current_device_uri, 0, size( "scsi:/" ) ) )
    { UI::ChangeWidget( `tree_selection, `CurrentItem, `scsi );
      changeSettingsDialog( `scsi );
    }
    else if( "socket:/" == substring( current_device_uri, 0, size( "socket:/" ) ) )
    { UI::ChangeWidget( `tree_selection, `CurrentItem, `tcp );
      changeSettingsDialog( `tcp );
    }
    else if( "lpd:/" == substring( current_device_uri, 0, size( "lpd:/" ) ) )
    { // It is not possible to distinguish if a current_device_uri
      // belongs to the `lpr case (print via traditional UNIX server)
      // or to the `lpd case (access a network printer via LPD port)
      // because the Device URI is in both cases "lpd://server/queue".
      // Nevertheless a currently useless 'false' condition is implemented
      // to be prepared where to insert a reasonable condition
      // to distinguish the cases which may appear in the future.
      // Because access a network printer via LPD port happens more often
      // than print via traditional UNIX server, the first case is used
      // as fallback in any case here:
      if( false )
      { UI::ChangeWidget( `tree_selection, `CurrentItem, `lpr );
        changeSettingsDialog( `lpr );
      }
      else
      { UI::ChangeWidget( `tree_selection, `CurrentItem, `lpd );
        changeSettingsDialog( `lpd );
      }
    }
    else if( "ipp:/" == substring( current_device_uri, 0, size( "ipp:/" ) )
             || "http:/" == substring( current_device_uri, 0, size( "http:/" ) )
           )
    { // A Device URI to print via CUPS server has the form "ipp://server/printers/queue"
      // while a Device URI to access a network printer via IPP
      // does probably not contain "/printers/" so that this is used here
      // as a best effort attempt to distinguish both cases:
      if( issubstring( current_device_uri, "/printers/" ) )
      { UI::ChangeWidget( `tree_selection, `CurrentItem, `cups );
        changeSettingsDialog( `cups );
      }
      else
      { UI::ChangeWidget( `tree_selection, `CurrentItem, `ipp );
        changeSettingsDialog( `ipp );
      }
    }
    else if( "smb:/" == substring( current_device_uri, 0, size( "smb:/" ) ) )
    { UI::ChangeWidget( `tree_selection, `CurrentItem, `smb );
      changeSettingsDialog( `smb );
    }
    else if( "novell:/" == substring( current_device_uri, 0, size( "novell:/" ) ) )
    { UI::ChangeWidget( `tree_selection, `CurrentItem, `ipx );
      changeSettingsDialog( `ipx );
    }
    else if( "pipe:/" == substring( current_device_uri, 0, size( "pipe:/" ) ) )
    { UI::ChangeWidget( `tree_selection, `CurrentItem, `pipe );
      changeSettingsDialog( `pipe );
    }
    else if( "beh:/" == substring( current_device_uri, 0, size( "beh:/" ) ) )
    { UI::ChangeWidget( `tree_selection, `CurrentItem, `beh );
      changeSettingsDialog( `beh );
    }
    else
    { // Do nothing by default and as fallback.
    }
  }

boolean validateAndMakeURI( symbol selected )
{ boolean valid=false;
  connection_uri="";
  switch(selected)
  { case(`parallel):
    case(`usb):
    case(`hplip):
          integer selected_connection_index = (integer)UI::QueryWidget( `id(`connection_selection), `CurrentItem );
          if( nil == selected_connection_index )
          { Popup::AnyMessage( // Header of a Popup::AnyMessage when no connection was selected:
                               _("Select a connection"),
                               // Body of a Popup::AnyMessage when no connection was selected
                               // because there is no connection available to be selected:
                               _("If no connection is shown here, it is not possible\nto access the device via this type of connection.\nWas the printer connected and switched on all the time?")
                             );
            break;
          }
          if( selected_connection_index < 0 )
          { Popup::AnyMessage( // Header of a Popup::AnyMessage when an invalid connection was selected:
                               _("Select a valid connection"),
                               // Body of a Popup::AnyMessage when an invalid connection was selected
                               // because the current connection is no longer valid:
                               _("When the current connection is no longer valid,\nit does no longer work to access the device via this connection.\nIs the printer still connected and switched on?")
                             );
            break;
          }
          connection_uri = Printer::connections[selected_connection_index,"uri"]:"";
          connection_model = Printer::connections[selected_connection_index,"model"]:"Unknown";
          if( "" != connection_uri )
          { valid = true;
          }
          break;
    case(`serial):
          string serial_device_node = (string)UI::QueryWidget( `serial_device_node, `Value );
          string serial_baud_rate = (string)UI::QueryWidget( `serial_baud_rate, `Value );
          string serial_data_bits = (string)UI::QueryWidget( `serial_data_bits, `Value );
          string serial_parity = (string)UI::QueryWidget( `serial_parity, `Value );
          string serial_flow_control = (string)UI::QueryWidget( `serial_flow_control, `Value );
          string serial_stop_bits = (string)UI::QueryWidget( `serial_stop_bits, `Value );
          if( size( serial_device_node ) == 0
              || size( serial_baud_rate ) == 0
            )
          { Popup::Error( _("Serial device and baud rate could not be empty.") );
          }
          else
          { if( "space" == serial_parity && "7" != serial_data_bits )
            { Popup::Error( _("The 'space' parity checking is only supported with 7 data bits.") );
            }
            else
            { if( "mark" == serial_parity && ( "7" != serial_data_bits || "1" != serial_stop_bits ) )
              { Popup::Error( _("The 'mark' parity checking is only supported with 7 data bits and 1 stop bit.") );
              }
              else
              { connection_uri = "serial:" + serial_device_node + "?baud=" + serial_baud_rate;
                if( size( serial_data_bits ) > 0 )
                { connection_uri = connection_uri + "+bits=" + serial_data_bits;
                }
                if( size( serial_parity ) > 0 )
                { connection_uri = connection_uri + "+parity=" + serial_parity;
                }
                if( size( serial_flow_control ) > 0 )
                { connection_uri = connection_uri + "+flow=" + serial_flow_control;
                }
                if( size( serial_stop_bits ) > 0 )
                { connection_uri = connection_uri + "+stop=" + serial_stop_bits;
                }
                valid = true;
              }
            }
          }
          break;
    case(`bluetooth):
          string bluetooth_device_id = (string)UI::QueryWidget( `bluetooth_device_id, `Value );
          if( size( bluetooth_device_id ) == 0 )
          { Popup::Error( _("Bluetooth device ID could not be empty.") );
          }
          else
          { connection_uri = "bluetooth://" + bluetooth_device_id;
            valid = true;
          }
          break;
    case(`scsi):
          string scsi_device_node = (string)UI::QueryWidget( `scsi_device_node, `Value );
          if( size( scsi_device_node ) == 0 )
          { Popup::Error( _("SCSI generic device could not be empty.") );
          }
          else
          { // It would be wrong to do URIpercentEncoding(scsi_device_node)
            // because scsi_device_node is e.g. '/dev/sg1' which must stay as is
            // to result a valid 'scsi' URI like 'scsi:/dev/sg1':
            connection_uri = "scsi:" + scsi_device_node;
            valid = true;
          }
          break;
    case(`uri):
    case(`ipp):
          connection_uri = (string)UI::QueryWidget( `uri, `Value );
          if( size( connection_uri ) > 0 )
          { // It would be wrong to do URIpercentEncoding(connection_uri)
            // because special URI characters like ':' or '/' in connection_uri
            // must stay as is and not be percent encoded because only the values
            // of the URI parts must be percent encoded but not the whole URI.
            valid = true;
          }
          else
          { Popup::Error( _("URI could not be empty.") );
          }
          break;
    case(`smb):
          string smb_hostname = (string)UI::QueryWidget( `hostname, `Value );
          string smb_printer = (string)UI::QueryWidget( `printer, `Value );
          string smb_domain = (string)UI::QueryWidget( `domain, `Value );
          string smb_user = (string)UI::QueryWidget( `user, `Value );
          string smb_pass = (string)UI::QueryWidget( `pass, `Value );
          if( "" == filterchars( smb_hostname, Printer::alnum_chars )
              || "" == filterchars( smb_printer, Printer::alnum_chars )
            )
          { Popup::Error( _("Servername and printer could not be empty.") );
          }
          else
          { if( ( "" != filterchars( smb_user, Printer::alnum_chars )
                  && size( smb_pass ) < 1
                )
                || ( "" == filterchars( smb_user, Printer::alnum_chars )
                     && size( smb_pass ) > 0
                   )
              )
            { Popup::Error( _("Both user and password must be specified.") );
            }
            else
            { connection_uri = "smb://";
              if( "" != filterchars( smb_user, Printer::alnum_chars )
                  && size( smb_pass ) > 0
                )
              { connection_uri = sformat( "%1%2:%3@",
                                          connection_uri,
                                          URIpercentEncoding( smb_user ),
                                          URIpercentEncoding( smb_pass )
                                        );
              }
              if( "" != filterchars( smb_domain, Printer::alnum_chars ) )
              { connection_uri = sformat( "%1%2/",
                                          connection_uri,
                                          URIpercentEncoding( smb_domain )
                                        );
              }
              connection_uri = sformat( "%1%2/%3",
                                        connection_uri,
                                        URIpercentEncoding( smb_hostname ),
                                        URIpercentEncoding( smb_printer )
                                      );
              valid = true;
            }
          }
          break;
    case(`tcp):
          string tcp_hostname = (string)UI::QueryWidget( `hostname, `Value );
          string tcp_port = (string)UI::QueryWidget( `port_or_queue, `Value );
          string tcp_uri_options = (string)UI::QueryWidget( `uri_options, `Value );
          if( "" != filterchars( tcp_hostname, Printer::alnum_chars ) )
          { if( "" != filterchars( tcp_port, Printer::alnum_chars ) )
            { if( "" != filterchars( tcp_uri_options, Printer::alnum_chars ) )
              { // It would be wrong to do URIpercentEncoding(tcp_uri_options)
                // because special URI characters like '=' or '&' in tcp_uri_options
                // must stay as is and not be percent encoded because tcp_uri_options
                // contains all options like 'option1=value1&option2=value2'.
                connection_uri = sformat( "socket://%1:%2?%3",
                                          URIpercentEncoding( tcp_hostname ),
                                          URIpercentEncoding( tcp_port ),
                                          tcp_uri_options
                                        );
              }
              else
              { connection_uri = sformat( "socket://%1:%2",
                                          URIpercentEncoding( tcp_hostname ),
                                          URIpercentEncoding( tcp_port )
                                         );
              }
            }
            else
            { connection_uri = sformat( "socket://%1",
                                        URIpercentEncoding( tcp_hostname )
                                      );
            }
            valid = true;
          }
          else
          { Popup::Error( _("Servername could not be empty.") );
          }
          break;
    case(`lpd):
    case(`lpr):
          string lpd_hostname = (string)UI::QueryWidget( `hostname, `Value );
          if( ! issubstring( lpd_hostname, "@" ) )
          { // It would be wrong to do URIpercentEncoding(lpd_hostname)
            // when it contains a '@' because a lpd URI can be of the form
            //   lpd://username@ip-address-or-hostname/...
            // see https://bugzilla.novell.com/show_bug.cgi?id=512549
            lpd_hostname = URIpercentEncoding( lpd_hostname );
          }
          string lpd_queue = (string)UI::QueryWidget( `port_or_queue, `Value );
          string lpd_uri_options = (string)UI::QueryWidget( `uri_options, `Value );
          if( "" != filterchars( lpd_hostname, Printer::alnum_chars )
              && "" != filterchars( lpd_queue, Printer::alnum_chars )
            )
          { if( "" != filterchars( lpd_uri_options, Printer::alnum_chars ) )
            { // It would be wrong to do URIpercentEncoding(lpd_uri_options)
              // because special URI characters like '=' or '&' in lpd_uri_options
              // must stay as is and not be percent encoded because lpd_uri_options
              // contains all options like 'option1=value1&option2=value2'.
              connection_uri = sformat( "lpd://%1/%2?%3",
                                        lpd_hostname,
                                        URIpercentEncoding( lpd_queue ),
                                        lpd_uri_options
                                      );
            }
            else
            { connection_uri = sformat( "lpd://%1/%2",
                                        lpd_hostname,
                                        URIpercentEncoding( lpd_queue )
                                      );
            }
            valid=true;
          }
          else
          { Popup::Error( _("Servername and queue name could not be empty.") );
          }
          break;
    case(`cups):
          string cups_hostname = (string)UI::QueryWidget( `hostname, `Value );
          if( ! issubstring( cups_hostname, "@" ) )
          { // It would be wrong to do URIpercentEncoding(cups_hostname)
            // when it contains a '@' because a ipp/http URI can be of the form
            //   ipp://username:password@ip-address-or-hostname/...
            //   http://username:password@ip-address-or-hostname/...
            // see https://bugzilla.novell.com/show_bug.cgi?id=512549
            cups_hostname = URIpercentEncoding( cups_hostname );
          }
          string cups_queue = (string)UI::QueryWidget( `queue, `Value );
          string cups_uri_options = (string)UI::QueryWidget( `uri_options, `Value );
          if( "" != filterchars( cups_hostname, Printer::alnum_chars )
              && "" != filterchars( cups_queue, Printer::alnum_chars )
            )
          { if( "" != filterchars( cups_uri_options, Printer::alnum_chars ) )
            { // It would be wrong to do URIpercentEncoding(cups_uri_options)
              // because special URI characters like '=' or '&' in cups_uri_options
              // must stay as is and not be percent encoded because cups_uri_options
              // contains all options like 'option1=value1&option2=value2'.
              connection_uri = sformat( "ipp://%1/printers/%2?%3",
                                        cups_hostname,
                                        URIpercentEncoding( cups_queue ),
                                        cups_uri_options
                                      );
            }
            else
            { connection_uri = sformat( "ipp://%1/printers/%2",
                                        cups_hostname,
                                        URIpercentEncoding( cups_queue )
                                      );
            }
            valid=true;
          }
          else
          { Popup::Error( _("Servername and queue name could not be empty.") );
          }
          break;
    case(`ipx):
          string ipx_hostname = (string)UI::QueryWidget( `hostname, `Value );
          string ipx_queue = (string)UI::QueryWidget( `queue, `Value );
          string ipx_user = (string)UI::QueryWidget( `user, `Value );
          string ipx_pass = (string)UI::QueryWidget( `pass, `Value );
          if( "" != filterchars( ipx_hostname, Printer::alnum_chars )
              && "" != filterchars( ipx_queue, Printer::alnum_chars )
            )
          { connection_uri = "novell://";
            if( "" != filterchars( ipx_user, Printer::alnum_chars )
                && size( ipx_pass ) > 0
              )
            { connection_uri = sformat( "%1%2:%3@", connection_uri, ipx_user, ipx_pass );
            }
            connection_uri = sformat("%1%2/%3", connection_uri, ipx_hostname, ipx_queue );
            valid=true;
          }
          else
          { Popup::Error( _("Servername and queue name could not be empty.") );
          }
          break;
    case(`beh):
          string beh_original_uri = (string)UI::QueryWidget( `beh_original_uri, `Value );
          boolean beh_do_not_disable = (boolean)UI::QueryWidget( `beh_do_not_disable, `Value );
          string beh_attempts = (string)UI::QueryWidget( `beh_attempts, `Value );
          string beh_delay = (string)UI::QueryWidget( `beh_delay, `Value );
          if( "" != filterchars( beh_original_uri, Printer::alnum_chars )
              && "" != filterchars( beh_attempts, Printer::alnum_chars )
              && "" != filterchars( beh_delay, Printer::alnum_chars )
            )
          { connection_uri = sformat( "beh:/%1/%2/%3/%4",
                                      ( beh_do_not_disable ? "1" : "0" ),
                                      beh_attempts,
                                      beh_delay,
                                      beh_original_uri
                                    );
            valid = true;
          }
          else
          { Popup::Error( _("Device URI, number of retries, and delay could not be empty." ) );
          }
          break;
    case(`pipe):
          string pipe = (string)UI::QueryWidget( `program, `Value );
          if( "" != filterchars( pipe, Printer::alnum_chars ) )
          { // It would be wrong to do URIpercentEncoding(pipe)
            // because special URI characters like '/ ? = &' in pipe
            // must stay as is and not be percent encoded because pipe
            // contains all like 'path/to/command?option1=value1&option2=value2'
            connection_uri = sformat( "pipe:/%1", pipe );
            valid = true;
          }
          else
          { Popup::Error( _("Could not be empty.") );
          }
          break;
    default:
          y2warning( "validateAndMakeURI unknown selected value: '%1'", selected );
          break;
  }
  if( ! valid )
  { connection_uri="";
  }
  return valid;
}

boolean validateModel( symbol selected )
{ switch(selected)
  { case(`parallel):
    case(`usb):
    case(`hplip):
          break;
    case(`serial):
    case(`bluetooth):
    case(`scsi):
    case(`uri):
    case(`ipp):
    case(`smb):
    case(`tcp):
    case(`lpd):
    case(`lpr):
    case(`cups):
    case(`ipx):
    case(`beh):
    case(`pipe):
          connection_model = (string)UI::QueryWidget( `id("manufacturers_combo_box"), `Value );
          if( "" == connection_model )
          { // Popup::Error message when neither a manufacturer nor 'Raw Queue' was selected.
            // Do not change or translate "raw", it is a technical term
            // when no driver is used for a print queue.
            Popup::Error( _("Select a manufacturer or 'raw queue'.") );
            return false;
          }
          break;
    default:
          y2warning( "validateModel unknown selected value: '%1'", selected );
          break;
  }
  return true;
}

void scanForServers( symbol selected, boolean all )
{ list<string> hosts = [];
  string current_host = (string)UI::QueryWidget( `hostname, `Value );
  if( all )
  { y2milestone( "scanForServers 'all'" );
    Popup::ShowFeedback( // Title for a Popup::ShowFeedback:
                         _("Look up all hosts in the local network"),
                         // Body of a Popup::ShowFeedback:
                         _("Please wait...\nThis could take more than a minute.")
                       );
    hosts = (list<string>)SCR::Read(.net.hostnames);
    // Sleep half a second to let the user notice the Popup::ShowFeedback in any case
    // before it is removed even when the above SCR::Read finished immediately:
    sleep( 500 );
    Popup::ClearFeedback();
  }
  else
  { y2milestone( "scanForServers selected = '%1'", selected );
    switch(selected)
    { case(`tcp):
            string port = (string)UI::QueryWidget( `port_or_queue, `Value );
            if( "" == port )
            { port = "9100";
              UI::ChangeWidget( `port_or_queue, `Value, "9100" );
            }
            Popup::ShowFeedback( // Title for a Popup::ShowFeedback
                                 // where %1 will be replaced by the port number:
                                 sformat( _("Scan for hosts which are accessible via TCP port %1"), port ),
                                 // Body of a Popup::ShowFeedback:
                                 _("Please wait...\nThis could take more than a minute.")
                               );
            hosts = (list<string>)SCR::Read(.net.hostnames, tointeger(port));
            // Sleep half a second to let the user notice the Popup::ShowFeedback in any case
            // before it is removed even when the above SCR::Read finished immediately:
            sleep( 500 );
            Popup::ClearFeedback();
            break;
      case(`smb):
            Popup::ShowFeedback( // Title for a Popup::ShowFeedback:
                                 _("Scan for hosts which are accessible via Samba (SMB)"),
                                 // Body of a Popup::ShowFeedback:
                                 _("Please wait...\nThis could take more than a minute.")
                               );
            hosts = (list<string>)SCR::Read(.net.hostnames.samba);
            // Sleep half a second to let the user notice the Popup::ShowFeedback in any case
            // before it is removed even when the above SCR::Read finished immediately:
            sleep( 500 );
            Popup::ClearFeedback();
            break;
      case(`lpr):
      case(`lpd):
            Popup::ShowFeedback( // Title for a Popup::ShowFeedback:
                                 _("Scan for hosts which are accessible via port 515 (LPD/LPR)"),
                                 // Body of a Popup::ShowFeedback:
                                 _("Please wait...\nThis could take more than a minute.")
                               );
            hosts = (list<string>)SCR::Read(.net.hostnames, 515);
            // Sleep half a second to let the user notice the Popup::ShowFeedback in any case
            // before it is removed even when the above SCR::Read finished immediately:
            sleep( 500 );
            Popup::ClearFeedback();
            break;
      case(`cups):
      case(`ipp):
            Popup::ShowFeedback( // Title for a Popup::ShowFeedback:
                                 _("Scan for hosts which are accessible via port 631 (CUPS/IPP)"),
                                 // Body of a Popup::ShowFeedback:
                                 _("Please wait...\nThis could take more than a minute.")
                               );
            hosts = (list<string>)SCR::Read(.net.hostnames, 631);
/*
            hosts = (list<string>)filter (string h, hosts, ``{
                list queues = (list<string>)SCR::Read (.cups.remote, h);
                return size (queues) > 0;
            });
*/
            // Sleep half a second to let the user notice the Popup::ShowFeedback in any case
            // before it is removed even when the above SCR::Read finished immediately:
            sleep( 500 );
            Popup::ClearFeedback();
            break;
      default:
            y2warning( "scanForServers unknown selected value: '%1'", selected );
    }
  }
  y2milestone( "scanForServers hosts = '%1'", hosts );
  if( size( hosts ) < 1 )
  { Popup::Message( // Popup::Message when scanning for hosts in the network did not find any host.
                    _("Scanning in the network did not find any host.\n(Network issue or firewall active?)")
                  );
    hosts = [ current_host ];
  }
  if( ! contains( hosts, current_host ) )
  { hosts = prepend( hosts, current_host );
  }
  UI::ChangeWidget( `hostname, `Items, hosts );
  UI::ChangeWidget( `hostname, `Value, current_host );
}

boolean testQueue( symbol selected )
{ string test_command = "";
  string timeout = "5";
  string host = "";
  string port = "";
  string queue = "";
  string workgroup = "";
  string user = "";
  string password = "";
  switch(selected)
  { case(`tcp):
          host = (string)UI::QueryWidget( `hostname, `Value );
          port = (string)UI::QueryWidget( `port_or_queue, `Value );
          test_command = sformat( "%1test_remote_socket \"%2\" \"%3\" %4",
                                  Printerlib::yast_bin_dir,
                                  host,
                                  port,
                                  timeout
                                );
          if( ! Printerlib::ExecuteBashCommand( test_command ) )
          { Popup::ErrorDetails( sformat( // Message of a Popup::ErrorDetails
                                          // where %1 will be replaced by the port number
                                          // and %2 will be replaced by the host name:
                                          _("Access test failed for port '%1' on host '%2'."),
                                          port,
                                          host
                                        ),
                                 Printerlib::result["stderr"]:"" + "\n" + Printerlib::result["stdout"]:""
                               );
            return false;
          }
          break;
    case(`lpd):
    case(`lpr):
          host = (string)UI::QueryWidget( `hostname, `Value );
          queue = (string)UI::QueryWidget( `port_or_queue, `Value );
          port = "515";
          test_command = sformat( "%1test_remote_lpd \"%2\" \"%3\" %4",
                                  Printerlib::yast_bin_dir,
                                  host,
                                  queue,
                                  timeout
                                );
          if( ! Printerlib::ExecuteBashCommand( test_command) )
          { Popup::ErrorDetails( sformat( // Message of a Popup::ErrorDetails
                                          // where %1 will be replaced by the queue name
                                          // and %2 will be replaced by the host name:
                                          _("Access test failed for queue '%1' on host '%2'."),
                                          queue,
                                          host
                                        ),
                                 Printerlib::result["stderr"]:"" + "\n" + Printerlib::result["stdout"]:""
                               );
            return false;
          }
          break;
    case(`cups):
          host = (string)UI::QueryWidget( `hostname, `Value );
          queue = (string)UI::QueryWidget( `queue, `Value );
          test_command = sformat( "%1test_remote_ipp \"%2\" \"%3\" %4",
                                  Printerlib::yast_bin_dir,
                                  host,
                                  queue,
                                  timeout
                                );
          if( ! Printerlib::ExecuteBashCommand( test_command) )
          { Popup::ErrorDetails( sformat( // Message of a Popup::ErrorDetails
                                          // where %1 will be replaced by the queue name
                                          // and %2 will be replaced by the host name:
                                          _("Access test failed for queue '%1' on host '%2'."),
                                          queue,
                                          host
                                        ),
                                 Printerlib::result["stderr"]:"" + "\n" + Printerlib::result["stdout"]:""
                               );
            return false;
          }
          break;
    case(`smb):
          host = (string)UI::QueryWidget( `hostname, `Value );
          queue = (string)UI::QueryWidget( `printer, `Value );
          workgroup = (string)UI::QueryWidget( `domain, `Value );
          user = (string)UI::QueryWidget( `user, `Value );
          password = (string)UI::QueryWidget( `pass, `Value );
          test_command = sformat( "%1test_remote_smb \"%2\" \"%3\" \"%4\" \"%5\" \"%6\" %7",
                                  Printerlib::yast_bin_dir,
                                  workgroup,
                                  host,
                                  queue,
                                  user,
                                  password,
                                  timeout
                                );
          if( ! Printerlib::ExecuteBashCommand( test_command) )
          { Popup::ErrorDetails( sformat( // Message of a Popup::ErrorDetails
                                          // where %1 will be replaced by the SMB share name
                                          // and %2 will be replaced by the host name:
                                          _("Access test failed for share '%1' on host '%2'."),
                                          queue,
                                          host
                                        ),
                                 Printerlib::result["stderr"]:"" + "\n" + Printerlib::result["stdout"]:""
                               );
            return false;
          }
          break;
    case(`ipx):
          host = (string)UI::QueryWidget( `hostname, `Value );
          queue = (string)UI::QueryWidget( `queue, `Value );
          user = (string)UI::QueryWidget( `user, `Value );
          password = (string)UI::QueryWidget( `pass, `Value );
          test_command = sformat( "%1test_remote_novell \"%2\" \"%3\" \"%4\" \"%5\" %6",
                                  Printerlib::yast_bin_dir,
                                  host,
                                  queue,
                                  user,
                                  password,
                                  timeout
                                );
          if( ! Printerlib::ExecuteBashCommand( test_command) )
          { Popup::ErrorDetails( sformat( // Message of a Popup::ErrorDetails
                                          // where %1 will be replaced by the queue name
                                          // and %2 will be replaced by the host name:
                                          _("Access test failed for queue '%1' on host '%2'."),
                                          queue,
                                          host
                                        ),
                                 Printerlib::result["stderr"]:"" + "\n" + Printerlib::result["stdout"]:""
                               );
            return false;
          }
          break;
  }
  Popup::Message( _("Test OK") );
  return true;
}

boolean UpdateConnectionsList( symbol selected )
{ if( "" == connection_uri )
  { return false;
  }
  if( "" == connection_model )
  { connection_model = "Unknown";
  }
  // Avoid duplicate URIs because Printer::current_device_uri must point to a unique URI
  // otherwise preselection in BasicAddDialog and BasicModifyDialog would be ambiguous.
  // If an URI already exists, update its matching entry in the Printer::connections list.
  // Usually there should not exist duplicate URIs in the Printer::connections list
  // (in contrast duplicate URIs in the Printer::queues list are perfectly o.k.)
  // but if duplicate URIs exist in Printer::connections, all those entries are updated.
  boolean uri_already_exists = false;
  // I do not know if it is allowed to modify one same list "in place" via foreach like:
  //   list < string > words = [ "Jane", "World", "John" ];
  //   integer index = -1;
  //   foreach( string word,
  //            words,
  //            { index = index + 1;
  //              if( "World" == word )
  //              { words[index] = "Hello " + word;
  //              }
  //            }
  //          );
  // so that in any case the result words == [ "Jane", "Hello World", "John" ]
  // and therefore I prefer to be on the safe side with maplist
  // which might consume unnecessarily much memory and CPU
  // (maplist has two lists and all elements are at least copied
  //  instead of "in place" modification only where needed via foreach)
  // but for my small lists this does actually not matter:
  Printer::connections = maplist( map< string, string > connection_entry,
                                  Printer::connections,
                                  { if( connection_uri == connection_entry["uri"]:"" )
                                    { uri_already_exists = true;
                                      y2internal( "UpdateConnectionsList: modify connections list type '%1' with uri '%2' for model '%3'", selected, connection_uri, connection_model );
                                      return $[ "uri" : connection_uri,
                                                "model" : connection_model,
                                                "deviceID" : "",
                                                "info" : "modified by the connection wizard",
                                                "class" : "ConnectionWizardDialog"
                                              ];
                                    }
                                    else
                                    { return connection_entry;
                                    }
                                  }
                                );
  if( ! uri_already_exists )
  { y2internal( "UpdateConnectionsList: adding connection type '%1' with uri '%2' for model '%3'", selected, connection_uri, connection_model );
    Printer::connections = add( Printer::connections,
                                $[ "uri" : connection_uri,
                                   "model" : connection_model,
                                   "deviceID" : "",
                                   "info" : "created by the connection wizard",
                                   "class" : "ConnectionWizardDialog"
                                 ]
                              );
  }
  // Set Printer::current_device_uri so that BasicAddDialog and BasicModifyDialog
  // can preselect the currently used connection when calling Printer::ConnectionItems(...)
  // which sets Printer::selected_connections_index if it matches to Printer::current_device_uri.
  // It makes sense to have the currently used connection from the ConnectionWizardDialog
  // preselected also in BasicModifyDialog because when the user launched the Connection Wizard
  // from the BasicModifyDialog he wants to change the connection so that it is sufficiently safe
  // to have the changed connection preselected when he is back in the BasicModifyDialog
  // so that the connection would get changed in the system without explicite selection
  // by the user in the BasicModifyDialog if the user clicks "OK" in the BasicModifyDialog.
  Printer::current_device_uri = connection_uri;
  return true;
}

//UI::OpenDialog(content);
any ret = nil;
while( ret != `back && ret != `next )
{ ret = UI::UserInput();
  symbol selected = (symbol)UI::QueryWidget( `tree_selection, `Value );
  y2milestone( "ConnectionWizardDialog selected = '%1'", selected );
  switch( (symbol)ret )
  { case(`tree_selection):
          changeSettingsDialog( selected );
          break;
    case(`next):
          if( validateAndMakeURI( selected )
              && validateModel( selected )
            )
          { y2milestone( "ConnectionWizardDialog writing settings" );
            UpdateConnectionsList( selected );
          }
          else
          { y2error( "ConnectionWizardDialog: Could not validate for '%1'", selected );
            ret=nil;
          }
          break;
    case(`scan_all):
          scanForServers( selected, true );
          break;
    case(`scan):
          scanForServers( selected, false );
          break;
    case(`test):
          if( validateAndMakeURI( selected ) )
          { testQueue( selected );
          }
          break;
    y2internal( "ret %1", ret );
  }
}
return ret;
//UI::CloseDialog();
}
}

