/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:        include/printer/policies.ycp
 * Package:     Configuration of printer
 * Summary:     DefaultPolicy and ErrorPolicy settings in cupsd.conf
 * Authors:     Johannes Meixner <jsmeix@suse.de>
 *
 * $Id: policies.ycp 27914 2006-02-13 14:32:08Z locilka $
 */

{

textdomain "printer";

import "Printerlib";
import "Printer";
import "Popup";

include "printer/helps.ycp";

string initial_operation_policy = "default";
// An entry for a ComboBox from which the user can select that the CUPS error policy
// which is used when it fails to send a job to the printer is to
// stop the printer and keep the job for future printing:
string error_policy_stop_printer_string = _("stop the printer and keep the job for future printing");
// An entry for a ComboBox from which the user can select that the CUPS error policy
// which is used when it fails to send a job to the printer is to
// re-send the job from the beginning after waiting some time
// (the default JobRetryInterval is 30 seconds but this can be changed):
string error_policy_retry_job_string = _("re-send the job from the beginning after waiting some time");
// An entry for a ComboBox from which the user can select that the CUPS error policy
// which is used when it fails to send a job to the printer is to
// abort and delete the job and proceed with the next job:
string error_policy_abort_job_string = _("abort and delete the job and proceed with the next job");
string initial_error_policy = "stop-printer";

// Have the error policy stuff first because this is of more importance for a normal user.
// Normal users may like to change the CUPS upstream default "stop-printer" error policy
// to "abort-job" because is often more convenient for a workstation with local printers
// when a failing print job is simply removed instead of having the whole queue disabled
// and get the failed job re-printed when the queue becomes re-enabled at any time later.
// In contrast normal users should usually not change the CUPS upstream default
// operation policy "default" to something else because other operation policies
// are either less secure or too secure for usual printing operation.
term widgetPolicies = `VBox
                      ( `VStretch(),
                        `Left
                        ( `ComboBox
                          ( `id("error_policy"),
                            // Header for a ComboBox to specify the CUPS error policy:
                            _("Specify the &error policy"),
                            [ `item( `id("stop-printer"), error_policy_stop_printer_string ),
                              `item( `id("retry-job"), error_policy_retry_job_string ),
                              `item( `id("abort-job"), error_policy_abort_job_string )
                            ]
                          )
                        ),
                        `Left
                        ( `CheckBox
                          ( `id("apply_error_policy"),
                            // CheckBox to apply the CUPS error policy which is selected in the ComboBox above
                            // to all local printer configurations (i.e. to all local print queues).
                            // When possible we perefer to use the wording "printer configuration"
                            // instead of "print queue" because the latter may sound too technical
                            // but sometimes (e.g. in the Connection Wizard) we must use the exact technical term:
                            _("&Apply this error policy to all local printer configurations")
                          )
                        ),
                        `VStretch(),
                        `Left
                        ( `ComboBox
                          ( `id("operation_policy"),
                            // Header for a ComboBox to specify the CUPS operation policy:
                            _("Specify the &operation policy"),
                            [""]
                          )
                        ),
                        `Left
                        ( `CheckBox
                          ( `id("apply_operation_policy"),
                            // CheckBox to apply the CUPS operation policy which is selected in the ComboBox above
                            // to all local printer configurations (i.e. to all local print queues).
                            // When possible we perefer to use the wording "printer configuration"
                            // instead of "print queue" because the latter may sound too technical
                            // but sometimes (e.g. in the Connection Wizard) we must use the exact technical term:
                            _("Apply this operation &policy to all local printer configurations")
                          )
                        ),
                        `VStretch()
                      );

void initPolicies( string key )
{ y2milestone( "entering initPolicies with key '%1'", key );
  // Note that the "Policies" dialog is not useless when there is no local queue.
  // For example the user may like to configure the "Policies" before he set up the first local queue.
  boolean policies_dialog_is_useless = false;
  // Determine whether or not it is currently a real client-only config
  // (i.e. a ServerName != "localhost/127.0.0.1" in /etc/cups/client.conf)
  // and ignore when it fails (i.e. use the fallback value silently):
  Printerlib::DetermineClientOnly();
  if( Printerlib::client_only )
  { if( ! Popup::YesNoHeadline( sformat( // PopupYesNoHeadline headline
                                         // where %1 will be replaced by the server name:
                                         _("Disable remote CUPS server '%1'"),
                                         Printerlib::client_conf_server_name
                                       ),
                                // PopupYesNoHeadline body:
                                _("A remote CUPS server setting conflicts with setting policies for the local system.")
                              )
      )
    { policies_dialog_is_useless = true;
      y2milestone( "policies_dialog_is_useless because user decided not to disable client-only CUPS server '%1'",
                   Printerlib::client_conf_server_name
                 );
    }
    else
    { // Remove the 'ServerName' entry in /etc/cups/client.conf:
      if( ! Printerlib::ExecuteBashCommand( Printerlib::yast_bin_dir + "cups_client_only none" ) )
      { Popup::ErrorDetails( // Popup::ErrorDetails message:
                             _("Failed to remove the 'ServerName' entry in /etc/cups/client.conf"),
                             Printerlib::result["stderr"]:"" + "\n" + Printerlib::result["stdout"]:""
                           );
        policies_dialog_is_useless = true;
        y2milestone( "policies_dialog_is_useless because it failed to disable client-only CUPS server '%1'",
                     Printerlib::client_conf_server_name
                   );
      }
    }
  }
  // When it is no "client-only" config,
  // determine whether or not a local cupsd is accessible:
  if( ! policies_dialog_is_useless )
  {if( ! Printerlib::GetAndSetCupsdStatus( "" ) )
    { // Printerlib::GetAndSetCupsdStatus already shows a confirmation popup:
      if( ! Printerlib::GetAndSetCupsdStatus( "start" ) )
      { policies_dialog_is_useless = true;
        y2milestone( "policies_dialog_is_useless because 'rccups start' failed." );
      }
    }
  }
  // Determine the existing policy names in '<Policy policy-name>' sections in /etc/cups/cupsd.conf:
  list< string > policy_names = [ "" ];
  if( Printerlib::ExecuteBashCommand( Printerlib::yast_bin_dir + "modify_cupsd_conf Policies" ) )
  { // The command outputs a line where multiple policy names are separated by space
    // but possible duplicate policy names are not removed in the command output:
    policy_names = toset( splitstring( Printerlib::result["stdout"]:"", " " ) );
  }
  else
  { // Use fallback value when the command above failed:
    policy_names = [ "default" ];
  }
  // Determine the DefaultPolicy in /etc/cups/cupsd.conf:
  if( Printerlib::ExecuteBashCommand( Printerlib::yast_bin_dir + "modify_cupsd_conf DefaultPolicy" ) )
  { // The command outputs a line where multiple DefaultPolicy entries are separated by space
    // but possible duplicate policy names are not removed in the command output.
    // Multiple DefaultPolicy entries are a broken config but it can happen
    // and in this case the first DefaultPolicy entry is used:
    initial_operation_policy = splitstring( Printerlib::result["stdout"]:"", " " )[0]:"default";
  }
  else
  { // Use fallback value when the command above failed:
    initial_operation_policy = "default";
  }
  // Use only the plain strings in the policy_names list without an id
  // for the operation_policy ComboBox:
  UI::ChangeWidget( `id("operation_policy"), `Items, policy_names );
  // Have the initial_operation_policy preselected:
  UI::ChangeWidget( `id("operation_policy"), `Value, initial_operation_policy );
  // Have the CheckBox to apply the operation policy to all local print queues
  // un-checked in any case:
  UI::ChangeWidget( `id("apply_operation_policy"), `Value, false );
  // Determine the ErrorPolicy in /etc/cups/cupsd.conf:
  if( Printerlib::ExecuteBashCommand( Printerlib::yast_bin_dir + "modify_cupsd_conf ErrorPolicy" ) )
  { // The command outputs a line where multiple ErrorPolicy entries are separated by space
    // but possible duplicate policy names are not removed in the command output.
    // Multiple ErrorPolicy entries are a broken config but it can happen
    // and in this case the first ErrorPolicy entry is used:
    initial_error_policy = splitstring( Printerlib::result["stdout"]:"", " " )[0]:"stop-printer";
  }
  else
  { // Use fallback value when the command above failed:
    initial_error_policy = "stop-printer";
  }
  // Have the initial_error_policy preselected:
  UI::ChangeWidget( `id("error_policy"), `Value, `id(initial_error_policy) );
  // Have the CheckBox to apply the error policy to all local print queues
  // un-checked in any case:
  UI::ChangeWidget( `id("apply_error_policy"), `Value, false );
  if( policies_dialog_is_useless )
  { UI::ChangeWidget( `id("operation_policy"), `Enabled, false );
    UI::ChangeWidget( `id("apply_operation_policy"), `Enabled, false );
    UI::ChangeWidget( `id("error_policy"), `Enabled, false );
    UI::ChangeWidget( `id("apply_error_policy"), `Enabled, false );
  }
  y2milestone( "leaving initPolicies with\ninitial_operation_policy = '%1'\ninitial_error_policy = '%2'", initial_operation_policy, initial_error_policy );
}

boolean ApplyPoliciesSettings()
{ boolean applied_policies = true;
  // Get the actual settings and values from the dialog:
  string current_operation_policy = (string)UI::QueryWidget( `id("operation_policy"), `Value );
  boolean apply_operation_policy = (boolean)UI::QueryWidget( `id("apply_operation_policy"), `Value );
  y2milestone( "current_operation_policy: '%1' apply it to all local queues: '%2'", current_operation_policy, apply_operation_policy );
  string current_error_policy = (string)UI::QueryWidget( `id("error_policy"), `Value );
  boolean apply_error_policy = (boolean)UI::QueryWidget( `id("apply_error_policy"), `Value );
  y2milestone( "current_error_policy: '%1' apply it to all local queues: '%2'", current_error_policy, apply_error_policy );
  if( current_operation_policy == initial_operation_policy
      && current_error_policy == initial_error_policy
      && ! apply_operation_policy
      && ! apply_error_policy
    )
  { y2milestone( "Nothing changed in 'Policies' dialog." );
    y2milestone( "leaving storePolicies" );
    return true;
  }
  if( apply_operation_policy
      || apply_error_policy
    )
  { // When the module is started, the Overview dialog is shown in any case.
    // The Overview dialog is also shown in any case after a queue was added.
    // Finally the Overview dialog is re-run (with a re-created list of queues) via the sequencer
    // after a queue was deleted.
    // The Overview dialog calls Printer::QueueItems which calls AutodetectQueues so that
    // the queues have been already autodetected and the Printer::queues list is up to date.
    // so that there is no need to call Printer::AutodetectQueues here again.
    foreach( map< string, string > queue,
             Printer::queues,
             { string name = queue["name"]:"";
               if( "" == filterchars( name, Printer::alnum_chars ) )
               { // Ignore an effectively empty queue name:
                 continue;
               }
               string commandline = "/usr/sbin/lpadmin -h localhost -p '" + name + "'";
               if( apply_operation_policy )
               { commandline = commandline + " -o 'printer-op-policy=" + current_operation_policy + "'";
               }
               if( apply_error_policy )
               { commandline = commandline + " -o 'printer-error-policy=" + current_error_policy + "'";
               }
               if( ! Printerlib::ExecuteBashCommand( commandline ) )
               { Popup::ErrorDetails( sformat( // Popup::ErrorDetails message
                                               // where %1 will be replaced by the print queue name.
                                               _("Failed to apply the policy to '%1'"),
                                               name
                                             ),
                                      Printerlib::result["stderr"]:""
                                    );
                 applied_policies = false;
               }
             }
           );
  }
  if( current_operation_policy != initial_operation_policy )
  { if( ! Printerlib::ExecuteBashCommand( Printerlib::yast_bin_dir + "modify_cupsd_conf DefaultPolicy " + current_operation_policy ) )
    { Popup::ErrorDetails( sformat( // Popup::ErrorDetails message
                                    // where %1 will be replaced by the default operation policy value.
                                    // Do not change or translate "DefaultPolicy", it is a system settings name.
                                    _("Failed to set 'DefaultPolicy %1' in /etc/cups/cupsd.conf"),
                                    current_operation_policy
                                  ),
                           Printerlib::result["stderr"]:""
                         );
      applied_policies = false;
    }
  }
  if( current_error_policy != initial_error_policy )
  { if( ! Printerlib::ExecuteBashCommand( Printerlib::yast_bin_dir + "modify_cupsd_conf ErrorPolicy " + current_error_policy ) )
    { Popup::ErrorDetails( sformat( // Popup::ErrorDetails message
                                    // where %1 will be replaced by the default error policy value.
                                    // Do not change or translate "ErrorPolicy", it is a system settings name.
                                    _("Failed to set 'ErrorPolicy %1' in /etc/cups/cupsd.conf"),
                                    current_error_policy
                                  ),
                           Printerlib::result["stderr"]:""
                         );
      applied_policies = false;
    }
  }
  // Restart a local cupsd only if a policy in /etc/cups/cupsd.conf was changed:
  if( current_operation_policy != initial_operation_policy
      || current_error_policy != initial_error_policy
    )
  { // If a local cupsd is accessible, restart it,
    // otherwise do nothing (i.e. do not start it now):
    if( Printerlib::GetAndSetCupsdStatus( "" ) )
    { if( ! Printerlib::GetAndSetCupsdStatus( "restart" ) )
      { applied_policies = false;
      }
    }
  }
  y2milestone( "leaving storePolicies" );
  return applied_policies;
}

symbol handlePolicies( string key, map event )
{ y2milestone( "entering handlePolicies with key '%1'\nand event '%2'", key, event );
  if( "Activated" == event["EventReason"]:"" )
  { if( `abort == event["ID"]:nil || `cancel == event["ID"]:nil || `back == event["ID"]:nil )
    { // There is no "abort" functionality which does a sudden death of the whole module.
      // There is only a "Cancel" functionality (via the "back" button) which goes back one step
      // and the button with the "abort" functionality is not shown at all (see dialogs.ycp).
      // Unfortunately when the YaST package installer is run via Printerlib::TestAndInstallPackage
      // it leaves a misused "abort" button labeled "Skip Autorefresh" with WidgetID "`abort"
      // so that this case is mapped to the "Cancel" functionality:
      return `policies_back;
    }
    if( `next == event["ID"]:nil )
    { if( ! ApplyPoliciesSettings() )
      { Popup::Error( // Popup::Error message:
                      _("Failed to apply the settings to the system.")
                    );
      }
      return `policies_next;
    }
  }
  return nil;
}

/* EOF */
}
