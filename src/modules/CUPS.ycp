/**
 * File:
 *   modules/CUPS.ycp
 *
 * Package:
 *   Printer configuration
 *
 * Summary:
 *   Data and functions related only to CUPS
 *
 * Authors:
 *   Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 * Printer library exported functions. What else?!?
 */

{
    module "CUPS";

    textdomain "printer";

    import "Label";

// local variables




// global variables

    /**
      * List of detected CUPS servers
      */
    global list<string> cups_servers = [];

    /**
      * Use CUPS-like USB devices names
      * `always, `never, `serial
      */
    global symbol usb_dev_names = `always;

    /**
      * Type of cups installation.
      * nil: unknown
      * `server:  server
      * `client: client
      */
    global symbol cups_installation = nil;

    /**
     * If this is only cups client station,
     * server host name is here.
     */
    global string server_hostname = "";

    /**
      * Settings of CUPS server
      */
    global map<string,list<string> > cups_server_settings = nil;

    /**
      * Settings of CUPS server
      */
    global map<string,map<string, list<string> > > cups_server_permissions = nil;

    /**
      * When configuring client, using server's default queue?
      */
    global boolean server_default = true;

// local functions

// global functions

    /**
     * Read client.conf host name to server_hostname
     */
    global define void loadClientHostName () ``{
	server_hostname = (string)
	    SCR::Read (.etc.cups.client_conf.value.ServerName);
/*
        // grep /etc/cups/client.conf for ServerName
        server_hostname = "";
        map e = (map)SCR::Execute (.target.bash_output, "/usr/bin/awk '/^ServerName/ { print $2 }' /etc/cups/client.conf");
        if (0 == lookup (e, "exit", 1))
        {
            server_hostname = select (splitstring (lookup (e, "stdout", ""), "\n"), 0, "");*/
            if (nil == server_hostname || "" == server_hostname || "nil" == server_hostname ||
                "localhost" == server_hostname || "127.0.0.1" == server_hostname)
                server_hostname = "";
//	}
	y2milestone ("Read server host name: >>%1<<", server_hostname);
    }

    /**
      * If only client is installed or remote server to use is set,
      * returns 1, if this is real server installation, returns 0
      * Also sets server_hostname and cups_installation
      * @return symbol `client or `server
      */
    global define symbol InstallationType () ``{
        if (nil != cups_installation)
            return cups_installation;

        if (Pkg::IsProvided ("cups-libs") &&
            !Pkg::IsProvided ("cups"))
        {
            loadClientHostName ();
            cups_installation = `client;
            return `client;
        }
        loadClientHostName ();
        cups_installation = (("" != server_hostname) ? `client : `server);
        return cups_installation;
    }

    /**
     * Save client.conf host name host name
     * @return boolean true on success
     */
    global define boolean saveClientHostName () ``{
	boolean ret = true;
	if (server_hostname == "")
	    server_hostname = nil;
	SCR::Write (.etc.cups.client_conf.value.ServerName, server_hostname);
	ret = SCR::Write (.etc.cups.client_conf, nil);
	return ret;
// FIXME remove the rest of the function
    // added check for nil value (bug #19226)
	if (server_hostname == "" || server_hostname == nil)
	{
	     SCR::Execute (.target.bash, "test -f /etc/cups/client.conf && (/usr/bin/awk '
BEGIN { used = 0 }
/^ServerName/ { next }
{ print $0; }
' /etc/cups/client.conf > /etc/cups/client.conf.yast2; mv /etc/cups/client.conf.yast2 /etc/cups/client.conf)");
	}
	else
	{
            SCR::Execute (.target.bash,
                      sformat ("test -f /etc/cups/client.conf && (/usr/bin/awk '
BEGIN { used = 0 }
/^ServerName/ { print \"ServerName %1\"; used = 1; next }
{ print $0; }
END { if (!used) print \"ServerName %1\" }
' /etc/cups/client.conf > /etc/cups/client.conf.yast2; /bin/mv /etc/cups/client.conf.yast2 /etc/cups/client.conf)", server_hostname));
	}
	if (server_hostname == "")
	    server_hostname = nil;
    }

    /**
      * Save CUPS client-only configuration
      * @param default string default queue name
      * @return boolean true on success
      */
    global define boolean saveCupsClient (string default) ``{
	saveClientHostName ();
	if (server_default)
	{
	    default = "";
	}
	SCR::Write (.cups.default_dest, default, "local");
	return true;
    }

    /**
      * start CUPS server and don't wait until initialization finishes
      */
    global define void StartDaemon () ``{
        integer status = (integer)SCR::Execute (.target.bash, "/etc/init.d/cups status");
        if (0 != status)
        {
            SCR::Execute (.target.bash_background, "/etc/init.d/cups start");
        }
    }

    /**
      * Reads CUPS server settings from /etc/cups/cupsd.conf file
      * @return boolean true on success
      */
    global define boolean readCupsSettings () ``{
	list<string> options = (list<string>)
	    SCR::Dir (.etc.cups.cupsd_conf.value);
	options = toset (options);
	map<string,list<string> > settings = $[];
	foreach (string s, options, ``{
	    settings[s] = (list<string>)
		SCR::Read (add (.etc.cups.cupsd_conf.value, s));
	});
	list<string> sections = (list<string>)
	    SCR::Dir (.etc.cups.cupsd_conf.section);
	map<string, map<string, list<string> > > permissions = $[];
	foreach (string s, sections, ``{
	    map<string, list<string> > section = $[];
	    options = (list<string>)
		SCR::Dir (add (.etc.cups.cupsd_conf.value, s));
	    options = toset (options);
	    foreach (string o, options, ``{
		section[o] = (list<string>)
		    SCR::Read (add (add (.etc.cups.cupsd_conf.value, s), o));
		if (tolower (o) == "allow" || tolower (o) == "deny")
		{
		    section[o] = maplist (string s, section[o]:[], ``{
			if (tolower (substring (s, 0, 5)) == "from ")
			    s = substring (s, 5);
			return s;
		    });
		}
	    });
	    permissions[s] = section;
	});
	y2milestone ("CUPS settings read: %1", settings);
	y2milestone ("CUPS permissions read: %1", permissions);
	CUPS::cups_server_settings = settings;
	CUPS::cups_server_permissions = permissions;
	return true;
    }

    /**
      * Writes CUPS server settings to /etc/cups/cupsd.conf file
      * @return boolean true on success
      */
    global define boolean writeCupsSettings () ``{
	if (cups_server_settings == nil || cups_server_permissions == nil)
	    readCupsSettings ();
	boolean ret = true;
	foreach (string k, list<string> v, cups_server_settings, ``{
	    ret = SCR::Write (add (.etc.cups.cupsd_conf.value, k), v) && ret;
	});
	foreach (string s, map<string, list<string> > sect,
	    cups_server_permissions,
	``{
	    foreach (string k, list<string> v, sect, ``{
		if (tolower (k) == "allow" || tolower (k) == "deny")
		{
		    v = maplist (string s, v, ``{
			if (tolower (substring (s, 0, 5)) != "from ")
			    s = "From " + s;
			return s;
		    });
		}
		ret = SCR::Write (
		    add (add (.etc.cups.cupsd_conf.value, s), k), v)
		    && ret;
	    });
	});
	ret = SCR::Write (.etc.cups.cupsd_conf, nil) && ret;
	y2milestone ("CUPS settings writing success: %1", ret);
	return ret;
    }

    /**
      * Wait until listening to CUPS IPP broadcasts finishes
      */
    global define void WaitForCupsListeiningFinish () ``{
	string pid = nil;
	if (SCR::Read (.target.size, "/var/run/listen_remote_ipp.pid") > 0)
	{
	    pid = (string)SCR::Read (.target.string,
		"/var/run/listen_remote_ipp.pid");
	}
	boolean aborted = false;
	if (pid != nil)
	{
	    y2milestone ("Scanning for CUPS server in progress");
	    SCR::Execute (.target.bash, sformat ("kill -1 %1", pid));
	    boolean runs = true;
	    boolean displayed = false;
	    integer counter = 0;
	    while (runs)
	    {
		if (counter == 10)
		{
		    displayed = true;
		    UI::OpenDialog (`VBox (`Label (
			// label
			_("Detecting CUPS network server...")),
			`PushButton (`id (`abort), `opt (`key_F9),
			    Label::AbortButton ())));
		}
		sleep (100);
		runs = SCR::Read (.target.size,
		    "/var/run/listen_remote_ipp.pid") > 0;
		counter = counter + 1;
		if (displayed)
		{
		    any ui = UI::PollInput ();
		    if (ui == `abort)
		    {
			SCR::Execute (.target.bash,
			    sformat ("kill -15 %1", pid));
			runs = false;
			aborted = true;
		    }
		}
	    }
	    if (displayed)
		UI::CloseDialog ();
	}
	else // use results of previous detection
	{
	    return;
	}
	cups_servers = [];
	if (SCR::Read (.target.size,
	    "/var/lib/YaST2/cups_network_server_name") != -1)
	{
	    if (! aborted)
	    {
	        y2milestone ("File with CUPS servers found");
		string tmp = (string)SCR::Read (.target.string,
		    "/var/lib/YaST2/cups_network_server_name");
		cups_servers = splitstring (tmp, "\n");
		cups_servers = toset (cups_servers);
		cups_servers = filter (string s, cups_servers, ``(
		    s != "" && s != nil));
	     }
	}
	// cleanup after testing of remote CUPS server existence
	SCR::Execute (.target.bash, "test -f /var/lib/YaST2/cups_network_server_name && /bin/rm /var/lib/YaST2/cups_network_server_name");
	SCR::Execute (.target.bash, "test -f /var/run/listen_remote_ipp.pid && /bin/rm /var/run/listen_remote_ipp.pid");

    }

    /**
      * Get hosts available on local network via listening to IPP broadcasts
      * @return list Sorted list of hosts
      */
    global define list listenCupsServers () ``{
	integer status = (integer)SCR::Execute (.target.bash, "/etc/init.d/cups status");
	if (0 == status)
	    SCR::Execute (.target.bash, "/etc/init.d/cups stop");

	SCR::Execute(.target.bash_background,
	    "/usr/lib/YaST2/bin/listen_remote_ipp 30");
	sleep (1000);
	WaitForCupsListeiningFinish ();

	if (0 == status)
	    SCR::Execute (.target.bash_background, "/etc/init.d/cups start");
	return cups_servers;
    }

    /**
      * Immediatelly stop listenning to IPP broadcasts via the script
      */
    global define void stopListenCupsServers () ``{
        if (SCR::Read (.target.size, "/var/run/listen_remote_ipp.pid") > 0)
        {
            string pid = (string)SCR::Read (.target.string,
                "/var/run/listen_remote_ipp.pid");
	    y2milestone ("Stopping listining to CUPS IPP bcasts, PID %1", pid);
	    SCR::Execute (.target.bash, sformat ("kill -15 %1", pid));
        }
    }

    /**
      * Propose Client only with a CUPS server
      * listen_remote_ipp must have neen started befor this function is called
      */
    global define void ProposeClientOnly () ``{
	// no local printer found
	y2milestone ("No local printer found, trying IPP servers");
	WaitForCupsListeiningFinish ();
	if (size (cups_servers) > 0)
	{
	    y2milestone ("Found servers: %1", cups_servers);
	    string server = cups_servers[0]:"";
	    cups_installation = `client;
	    server_hostname = server;
	}
	else
	{
	    cups_installation = `server;
	}
    }



    /**
      * List all available queues (local and remote)
      * @return a list of strings all available queues
      */
    global define list<string> GetAvailableQueues () ``{
	list<string> ret = [];
	string hostname = "localhost";
	if (CUPS::InstallationType () == `client && CUPS::server_hostname != "")
		hostname = CUPS::server_hostname;
	ret = (list<string>)SCR::Read (.cups.remote, hostname);
	ret = toset (ret);
	y2milestone ("Available queues for CUPS: %1", ret);
	return ret;
    }

    /**
      * Get list of possible banners for CUPS server
      * @return a list banners names
      */
    global define list<string> getBannerList () ``{
        map out = (map)SCR::Execute (.target.bash_output, "/bin/ls -1 /usr/share/cups/banners");
        list<string> ban = splitstring (lookup (out, "stdout", ""), "\n");
        ban = toset (add (ban, "none"));
        return filter (string i, ban, ``("" != i));
    }



}
