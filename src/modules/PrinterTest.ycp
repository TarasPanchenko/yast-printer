/**
 * File:
 *  modules/PrinterTest.ycp
 *
 * Module:
 *  Printer configurator
 *
 * Summary:
 *  Testpage printing defines
 *
 * Authors:
 *  Petr Blahos <pblahos@suse.cz>
 *  Jiri Srain <jsrain@suse.cz>   2002
 *
 * $Id$
 *
 */

{
    module "PrinterTest";

    textdomain "printer";

    import "CUPS";
    import "Label";
    import "Mode";
    import "Popup";
    import "Printer";
    import "Printerdb";
    import "Printerlib";
    import "Report";
    import "Spooler";


// local functions

    /**
     * Prepare ascii test page. Insert localized string into it.
     * @return string path+filename to updated test page.
     */
    define string prepareAsciiTestPage () ``{
	// TRANSLATORS:
	// You may add some text to ascii test page if you want.
	// Fill in your encoding here! (e.g. iso-8859-2 for czech)
	string encoding = UI (_("!!!  YOUR  ENCODING  !!!"));
	// TRANSLATORS:
	// This text will be added at the end of your test-page if
	// user chooses your language. Write anything you want here.
	// Long multiline text can be here, please break your lines
	// at 80 characters.
	// This text will be visible only if user chooses your
	// language!!! If you want some text to be added in common
	// section, send me an e-mail to <pblahos@suse.cz>. Your
	// text must contain encoding and text. e.g.:
	// ISO-8859-1: Some text in your language.
	// ONLY ONE LINE PLEASE
	string special_text = UI (_("!!!  YOUR  TEXT  !!!"));
	// TRANSLATORS:
	// Ascii Test Page now contains only English explanation:
	// Following lines contain characters in various encodings.  You can check if your
	// selection works properly.
	// If you are English, do not translate it!
	// If you translate it, it must be in encoding "!!!  YOUR  ENCODING !!!".
	// Please break lines at 80 characters. DO NOT USE DIACRITICS (UMLAUTS/ACCENTS).
	// It is possible, that proper encoding is not chosen when printing the
	// test page.
	// ONLY ONE LINE PLEASE. IF YOU WANT MORE LINES, PLEASE USE \\n
	string common_text = UI (_("!!! COMMON  EXPLANATION !!!"));


	string out_file = SCR::Read (.target.tmpdir) + "/testpg.ascii";
	string c_text = "";
	string s_text = "";
	if ("!!!  YOUR  ENCODING  !!!" != encoding && "" != encoding)
	    {
		if ("!!!  YOUR  TEXT  !!!" != special_text && "" != special_text)
		    {
			s_text = UI::Recode ("utf-8", encoding, special_text);
			s_text = mergestring (splitstring (s_text, "\n"), " ");
		    }
		if ("!!! COMMON  EXPLANATION !!!" != common_text && "" != common_text)
		    {
			c_text = UI::Recode ("utf-8", encoding, common_text);
			c_text = mergestring (splitstring (c_text, "\n"), " ");
		    }
	    }
    // test the distribution
    // could be done by
    // if (Product::baseproduct == "UnitedLinux")
    string path_to_testpage = "";
    if (SCR::Read(.target.stat, Printerlib::baseDataDir + "/ul_testpg.ascii") == $[])
        path_to_testpage = Printerlib::baseDataDir + "/suse_testpg.ascii";
    else
        path_to_testpage = Printerlib::baseDataDir + "/ul_testpg.ascii";

	// now we have texts to replace.
	SCR::Execute (
	    .target.bash,
	    sformat (
		"/bin/cat %1 | /bin/sed -e \"s/~common~explanation~/%2/\" -e \"s/~special~text~/%3/\" > %4",
        path_to_testpage, c_text, s_text, out_file));
	return out_file;
    }
    /**
     * Prepare test page
     * @param queue queue name
     * @param opt_file file with queue options
     * @param PS_printer is the tested printer PS? Do not print image there.
     * @return filename of the test page
     */
    define string preparePsTestPage (string queue, string opt_file, boolean PS_printer) ``{
	string out_file = SCR::Read (.target.tmpdir) + "/testpg.ps";
	SCR::Execute (.target.bash, sformat (
	    "/usr/lib/YaST2/bin/prepare_ps_testpage.pl %1 %2",
	    opt_file,
	    out_file
	));
	return out_file;
	// test the distribution
	string path_to_testpage = Printerlib::baseDataDir + "/testpg.ps";

	y2debug("template test file to print: %1", path_to_testpage);

    }

    /**
     * Shows dialog box that allows user to stop printing.
     * @param pr_command Command that was used to start printing.
     * Showed in text field.
     * @return boolean true if printing has to be stopped
     */
    define boolean OkOrStopPrinting (string pr_command) ``{
	// message box with [OK] [Stop]
	string text = sformat (_("The test page was sent to the printer using
the command '%1'.
Printing should start in a few seconds.

If the printer is not producing the appropriate
output, use the 'Stop!' button.

When the whole page is printed, press
'Printout finished'."), pr_command);
	// push button
	return Popup::AnyQuestion (Popup::NoHeadline (), text, _("Printout &finished"), Label::StopButton (), `focus_yes);
    }

    /**
      * Saves printer under some new name and tests it.
      * @param printer map of printer to test
      * @param testpage_type type of page.
      * Supported are `ascii, `postscript, `ask
      * @return boolean true if success
      */
    global define boolean testPrinter (map printer, symbol testpage_type) ``{
	if (Mode::config)
	{
	    Printerlib::DisplayUnavailableAIPopup ();
	    return true;
	}

	printer = Printer::assignStates (printer, true);

	Printerdb::loadFoomaticIfNeeded ();

	if (Printer::getPrinterState(printer, Spooler::Get ()) == "void")
	{
	    // message popup
	    Popup::Message (_("Unable to print a test page. You are using different spooler."));
	    return false;
	}

	if (Spooler::Get () != "lprng" && Spooler::Get () != "cups")
	{
	    // message box
	    Popup::Message (_("Unable to print a test page. 
Install a spooler 
before printing test pages.
"));
	    return true;
	}

	// set for printing using localhost
	string cups_server_on_disk = "";
	if (Spooler::Get () == "cups")
	{
	    CUPS::loadClientHostName ();
	    cups_server_on_disk = CUPS::server_hostname;
	    CUPS::server_hostname = "";
	    CUPS::saveClientHostName ();
	    CUPS::cups_installation = `server;
	}

	Spooler::RestartIfNeeded (true);

	if (testpage_type == nil)
	    testpage_type = `ask;
	if (printer == nil || size (printer) == 0)
	{
	    Report::Error ("Internal error - printer structure empty");
	    return false;
	}
	if (testpage_type != `ask)
	{
	    // message box
	    if (!Popup::AnyQuestion ("", _("Ready to print a sample page.

Make sure the printer is turned
on and ONLINE then press the 'OK' button.
"),
		    Label::OKButton (), Label::CancelButton (), `focus_yes))
	    {
		return ;
	    }
	}
	else
	{
	    UI::OpenDialog (
		`VBox (
		    // label
		    `Label (_("Ready to print a sample page.

Select the test page type, make sure 
the printer is turned on and ONLINE, then 
press 'OK'.
")),
		    `VSpacing (1),
		    `RadioButtonGroup (`id (`type), `VBox (
			// radiobutton
			`Left (`RadioButton (`id (`graphic), _("Test &graphical printing"))),
			// radiobutton
			`Left (`RadioButton (`id (`ascii), _("Test &text printing")))
		    )),
		    `VSpacing (1),
		    `HBox (
			// pushbutton
			`PushButton (`id (`ok), `opt (`key_F10, `default), Label::OKButton ()),
			// pushbutton
			`PushButton (`id (`cancel), `opt (`key_F9), Label::CancelButton ())
		    )
		)
	    );
	    UI::ChangeWidget (`id (`type), `CurrentButton, `graphic);
	    symbol ret = nil;
	    while (nil == ret)
	    {
		ret = UI::UserInput ();
		if (ret == `cancel)
		{
		    UI::CloseDialog ();
		    return;
		}
		if (ret == `ok)
		{
		    if (UI::QueryWidget (`id (`type), `CurrentButton) == `ascii)
			testpage_type = `ascii;
		    else
			testpage_type = `postscript;
		    break;
		}
		ret = nil;
	    }
	    UI::CloseDialog ();
	}

	// create new name for the printer
	list forbidden_names = union (Printer::getForbiddenNames (), Printer::DeletedNames ());
	string virtual_name = lookup (printer, "name", "");
	string name = Printer::adjustQueueName ("y2test", forbidden_names);
	string uri = lookup (printer, "uri", "");
	string printer_type = uri == "class" ? "class" : "printer";
	printer = add (printer, "name", name);
	printer = add (printer, "recreate", true);
	printer = Printer::fixPrinter (printer);
	y2debug ("Printer for testpage: %1", printer);

	if (Spooler::Get () == "cups")
	{
	    Printer::writeCupsPrinter (printer);
	}
	else
	{
	    //
	    // backup printcap
	    //
	    SCR::Execute (.target.bash, "/bin/cp /etc/printcap /etc/printcap.y2bak");

	    //
	    // write printer
	    //
	    if (!Printer::writeLpdPrinter (printer))
		return false;

	    //
	    // restart lpd
	    //
	    SCR::Execute (.target.bash, "test -f /etc/init.d/lpd && /etc/init.d/lpd restart");
	}
	//
	// print test page
	// to queue: name
	// but tell user it is queue: virtual_name
	string switch = " -P" + name;
	string test_page = "";
	if (`postscript == testpage_type)
	{
	    map consolefonts = SCR::Read (.target.yast2, "consolefonts.ycp");
	    string ce = select (lookup (consolefonts, UI::GetLanguage (false), []), 4, "X");
	    string opts = SCR::Read (.target.tmpdir) + "/testpg.options";
	    string os = "";
	    // encoding first
	    ce = toupper (ce);
	    if (ce != "ISO-8859-2" && ce != "ASCII" && ce != "ISO-8859-15"
		&& ce != "ISO-8859-1")
	    {
		ce = toupper (_("!!!  YOUR  ENCODING  !!!"));
	    }
	    if (ce != "ISO-8859-2" && ce != "ASCII" && ce != "ISO-8859-15"
		&& ce != "ISO-8859-1")
	    {
		ce = "ASCII";
	    }

	    string enc = "ISO-8859-2" == ce ? "h02" : "h01";

	    string config = printer["config"]:"";
	    if (findfirstof (config, "(") != nil)
		config = substring (config, 0, findfirstof (config, "("));

	    // options
	    string filename = SCR::Read (.ppd.file.open,
		[Printerdb::foomatic[
		    printer["vendor_db"]:"",
		    printer["device_db"]:"",
		    printer["config"]:"", "filename"]:"",
		SCR::Read (.target.tmpdir)]);
	    map options = SCR::Read (.ppd.file.options, [filename, ""]);
	    list optlist = options["data"]:[];
	    optlist = maplist (`i, optlist, ``{
		    string name = i["name"]:"";
		    string label = i["gui"]:"";
		    string value = printer["options", name]:"";
		    if (value == "")
			value = i["current"]:"";
		    string valuelabel = i["values", value]:"";
		    if (label == "")
			label = name;
		    if (valuelabel == "")
			valuelabel = value;
		    if (label != "" && valuelabel != "")
			return sformat ("(%1: %2)", label, valuelabel);
		    else
			return "";
	    });
	    optlist = filter (`o, optlist, ``(o != "" && o != nil));

// encoding
	    os = os + sformat ("----X-ENCODING: %1\n", enc);

// labels
            // TRANSLATORS: keep this short! Only translations in languages
            // with encodings ISO-8859-[1|2|15] will be used.
	    os = os + sformat ("----X-HEAD: (%1)\n", _("YaST2 test page"));
	    // TRANSLATORS: keep this short! Only translations in languages
	    // with encodings ISO-8859-[1|2|15] will be used.
	    os = os + sformat ("----X-SECT1-L: (%1)\n", _("Print queue:"));
            // TRANSLATORS: keep this short! Only translations in languages
            // with encodings ISO-8859-[1|2|15] will be used.
	    os = os + sformat ("----X-SECT2-L: (%1)\n", _("Printer:"));
	    // TRANSLATORS: keep this short! Only translations in languages
	    // with encodings ISO-8859-[1|2|15] will be used.
	    os = os + sformat ("----X-SECT3-L: (%1)\n", _("PPD File:"));
            // TRANSLATORS: keep this short! Only translations in languages
            // with encodings ISO-8859-[1|2|15] will be used.
	    os = os + sformat ("----X-SECT4-L: (%1)\n", _("Options:"));

// border
	    os = os + sformat ("----X-BORDER-1: (%1)\n",
		// footnote of the test page 1/6
		// TRANSLATORS: keep this short! Only translations in languages
		// with encodings ISO-8859-[1|2|15] will be used.
		_("The border lines start and end at the edges of the imageable area."));
	    os = os + sformat ("----X-BORDER-2: (%1)\n",
		// footnote of the test page 2/6
		// TRANSLATORS: keep this short! Only translations in languages
		// with encodings ISO-8859-[1|2|15] will be used.
		_("They have 1 inch resp. 2 cm distance to the edges of the imageable area."));
	    os = os + sformat ("----X-BORDER-3: (%1)\n",
		// footnote of the test page 3/6
		// TRANSLATORS: keep this short! Only translations in languages
		// with encodings ISO-8859-[1|2|15] will be used.
		_("The actual imageable area depends on the printer model and/or Ghostscript driver."));
	    os = os + sformat ("----X-BORDER-4-LEFT: (%1)\n",
		// footnote of the test page 4/6
		// TRANSLATORS: keep this short! Only translations in languages
		// with encodings ISO-8859-[1|2|15] will be used.
		// it will be followed by a position specification
		// (number/number) and the following part of testpage footnote
		_("Here it begins on the left/bottom at"));
	    os = os + sformat ("----X-BORDER-4-RIGHT: (%1)\n",
		// footnote of the test page 5/6
		// TRANSLATORS: keep this short! Only translations in languages
		// with encodings ISO-8859-[1|2|15] will be used.
		// it will be followed by a position specification
		// (number/number)
		_("and on the right/top it ends at"));
	    os = os + sformat ("----X-BORDER-5: (%1)\n",
		// footnote of the test page 6/6
		// TRANSLATORS: keep this short! Only translations in languages
		// with encodings ISO-8859-[1|2|15] will be used.
		_("1 unit = 1 PostScript point = 0.0139 inch = 0.0353 cm."));

// values
	    os = os + sformat ("----X-SECT1: (%1)\n", "queue name");
	    os = os + sformat ("----X-SECT2: (%1 %2)\n",
		printer["vendor_ieee"]:"", printer["device_ieee"]:"");
	    os = os + sformat ("----X-SECT3: (%1)\n", config);
            // TRANSLATORS: keep this short! Only translations in languages
            // with encodings ISO-8859-[1|2|15] will be used.
	    os = os + sformat ("----X-SECT4: %1\n", mergestring (optlist, " "));


//	    os = os + mergestring (optlist, "\n");

	    if (ce != "X")
	    {
		    os = UI::Recode ("UTF-8", ce, os);
	    }
	    SCR::Write (.target.string, opts, os);
	    boolean is_ps = true;
	    if (issubstring (printer["config"]:"", "Foomatic"))
	    {
		if (! issubstring (printer["config"]:"", "Postscript"))
		    is_ps = false;
	    }
	    test_page = preparePsTestPage (virtual_name, opts, is_ps);
	}
	else
	{
	    test_page = prepareAsciiTestPage ();
	}
	string lpr_command = sformat ("/usr/bin/lpr -P%1 %2", name, test_page);
	map out = SCR::Execute (.target.bash_output, lpr_command);

	// restore CUPS server settings
	if (Spooler::Get () == "cups")
	{
	    CUPS::server_hostname = cups_server_on_disk;
	    CUPS::saveClientHostName ();
	    CUPS::server_hostname = "";
	}

	if (lookup (out, "exit", 0) != 0)
	{
	    Popup::Message (
		// message box
		sformat (_("Unable to print the test page.

Output from lpr:
"), test_page) +
		lookup (out, "stderr", ""));
	    Printer::deletePrinters ([$["name": name, "type": printer_type ]]);
	    return false;
	}

	if (false == OkOrStopPrinting (sformat ("lpr -P%1 %2", virtual_name, test_page)))
	{ // Problems, stop the printing!
	    if (Spooler::Get () != "cups")
	    {
		Spooler::StopServices ();
	    }

	    string contype = Printerlib::getUriType (uri);
	    if (contype == "parallel" || contype == "serial" || contype == "usb")
	    {
		string device = Printerlib::getUriDevice (uri);
		if (device != "")
		{
		    SCR::Execute (.target.bash, sformat ("/bin/fuser -k %1", device));  // kill currently printing processes
		}
		if (contype == "parallel" && "/dev/lp" == substring (device, 0, 7))
		{
		    //
		    // do printer_reset only if we are sure that the device is /dev/lp, because
		    // now user may add anything as parallel device and we should send this ioctl
		    // only to parallel port
		    //
		    SCR::Execute (.target.control.printer_reset, device);
		}
	    }

	    SCR::Execute (.target.bash, "/bin/rm `/usr/bin/find /var/spool/lpd -name \"[cd]f*\" -type f`"); // remove all jobs
	    if (Spooler::Get () != "cups")
		SCR::Execute (.target.bash, "test -f /etc/init.d/lpd && /etc/init.d/lpd start"); // restart lpd

	    // message box
	    Popup::Message (_("Printing was stopped.

If the printer is still printing, push the reset button
on the printer or remove all the paper from its tray.
After it stops printing, switch off the printer power,
wait 10 seconds and switch it on again.

Again, check the manufacturer and printer model entries
you made previously."));
	}
	else
	{ // don't show notice regarding testing in proposal more
	    Printer::tested = true;
	}
	Printer::deletePrinters ([$["name": name, "type": printer_type]]);
//	SCR::Execute (.target.bash, sformat ("/bin/rm /var/lib/YaST2/printers/y2test; \n"));
	return true;
    }

}
