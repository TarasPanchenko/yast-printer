/**
 * File:
 *   modules/Printer.ycp
 *
 * Package:
 *   printer configuration tool
 *
 * Summary:
 *   Module for printer.
 *
 * Authors:
 *  Petr Blahos <pblahos@suse.cz>
 *  Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 * Well we all know what modules are for.
 */

{
    module "Printer";

    textdomain "printer";

    import "Arch";
    import "Confirm";
    import "Crash";
    import "CUPS";
    import "HTML";
    import "Label";
    import "Mode";
    import "Popup";
    import "Printerdb";
    import "Printerlib";
    import "Progress";
    import "Report";
    import "Runlevel";
    import "Spooler";
    import "Summary";
    include "printer/misc-cups.ycp";
    include "printer/misc-lprng.ycp";


    //////////
    ////////// Module data
    //////////

    /**
      * Version of YaST2 printer module for updates handling
      */
    global integer version = 256 * 2 + 9; // 2.9
    /**
      * Don't run SuSEconfig, don't restart services if true and possible
      */
    global boolean write_only = false;
    /**
      * Shall be printers detected
      * If nil, ask user
      */
    global boolean detect = true;

    /**
     * List of print queues. See description of map printer
     * for members structure.
     */
    global list printcap = [];
    /**
      *Backup list of print queues. See description of map printer
      * for members structure.
      */
    global list printcap_backup = [];
    /**
     * Default queue name
     */
    global string default = "";
    /**
     * Were settings changed?
     */
    global boolean dirty = false;
    /**
      * Were settings read?
      */
    global boolean read_done = false;
    /**
     * Print queue we are currently working with.
     * @example
     * $[
     * "name" : string, //queue name
     * "uri" : string, //printer uri
     * "unique_key" : string,  // from libhd  -|
     * "ppd" : string // filename of used ppd file, non-raw queues only
     * "ppd_info" : map // chached information about PPD file, non-raw only
     * "options": map,   // options from printer db -|
     * "ff" : boolean, // print formfeed between pages, present only for queues with formfeed
     * "raw": boolean, // raw queue, present only for raw queues
     * ]
     */
    global map printer = $[];
    /**
     * Index of printer we are working with.
     */
    global integer index = 0;
    /**
     * List of printers that were deleted during this configuration
     * session.
     */
    global list deleted = [];
    /**
     * List of autodetected printers. For documentation see
     * yast2-lib-printer.
     */
    global list autodetected = [];


    /**
     * List of unique keys of the printers read at the beginning.
     * We need this because when writting, we must call
     * Write (.probe.status.configured, "unique_key", `yes | `no)
     * It is map of $[ unique_key : true ]. When saving, unique keys that
     * are still configured are replaced by $[ unique_key : false ]
     */
    map original_unique_keys = $[];


    /**
      * Type of start, true if autodetection
      */
    global boolean detection = false;
    /**
      * At least one queue has been tested - because of hw proposal
      */
    global boolean tested = false;

    /**
      * True if autodetection should be skipped
      */
    global boolean skip_autodetection = Arch::s390;

// variables for UI purproses

    /**
      * Current mode of configuration
      * `det for configuring from detected printers dialog
      * `adm for configuring from printer administration dialog
      */
    global symbol confmode = nil;

    /**
      * Selected item from main connection type dialog
      */
    global symbol connection_type_selected = `parallel;

    /**
      * Old URI due to backing it up during edit sequence
      */
    global string old_uri = "";

    /**
      * Configuring printer, which is result of detection?
      */
    global boolean conf_detected = false;

    /**
      * When configuring client, using server's default queue?
      */
    global boolean server_default = true;

    /**
      * Selected item of the list of detected printers
      */
    global integer runAutoprobedListDialog__current = 0;

// local functions

    /**
     * Test for abort.
     * @return true if abort was pressed
     */
    global define boolean testAbort () ``{
	if (`abort == UI::PollInput ())
	{
	    UI::CloseDialog ();
	    return true;
	}
	return false;
    }

// global functions

    /**
     * Autodetect printers.
     */
    global define void Detect () ``{
        /* Confirmation: label text (detecting hardware: xxx) */
        if (!Confirm::Detection (_("Printers")))
            return true;

	dirty = true;
	autodetected = Printerlib::Detect (false);
	autodetected = maplist (`i, autodetected, ``{
	    i["info"] = i["vendor"]:"" + " " + i["device"]:"";
            i["location"] = Printerlib::getUriNiceName (i["uri"]:"");
	    i["vendor_db"] = SCR::Read (.ppd.db.vendorname, i["vendor"]:"");
	    i["device_db"] = SCR::Read (.ppd.db.modelname,
		    [i["vendor_db"]:"", i["device"]:""]);
	    y2milestone ("Detected printer %1", i);
	    return i;
	});
	if (Spooler::Get () == "cups")
	{
	    Printerlib::setCupsUsbDevicesInfo ();
	    autodetected = filter (`a, autodetected, ``(
		! contains (Printerlib::getProblematicCupsUsbDevices (),
		    Printerlib::getUridevice (a["uri"]:""))
	    ));
	}
    }

    /**
     * Select printer to edit or something.
     * @param i printer to select. Pass nil if you do not want to select
     *		printer, e.g. if printer is going to be added.
     */
    global define void selectPrinter (integer i) ``{
	if (nil == i || i < 0 || i >= size (printcap))
	{
	    index = -1;
	    printer = $[];
	    return ;
	}
	index = i;
	printer = select (printcap, index, $[]);
    }
    /**
     * Select printer to edit or something.
     * @param name printer to select. Pass nil if you do not want to select
     *          printer, e.g. if printer is going to be added.
     */
    global define void selectPrinterByName (string name) ``{
        index = -1;
        printer = $[];
	integer ind = -1;
	foreach (`p, printcap, ``{
	    ind = ind + 1;
	    if (p["name"]:"" == name)
	    {
		index = ind;
		printer = p;
	    }
	});
    }

    /**
     * Let print queue named name be currently edited.
     * If printer is not found, then queue will be $[] and index -1
     * @param name name of the queue to find
     */
    global define void selectPrinterByName (string name) ``{
	index = -1;
	integer j = -1;
	foreach (`i, printcap, ``{
	    j = j + 1;
	    if (name == lookup (i, "name", ""))
	    {
		index = j;
	    }
	});
	printer = select (printcap, index, $[]);
    }

    /**
     * Delete currently selected printer.
     */
    global define void deletePrinter () ``{
	if (index < 0 || index >= size (printcap))
	    return ;
	printer = select (printcap, index, $[]);
	if (nil == printer)
	    printer = $[];
	string printer_type = "";
	if (lookup (printer, "type", "yast2") == "lprng")
	    printer_type = "printer";
	else if (lookup (printer, "type", "yast2") == "yast2")
	    printer_type = lookup (printer, "uri", "class") == "class" ? "class" : "printer";
	else
	{
	    if (lookup (printer, "uri", "") == "class")
		printer_type = "class";
	    else if (lookup (printer, "uri", "") != "")
		printer_type = "printer";
	    else
	    {
		printer_type = "class";
		addToDeleted (lookup (printer, "name", ""), "printer");
	    }
	}
	addToDeleted (lookup (printer, "name", ""), printer_type);
	printcap = remove (printcap, index);
	if (index >= size (printcap))
	    index = index - 1;
	dirty = true;
	assignDefault ();
    }
    /**
      * Set implicit default queue if no queue is set as default
      */
    global define void assignDefault () ``{
	boolean found_default = false;
	boolean found_lp = false;
	boolean found_normal = false;
	boolean found_defstr = false;
	string norm_name = "";
	string first = "";
	string state_string = Spooler::Get () + "-state";
	foreach (`e, printcap, ``{
	    string name = lookup (e, "name", "");
	    if (lookup (e, state_string, "") != "void")
	    {
		if (name == "lp")
		    found_lp = true;
		if (name == default)
		    found_default = true;
		if (name == "normal" || regexpmatch (name, "normal[0-9]"))
		{
		    norm_name = name;
		    found_normal = true;
		}
		if (name == "default")
		    found_defstr = true;
		if (first == "")
		    first = name;
	    }
	});
	if (found_default)
	{

	}
	else if (found_lp)
	{
	    default = "lp";
	    dirty = true;
	}
	else if (found_normal)
	{
	    default = norm_name;
	    dirty = true;
	}
	else if (found_default)
	{
	    default = "default";
	    dirty = true;
	}
	else
	{
	    default = first;
	    dirty = true;
	}
    }

    /**
     * Set current printer as default printer
     */
    global define void setDefaultPrinter () ``{
	if (index < 0 || index >= size (printcap))
	    return ;
	default = lookup (printer, "name", "");
	dirty = true;
    }
    /**
     * Return list(set) of names that can not be used as printer name. There can be
     * same name for more printers in /etc/printcap. It was impossible to add printer,
     * because all names were invalid because
     * size (union (forbidden_names, new_names)) != size (forbidden_names) + size (new_names).
     * @return list set of already used names
     */
    global define list getForbiddenNames() ``{
	list l = toset (add (flatten (maplist (`entry, printcap, ``(add (lookup (entry, "names", []), lookup (entry, "name", ""))))), "all"));
	list names = maplist (`i, l, ``(tolower (i)));
	names = toset (names);
	return names;
    }
    /**
      * Assign states to a printer
      * @param p map printer
      * @param changed boolean true if queue was changed
      *   (to assign correct state)
      * @return map printer with assigned states
      */
    global define map assignStates (map p, boolean changed) ``{
	if (lookup (p, "type", "yast2") != "yast2")
	    return p;
	boolean supported = true;
	list spoolers = ["cups", "lprng"];
	string uri = lookup (p, "uri", "");
	string q_type = Printerlib::getUriType (uri);
	string q_filter = "";

	string filename = p["ppd"]:"";
	if (isPpd (filename))
	{
	    map info = p["ppd_info"]:$[];
	    q_filter = info["filter"]:"";
	}

	if (q_filter == nil)
	    supported = false;
	boolean is_class = q_type == "class";
	if (is_class || p["raw"]:false)
	    supported = true;
	foreach (`s, spoolers, ``{
	    boolean filt_sup = ((s == "cups" || ! is_class)
		    && (s == "cups" || q_filter == "foomatic-rip"))
		|| p["raw"]:false;
	    boolean spool_sup = Spooler::testSupportedQueueBySpooler (q_type, s);
	    string key = s + "-state";
	    boolean sup = supported && filt_sup && spool_sup;
	    p[key] = sup
		    ?
			(changed ?
			    "changed"
			:
			    (lookup (p, key, "changed") == "void"
			    ?
				"changed"
			    :
				lookup (p, key, "changed")))
		    :
			"void";
	});
	return p;
    }
    /**
      * Make states of all queues changed or void
      * after spooler switch de-facto no queue is really saved
      */
    global define void assignAllQueuesChanged () ``{
	printcap = maplist (`p, printcap, ``(assignStates (p, true)));
    }

    /**
      * Gets state of printer for choosen spooler
      * @param p map printer
      * @param spooler string spooler (cups or lprng)
      * @return string state
      */
    global define string getPrinterState (map p, string spooler) ``{
	string s = spooler + "-state";
	return p[s]:"changed";
    }
    /**
      * Adds a queue to the deleted list
      * @param name string queue name
      * @param printer_type string "printer" or "class"
      */
    global define void addToDeleted (string name, string printer_type) ``{
	deleted = add (deleted, $[ "name" : name, "type" : printer_type, "states" : $["cups-state" : "changed", "lprng-state" : "changed"]]);
    }
    /**
     * Save currently edited printer.
     */
    global define void storePrinter () ``{
	CUPS::cups_installation = `server;
	if (printer["uri"]:"" == "listen_ipp")
	{
	    if (CUPS::cups_server_settings["Browsing"]:"On" == "On")
	    {
		// TODO make sure CUPS server will be running

	    }
	    return;
	}
	else if (printer["uri"]:"" == "cups_client")
	{
	    CUPS::cups_installation = `client;
	    return;
	}

	printer = assignStates (printer, true);

	y2milestone ("Storing printer %1, index %2", printer, index);

	if (-1 == index)
	{
	    printcap = add (printcap, printer);
	    index = size (printcap) - 1;
	}
	else
	{
	    // we do not need care about creating new remote queue, it is
	    // impossible in this situation
	    integer c = -1;
	    printcap = maplist (`i, printcap, ``{
		c = c + 1;
		if (c == index)
		    return printer;
		return i;
	    });
	}
	// fix default printer
	if ("" == default || nil == default)
	{
	    default = lookup (printer, "name", "");
	}
	else
	{
	    boolean found = false;
	    foreach (`i, printcap, ``{
		    if (!found && lookup (i, "name", "") == default)
			found = true;
	    });
	    if (!found)
		default = lookup (printer, "name", "");
	}
	dirty = true;
	y2debug ("Final printcap: %1", printcap);
    }
    /**
     * Export module settings to map.
     * @return Map of module settings.
     */
    global define map Export () ``{
	return $[
	    "printcap" : printcap,
	    "default"  : default,
	    "spooler" : Spooler::Get (),
	    "cups_installation" : CUPS::cups_installation,
	    "server_hostname" : CUPS::server_hostname,
	    "server_default" : server_default,
	];
    }
    /**
     * Import module settings.
     * @param settings module settings
     */
    global define void Import (map settings) ``{
	dirty = true;
	Spooler::Set (settings["spooler"]:"cups");
	CUPS::cups_installation = lookup (settings, "cups_installation", nil);
	CUPS::server_hostname = lookup (settings, "server_hostname", "");
	default = lookup (settings, "default", "");
	printcap = lookup (settings, "printcap", []);
	CUPS::usb_dev_names = `always;
	index = -1;
	deleted = [];
	server_default = settings["server_default"]:"";
    }
    /**
     * Reset all settings...
     */
    global define void Reset () ``{

	list pr = printcap;
	foreach (`e, pr, ``{
	    string uri = lookup (e, "uri", "");
	    deletePrinters ([$["name": lookup (e, "name", ""), "type":  uri == "class" ? "class" : "printer"]]);
	});
	CUPS::server_hostname = "";
	CUPS::cups_installation = nil;
	dirty = true;
	default = "";
	printcap = [];
	index = -1;
	deleted = [];
	autodetected = [];
	CUPS::usb_dev_names = `always;
	server_default = true;
    }
    /**
     * read printers from /etc/printcap
     * @return list of printers
     */
    global define list printcapRead () ``{
	SCR::Execute (.target.bash,
	    "test -d /etc/lpdfilter || /bin/mkdir /etc/lpdfilter");
	list ret = SCR::Read (.etc.printcap);
	if (nil == ret)
	    return [];

	ret = maplist (map p, ret, ``{
	    string ppd_filename
		= sformat ("/etc/lpdfilter/%1/ppd", p["name"]:"");
	    if (-1 != SCR::Read (.target.size, ppd_filename))
	    {
		string tmp_file = SCR::Read (.target.tmpdir);
		SCR::Execute (.target.bash, "/bin/cp %1 %2", ppd_filename,
		    tmp_file);
		p["ppd"] = tmp_file;
		p["ppd_info"] = Printer::ppdInfo (tmp_file);
	    }
	    return p;
	});
	default = ret[0, "name"]:nil;
	return ret;
    }

    /**
     * Read the CUPS settings.
     * @return list of printers
     */
    global define list cupsRead () ``{
        if (`server == CUPS::InstallationType ())
        {
	    Spooler::RestartIfNeeded (true);
            list ret = SCR::Read (.cups.printers);
	    ret = filter (`e, ret, ``(lookup (e, "uri", "") != ""));
	    ret = maplist (map e, ret, ``{
		if (SCR::Read (.target.size, e["ppd"]:"") > 0)
		    e["ppd_info"] = Printer::ppdInfo (e["ppd"]:"");
		    path p = .etc.cups.printers.value;
		    p = add (p, e["name"]:"");
		    p = add (p, "DeviceURI");
		    string uri = SCR::Read (p);
		    if (uri != nil)
			e["uri"] = uri;
		return e;
	    });
            list classes = SCR::Read (.cups.classes);
	    if (nil == ret) ret = [];
	    if (nil == classes)  classes = [];
	    classes = maplist (`e, classes, ``(add (e, "uri", "class")));
	    ret = ret + classes;
	    default = SCR::Read (.cups.default_dest);
	    CUPS::readCupsSettings ();
	    return ret;
        }
        return [];
    }
    /**
      * Sorts entries of printcap
      */
    global define void sortPrinters () ``{
	list yast = filter (`e, printcap, ``(lookup (e, "type", "yast2") == "yast2"));
	list non_yast = filter (`e, printcap, ``(lookup (e, "type", "yast2") != "yast2"));
	list classes = filter (`e, yast, ``(lookup (e, "uri", "class") == "class"));
	list printers = filter (`e, yast, ``(lookup (e, "uri", "class") != "class"));
	map sorted = $[];
	list locals = filter (`e, printers, ``(contains (["parallel", "serial", "irda", "usb", "pipe"], Printerlib::getUriType (lookup (e, "uri", "")))));
	list remote = filter (`e, printers, ``(! contains (["parallel", "serial", "irda", "usb", "pipe"], Printerlib::getUriType (lookup (e, "uri", "")))));

	foreach (`e, locals, ``{
	    string uri = lookup (e, "uri", "");
	    list s = lookup (sorted, uri, []);
	    s = add (s, e);
	    sorted = add (sorted, uri, s);
	});
	locals = [];
	foreach (`k, `v, sorted, ``{locals = merge (locals, v);});
	sorted = $[];
	foreach (`e, remote, ``{
	    string uri = lookup (e, "uri", "");
	    list s = lookup (sorted, uri, []);
	    s = add (s, e);
	    sorted = add (sorted, uri, s);
	});
        remote = [];
        foreach (`k, `v, sorted, ``{remote = merge (remote, v);});

	printcap = merge (locals, remote);
	classes = sort (`x, `y, classes, ``(lookup (x, "name", "") <= lookup (y, "name", "")));
	printcap = merge (printcap, classes);
	non_yast = sort (`x, `y, non_yast, ``(lookup (x, "name", "") <= lookup (y, "name", "")));
	printcap = merge (printcap, non_yast);
    }



    /**
     * Read settings from disk or where.
     * @return boolean success?
     */
    global define boolean Read () ``{
	if (Arch::s390)
	    skip_autodetection = true;
	list stages = [
	    // progress stage, text in dialog (short) (infinitive)
	    _("Check environment"),
	    // progress stage, text in dialog (short) (infinitive)
	    _("Check database of printers"),
	    // progress stage, text in dialog (short) (infinitive)
	    _("Load current settings"),
	];
	list titles = [
	    // progress stage, text in dialog (short)
	    _("Checking environment..."),
	    // progress stage, text in dialog (short)
	    _("Checking database of printers..."),
	    // progress stage, text in dialog (short)
	    _("Loading current settings..."),
	];
	if (!skip_autodetection)
	{
	    // progress stage, text in dialog (short) (infinitive)
	    stages = add (stages, _("Autodetect printers"));
	    // progress stage, text in dialog (short)
	    titles = add (titles, _("Autodetecting printers..."));
	}

	// progress label
	Progress::New (_("Initializing printer configuration tool..."),
	    " ", skip_autodetection ? 12 : 16, stages, titles, "");

	Progress::NextStageStep (0); // step 0 - check root permission
	if (testAbort ()) return false;

	if (! checkRootPerm ())
	    return false;

	Progress::NextStep (); // step 1 - check installed spooler
	if (testAbort ()) return false;

	if (! checkSpooler ())
	    return false;

	Progress::NextStep (); // step 2 - check ghostscript package
	if (testAbort ()) return false;

	if (Spooler::Get () != "cups" || CUPS::InstallationType () == `server)
	{
	    checkGhostscript ();
	}

	Progress::NextStep (); // step 3 - initialize spooler
	if (testAbort ()) return false;

	if (Mode::test)
	{
	    spoolerInitialize ();
	}

	Progress::NextStageStep (4); // step 4-7 - check and load the database
	if (testAbort ()) return false;

	if (Spooler::Get () != "cups" || CUPS::InstallationType () == `server)
	{
	    Printerdb::foomatic = nil;
	    Printerdb::loadFoomaticIfNeeded ();
	}

	Progress::NextStageStep (8); // step 8-11 - read the settings
	if (testAbort ()) return false;

	if (Spooler::Get () == "cups" && CUPS::InstallationType () == `client)
	{
	    if (! cupsClientRead ())
		return false;
	}
	else
	{
	    if (! queuesRead ())
		return false;
	}

	printcap = maplist (`e, printcap, ``{return assignStates (e, false);});

	Progress::NextStageStep (12); // step 12-15 - autodetection
	if (testAbort ()) return false;

	if (!skip_autodetection)
	{
	    if (! doPrinterDetection ())
		return false;
	}
	// Progress finish
	Progress::Finish (); if (testAbort ()) return false;
	return true;
    }

    /**
      * Check if running with root permission
      * @return boolean true if yes, or user confirmed he agrees with
      *  possible problems
      */
    global define boolean checkRootPerm () ``{
	// make sure we are root
	if (!Printerlib::amIRoot () && !Mode::test)
	{
	    if (! Popup::AnyQuestion ("",
		// popup
		_("You must be root to run the printer configuration tool. 
 If you continue, you will not be able to save your settings. 
 Continue?"),
		Label::YesButton (), Label::NoButton (), `focus_no))
	    {
		return false;
	    }
	}
	return true;
    }

    /**
      * Detect spooler currently in use
      * @return boolean true on success
      */
    global define boolean checkSpooler () ``{
	Spooler::Set (Spooler::checkSpoolSystem());
	y2milestone ("Detected spooler: %1", Spooler::Get ());
	if (Spooler::Get () == "exit")
	    return false;

	return true;
    }

    /**
      * Check if GhostScript is installed
      * @return boolean true if is installed
      */
    global define boolean checkGhostscript () ``{
	if (SCR::Execute (.target.bash, "/usr/bin/which gs") != 0)
	{
	    // message box
	    Report::Warning (_("It seems that you do not have GhostScript
installed on your computer. It is needed
to print."));
	    return false;
	}
	return true;
    }

    /**
      * Update configuration if cfg. saved by previous version
      * @param read_version integere version written in cfg. file
      */
    global define void updateConfig (integer read_version) ``{
	if (read_version < 520)
	{
	    printcap = maplist (`p, printcap, ``{
		if (substring (p["uri"]:"", 0, 12) == "prefilter://")
		    p["uri"] = "filtering://localhost/"
			+ substring (p["uri"]:"", 12);
		if (substring (p["uri"]:"", 0, 6) == "lpd://")
		    p["raw"] = true;
		if (substring (p["uri"]:"", 0, 12) == "filtering://")
		    p["uri"] = "lpd://" + substring (p["uri"]:"", 12);
		return p;
	    });
	}
	if (read_version < 521)
	{
	    printcap = maplist (map p, printcap, ``{
		p["options"] = $[];
		if (p["raw"]:false)
		    return p;
		return p;
	    });
	}
    }

    /**
      * Read settings of CUPS client-only
      * @return boolean true on success
      * TODO prefer lpoptions
      * TODO error handling
      */
    global define boolean cupsClientRead () ``{
	map state = SCR::Read (.target.ycp, "/var/lib/YaST2/printers");
	if (nil == state)
	{
	    state = $[];
	}
	server_default = state["server_default"]:true;
	default = state["default"]:"";
	return true;
    }

    global define boolean spoolerInitialize () ``{
	if (Spooler::Get () == "cups")
	{
	    if (`server == CUPS::InstallationType ())
	    {
		integer status = SCR::Execute (.target.bash,
		    "/usr/bin/lpq 2>/dev/null");
		if (status != 0)
		{
		    Spooler::RestartIfNeeded (true);
		}
	    }
	}
	else if (Spooler::Get () == "lprng")
	{
	    SCR::Execute (.target.bash,
		"/usr/bin/touch /etc/printcap; /bin/chmod u=rw,g=r,o=r /etc/printcap");
	    integer lpdaemon = SCR::Execute (.target.bash,
		 "test -f /etc/init.d/lpd && /etc/init.d/lpd restart");
	    if (lpdaemon != 0)
	    {
		// error report
	        Report::Error (_("Unable to restart the lpd daemon."));
	    }
	}
    }

    /**
      * Check if it is safe, ask user if needed, and detect local printers
      * @return boolean true on success
      * TODO error checking
      */
    global define boolean doPrinterDetection () ``{
	if (Printer::detect != false)
	    Printer::detect = Crash::AskRun ("printer_detection",
		// popup
		_("During the following step, YaST2 will try to detect local printers only.

Printer detection can now start. In some cases, detection can cause a
system freeze. If a freeze happens, select Skip Detection
when next running the printer configuration.

Detect your printers?"));

	if (Printer::detect)
	{
	    Crash::Run ("printer_detection");
	    Detect ();
	    Crash::Finish ("printer_detection");
	}
	return true;
    }

    /**
      * Read queues set for spooler
      * @return list of queues
      */
    global define list spoolerSpecQueuesRead () ``{
	if (Spooler::Get () == "cups")
        {
            return cupsRead();
        }
        if (Spooler::Get () == "lprng")
        {
            return printcapRead();
        }
	return [];
    }

    /**
      * Read the contents of /var/lib/YaST2/printers
      * @return boolean true on success
      * TODO error handling
      */
    global define boolean stateRead () ``{
	if (! Spooler::reread)
	{
	    printcap = filter (`e, printcap, ``(lookup (e, "type", "yast2") == "yast2"));
	}
	else
	{
	    printcap = [];
	    SCR::Execute (.target.bash, "/bin/touch /var/lib/YaST2/printers");
	    map state = SCR::Read (.target.ycp, "/var/lib/YaST2/printers");
	    if (nil == state)
	    {
		state = $[];
	    }
	    integer read_version = state["version"]:0;
	    if ( !(Spooler::Get () == "cups" && CUPS::InstallationType () == `client))
	    {
		printcap = state["printers"]:[];
	    }

	    updateConfig (read_version);

	    deleted = lookup (state, "deleted", []);
	    if (default == "" || default == nil)
		default = lookup (state, "default", "");
	    CUPS::usb_dev_names = state["cups_usb_devices"]:`always;
	    printcap = maplist (`e, printcap, ``(
		add (e, "type", "yast2")
	    ));
	}
	return true;
    }

    /**
      * Set unique keys after configuration reading
      */
    global define void setUniqueKeys () ``{
        original_unique_keys = $[];
        foreach (`i, printcap, ``{
            if (haskey (i, "unique_key"))
                original_unique_keys = add (original_unique_keys, lookup (i, "unique_key", ""), true);
        });
    }

    global define void updateStatesAfterRead (list nonyast) ``{
	list nyl = maplist (`e, nonyast, ``{return lookup (e, "name", "");});
	nyl = filter (`e, nyl, ``(e != ""));
	printcap = maplist (`e, printcap, ``{
	    boolean ready = contains (nyl, lookup (e, "name", ""));
	    string state = Spooler::Get () + "-state";
        // changed due to bug #19224, but I'm not sure, if it is really OK!
	    e[state] = ready ? e[state]:"changed" : "changed";
	    return e;
	});
    }

    /**
      * Remove queues from YaST2 config. files, that were deleted by other tool
      * @param nonyast list of non-yast queues
      */
    global define void removeDeletedQueues (list nonyast) ``{
	list nyl = maplist (`e, nonyast, ``{return lookup (e, "name", "");});
	nyl = filter (`e, nyl, ``(e != ""));
	if (Spooler::Get () == "cups")
	{
	    printcap = filter (`e, printcap, ``(
		contains (nyl, e["name"]:"")
		|| e["cups-state"]:"changed" != "commited"
	    ));
	}
	else if (Spooler::Get () == "lprng")
	{
	    printcap = filter (`e, printcap, ``(
		contains (nyl, e["name"]:"")
		|| e["lprng-state"]:"changed" != "commited"
	    ));
	}
    }

    /**
      * Add queues not added by YaST to list of queues
      * @param nonyast list of non-yast queues
      */
    global define void mergeNonYaST (list nonyast) ``{
	list yast2_queue_names = filter (string f,
	    maplist (map e, printcap, ``(e["name"]:"")),
	    ``(f != ""));
	list marked_for_delete =filter (string f,
	    maplist (map e, deleted, ``(e["name"]:"")),
	    ``(f != ""));

	if (Spooler::Get () == "cups")
	{
foreach (map e, nonyast, ``{y2error ("CR: %1", e);});

	    printcap = nonyast;
	    return;
	}

        foreach (`e, nonyast, ``{
            string name = lookup (e, "name", "");
	    if (! contains (marked_for_delete, name))
	    {
                if (! contains (yast2_queue_names, name))
                {
		    string uri = lookup (e, "uri", "");
		    e = add (e, "type", "nonYaST");
                    printcap = add (printcap, e);
                }
	        else if (Spooler::Get () == "cups")
	        {
		    printcap = maplist (`ye, printcap, ``{
		        if (lookup (ye, "name", "") == name)
			{
y2error ("CUPS record: %1", e);
			    if (lookup (ye, "uri", "") == "")
			    {
				ye = add (ye, "uri", lookup (e, "uri", ""));
			    }
			    foreach (string key, [
				"options", "ppd", "accepting", "bannerend",
				"bannerstart", "state", "allowusers",
				"denyusers", "ppd_info", "uri",
			    ], ``{
				if (e[key]:nil != nil)
				    ye[key] = e[key]:nil;
			    });
		        }
			return ye;
		    });
	        }
		else if (Spooler::Get () == "lprng")
		{
		    if (e["ppd"]:"" != "")
		        ye["ppd"] = e["ppd"]:"";
		    if (e["ppd_info"]:$[] != $[])
			ye["ppd_info"] = e["ppd_info"]:$[];
		}
	    }
        });
    }

    /**
      * Old read function, called from new Read function
      * TODO: better integrate
      * TODO: error handling
      * @return boolean true on success
      */
    global define boolean queuesRead () ``{
	// during installation, no queues are saved
	if (Mode::cont && ! Mode::update)
	    return true;
	boolean ret = true;
	list nonyast = spoolerSpecQueuesRead ();

	stateRead ();
//	removeDeletedQueues (nonyast);
	updateStatesAfterRead (nonyast);
	mergeNonYaST (nonyast);

	setUniqueKeys ();
	read_done = true;
	assignDefault ();
	if (! ret)
	{
	    // message box
	    Report::Error (_("Unable to read the current configuration."));
	}
        return ret;
     }
    /**
      * deletes printers
      * @param l list of strings representing names
      * @return success state
      */
    global define boolean deletePrinters (list l) ``{
	if (size (l) > 0)
	{
	    string command = "";
	    foreach (`printer, l, ``{
		string name = lookup (printer, "name", "");
		string p_type = lookup (printer, "type", "class");
		map states = lookup (printer, "states", $[]);
		if ("" != name)
		{
		    if (Spooler::Get () == "cups")
		    {
			if (lookup (states, "cups-state", "changed") != "commited")
			{
			    if (p_type == "class")
			    {
				SCR::Write (.cups.classes.remove, name);
			    }
			    else
			    {
				SCR::Write (.cups.printers.remove, name);
			    }
			}
		    }
		    else if (Spooler::Get () == "lprng")
		    {
			if (p_type != "class" && lookup (states, "lprng-state", "changed") != "commited")
			{
			    command = command +
				sformat ("/bin/rm -r /etc/lpdfilter/%1 /var/spool/lpd/%1; \n", name);
			    callLprsetup (sformat ("/usr/lib/lpdfilter/bin/lprsetup -lprng -delete %1", name));
			}
		    }
		}
	    });
	    if (command != "")
		SCR::Execute (.target.bash, command);
	}
	return true;
    }

    /**
     * Write settings.
     * @return success state
     */
    global define boolean Write () ``{
	y2milestone ("Write called; spooler: %1, cups inst type: %2", Spooler::Get (),
	    CUPS::InstallationType ());
	boolean with_daemon = Spooler::Get () != "cups"
	    || `client != CUPS::InstallationType ();
	y2milestone ("Daemon will run for this configuration: %1", with_daemon);
	if (with_daemon)
	{
	    // caption of progress
	    Progress::New (_("Saving settings of printers. Please wait..."),
		" ", size (printcap) + 6,
		    // progress bar states
		[ _("Adjust spooler services"),
		    // progress stage
		    _("Delete old printers"),
		    // progress bar states
		    _("Save printers"),
		    // progress bar states
		    _("Set default queue"),
		    // progress bar stage
		    _("Save system settings"),
		    // progress bas stage
		    _("Restart spooler"), ],
		    // progress step
		[ _("Adjusting spooler services..."),
		    // progress step
		    _("Deleting old printers..."),
		    // progress step
		    _("Saving printer..."),
		    // progress step
		    _("Setting default queue..."),
		    // progress step
		    _("Saving system settings..."),
		    // progress step
		    _("Restarting spooler..."),
		    // progress step
		    _("Finished")],
	    "");
	}
	else
	{
	    // caption of progress
	    Progress::New (_("Saving settings of printers. Please wait..."),
		" ", 2,
		    // progress stage
		[ _("Adjust spooler services"),
                    // progress stage
		    _("Save system settings"),],
		    // progress step
		[ _("Adjusting spooler services"),
                    // progress step
		    _("Saving system settings..."),
		    // progress step
		    _("Finished")],
	    "");
	}

	boolean ret = true;

	if (with_daemon && Spooler::Get () == "cups")
	{
	    CUPS::server_hostname = "";
	    CUPS::saveClientHostName ();
	    CUPS::writeCupsSettings ();
	}

	Progress::NextStage (); // adjst services
	if (testAbort ()) return false;
	ret = Spooler::AdjustServices (size (printcap) > 0) && ret;

	if (with_daemon)
	{
	    Progress::NextStage (); // delete old printers
	    if (testAbort ()) return false;
	    ret = deleteDeletedPrinters () && ret;

	    Progress::NextStage (); // save printers
	    if (testAbort ()) return false;
	    ret = savePrinters () && ret;

	    Progress::NextStage (); // set default queue
	    if (testAbort ()) return false;
	    ret = saveDefaultQueue () && ret;

	    Progress::NextStage (); // save system settings
	    if (testAbort ()) return false;
	    ret = saveTheConfiguration() && ret;

	    Progress::NextStage ();// restart spooler
	    if (testAbort ()) return false;
	    if (! write_only)
		ret = Spooler::restartServices (size (printcap) > 0) && ret;

	}
	else
	{
	    Progress::NextStage (); // save system settings
	    if (testAbort ()) return false;
	    ret = CUPS::saveCupsClient () && ret;
	    ret = saveTheConfiguration() && ret;
	}


	Progress::NextStage (); // finished
	if (testAbort ()) return false;
	// progress step
        Progress::Title(_("Finished"));
	sleep (500);
	return ret;
    }



    /**
      * Delete printers marked for being deleted
      * @return boolean true on success
      */
    global define boolean deleteDeletedPrinters () ``{
	// FIXME error checking
	deletePrinters (deleted);
	deleted = maplist (`e, deleted, ``{
	    map states = lookup (e, "states", $[]);
	    if (Spooler::Get () == "cups")
	    {
		states = add (states, "cups-state", "commited");
	    }
	    else if (Spooler::Get () == "lprng")
	    {
		states = add (states, "lprng-state", "commited");
	    }
	    e = add (e, "states", states);
	    return e;
	});
	return true;
    }

    global define boolean savePrinters () ``{
	// FIXME error checking
	list unique_keys = [];
	//
	// We are not sure if default printer exists, someone could have
	// deleted it. If default printer does not exist, set default
	// printer to "".
	//
	boolean default_printer_found = false;
	printcap = maplist (`entry, printcap, ``{
	    string uri = lookup (entry, "uri", "");
	    string name = lookup (entry, "name", "");
	    // progress title
	    Progress::Title (sformat (_("Saving printer %1"), name));
	    if (name == "")
	    {
		// error report. %1 is queue name
		Report::Error (sformat (_("Attempting to save unnamed printer. Skipping: %1"), ent));
		return;
	    }
	    string state = Spooler::Get () + "-state";
	    if (name == default && lookup (entry, state, "changed") != "void")
		default_printer_found = true;

	    string unique_key = lookup (entry,"unique_key", nil);
	    if (nil != unique_key)
	    {
		unique_keys = add (unique_keys, unique_key);
		original_unique_keys = add (original_unique_keys, unique_key, false);
	    }
	    entry = fixPrinter(entry);
	    if (Spooler::Get () == "cups")
	    {
		if (lookup (entry, "cups-state", "changed") == "void")
		{
		    Popup::Message (sformat(
			// popup %1 is queue name
			_("Queue %1 cannot be saved because
the selected spooler does not support it."), name));
		}
		else if ((lookup (entry, "cups-state", "changed") == "changed" || Spooler::save_all) && (lookup (entry, "type", "yast2") == "yast2"))
		{
		    y2debug ("Saving printer %1", entry);
		    if (writeCupsPrinter (entry))
		    {
			y2debug ("Success");
			entry = add (entry, "cups-state", "commited");
		    }
		}
	    }
	    else if (Spooler::Get () == "lprng")
	    {
		if (lookup (entry, "lprng-state", "changed") == "void")
		{
		    Popup::Message (sformat(
			// popup %1 is queue name
			_("Queue %1 cannot be saved because
the selected spooler does not support it."), name));
		}
		else if ((lookup (entry, "lprng-state", "changed") == "changed" || Spooler::save_all) && (lookup (entry, "type", "yast2") == "yast2"))
		{
		    if (writeLpdPrinter (entry))
			entry = add (entry, "lprng-state", "commited");
		}
	    }
	    Progress::NextStep ();
	    return entry;
	});
	if (Spooler::Get () != "cups")
	{
	    // set 0644 mode to /etc/printcap (file does not exist if there is no printer)
	    if (-1 != SCR::Read(.target.size, "/etc/printcap"))
		SCR::Execute (.target.bash, "/bin/chmod 0644 /etc/printcap");
	}

	// Save unique_keys for autedetected printers to libhd
	foreach (`k, `v, original_unique_keys, ``{
	    SCR::Write (.probe.status.configured, k, v ? `no : `yes);
	});
	if (! default_printer_found)
	    default = "";
	return true;
    }

    global define boolean saveDefaultQueue () ``{
	if (Spooler::Get () == "cups")
	{
	    SCR::Write (.cups.default_dest, default);
	}
	else
	{
	    SCR::Execute (.target.bash, sformat ("/usr/lib/YaST2/bin/assign_printcap_default %1", default != "" ? default : "\"\""));
	}
	return true;
    }

    /**
      * Remove from deleted printers list printers which are deleted from both spoolers and which were recreated
      */
    define void cleanDeletedPrinters () ``{
	//remove deleted from all spoolers from list
	deleted = filter (`e, deleted, ``{
	    map states = lookup (e, "states", $[]);
	    boolean res = false;
	    foreach (`k, `v, states, ``{
		if (v != "commited")
		    res = true;
	    });
	    return res;
	});
    }

    /**
      * Remove from list of deleted printers suplicated entries
      */
    define void removeDuplicatedDeletedPrinters () ``{
	map tmp = $[
	    "class" : $[],
	    "printer" : $[],
	];
	foreach (map d, deleted, ``{
	    if (! haskey (tmp[(d["type"]:"printer")]:$[], d["name"]:""))
	    {
		tmp[d["type"]:"printer", d["name"]:""] = d["states"]:$[];
	    }
	    else
	    {
		map old_states = tmp[d["type"]:"printer", d["name"]:""]:$[];
		map new_states = d["states"]:$[];
		old_states = mapmap (`k, `v, old_states, ``{
		    if (v != "changed")
			v = new_states[k]:"changed";
		    return [k, v];
		});
		tmp[d["type"]:"printer", d["name"]:""] = old_states;
	    }
	});
	deleted = merge (
	    maplist (`k, `v, tmp["class"]:$[], ``(
		$[
		    "type" : "class",
		    "name" : k,
		    "states" : v,
		]
	    )),
	    maplist (`k, `v, tmp["printer"]:$[], ``(
		$[
		    "type" : "printer",
		    "name" : k,
		    "states" : v,
		]
	    ))
	);
    }

    /**
     * Write /var/lib/yast2/printers
     * @return boolean true if successful
     */

    define boolean saveTheConfiguration () ``{
	list l = filter (`e, printcap, ``(lookup (e, "type", "yast2") == "yast2"));
	list forbidden_keys = ["changed", "ppd", "ppd_info", "auto_propose",
	    "modelset_required", "composite", "comment", "saved",
	    "newer_gs_upp", "database", "options", "ownppd", "accepting",
	    "bannerend", "bannerstart", "state", "allowusers", "denyusers",
	    "ppd_options", "config", "detected", "vendor_ieee", "device_ieee",
	    "vendor_db", "device_db", "info", "location", 
	];
	l = maplist (`e, l, ``(filter (`k, `v, e,
	    ``(! contains (forbidden_keys, k)))));
	removeDuplicatedDeletedPrinters ();
	cleanDeletedPrinters ();
	map save = $[
	    "printers" : l,
	    "deleted" : deleted,
	    "default" : default,
	    "cups_usb_devices" : CUPS::usb_dev_names,
	    "server_default" : server_default,
	];
	save["version"] = version;
	if (! SCR::Write (.target.ycp, "/var/lib/YaST2/printers", save))
	{
	    // error report. %1 is filename
	    Report::Error (sformat (_("Cannot write %1."), "/var/lib/YaST2/printers"));
	    return false;
	}
	// It can contain Samba/Novell passwords...
	SCR::Execute (.target.bash, sformat ("/bin/chmod 600 %1", "/var/lib/YaST2/printers"));
	return true;
    }

    /**
      * separates from config map only values of specified type
      * @param config Map of configuration
      * @param type String specifying type
      * @return map of selected values
      */
    global define map getArgsOfType (map config, string type) ``{
	map result = $[];

	foreach (`k, `v, config, ``{
	    map valmap = lookup (config, k, $[]);
	    string value = lookup (valmap,type,"");
	    if (value != "") {
		result = add (result, k, value);
	    }
	});
	return result;
    }

    /**
     * Write conf file onto disk.
     * @param fn filename
     * @param conf file contents
     */
    define void writeConf (string fn, map conf) ``{
	string s = "#\n# for documentation see /usr/lib/lpdfilter/global/optional.options\n#\n\n";
	foreach (`k, `v, conf, ``{
	    s = s + sformat ("%1=\"%2\"\n", k, v);
	});
	SCR::Write (.target.string, fn, s);
	SCR::Execute (.target.bash, sformat ("/bin/chmod 660 %1 ; /bin/chown lp:lp %1", fn));
    }

    /**
     * Create string with the definition of samba print command
     * @param uri Uri of the printer
     * @return string string with definition
     */
    define string getRemoteEntry (string uri) ``{
	boolean type = (("novell" == Printerlib::getUriType (uri)) ? true : false);
	list up = Printerlib::getUriUsernamePass (uri);
	string user = "";
	string pass = "";
	if (select (up, 0, "") != "")
	    user = sformat ("-U \"%1\"", select (up, 0, ""));
	if (select (up, 1, "") != "") // -P only for non empty novell printer
	    pass = ((type ? "-P " : "") + sformat ("\"%1\"", select (up, 1, "")));

	return type ?
	    sformat ("/usr/lib/lpdfilter/redirect/novell_print -S %1 %2 %3 -q \"%4\" -\n",
		    Printerlib::getUriHost (uri), user, pass, Printerlib::getUriRemoteQueue (uri))
	    :
	    sformat ("/usr/lib/lpdfilter/redirect/samba_print //%1/\"%2\" %3 %4 -N -P\n",
		    Printerlib::getUriHost (uri), Printerlib::getUriRemoteQueue (uri), pass, user);
    }
    /**
     * Create .upp file from the options. Note that there can be depended options.
     * @param options Options list
     * @return string upp file content
     */
    define string optionsToString (list options) ``{
	string upp = "";
	if (nil != options)
	{
	    foreach (`opt, options, ``{
		integer defaultindex = lookup (opt,"defaultindex", nil);
		string def = lookup (opt, "default", "");
		list val = lookup (opt,"values", []);
		list depended_opt = lookup (select (val,0, $[]),"options", nil);
		if (nil != defaultindex)
		{
		    def = lookup (select (val,defaultindex, $[]),"value", nil);
		    depended_opt = lookup (select (val,defaultindex, $[]),"options", nil);
		}
		//else if there is no defaultindex, no changes were made, so let "default"
		if (def != "")
		    upp = upp+sformat ("%1\n", def);
		// if there is no defaultindex, no suboptions can be here
		if (nil != depended_opt)
		    upp = upp+optionsToString (depended_opt);
	    });
	}
	return upp;
    }
    /**
     * Creates summary from autodetected printers and printcap.
     * @param style type of summary - list of symbols - flags:
     *		`test: add test link<br>
     *		`nonew: do not include new -- unconfigured printers into summary<br>
     *		`short: short summary doesn't contain queue description
     *		`state: show printer state
     * @return summary string
     */
    global define string Summary (list style) ``{
	if (Spooler::Get () == "cups" && CUPS::cups_installation == `client)
	{
	    string ret =
                // summary text
                // %1 is info about config status of the server
		sformat (_("<LI>CUPS Client-Only Configuration:<BR>%1</LI>"),
			// summary text part
			// %1 server name
		    sformat (_("using server %1."), CUPS::server_hostname));
	    list servers = filter (`s, cups_servers, ``(s != CUPS::server_hostname));
	    servers = toset (servers);
	    if (size (servers) > 0)
	    {
		// sumary text
		ret = ret + sformat(_("<li>Other Detected Servers:<br>%1</li>"),
		    mergestring (servers, ", "));
	    }
	    ret = "<UL>" + ret + "</UL>";
	    return ret;
	}
	// Configured as name_of_queue.
	string format = contains (style, `short) ? _("Configured as %1.")
	// Configured as name_of_queue.
	: _("Configured as:<br>%1");
	list summary = [];
	list used = [];
	// autodetected printer
//	y2milestone ("Listing autodetected");
	foreach (`i, autodetected, ``{
	    string found = "";
	    string vendor = lookup (i, "vendor", "");
	    string model = lookup (i, "device", "");
	    string dev = sformat ("%1 %2: %3", vendor, model, Printerlib::getUriNiceName (lookup (i, "uri", "")));
	    foreach (`entry, printcap, ``{
		if (lookup (i, "unique_key", "") == lookup (entry, "unique_key", " "))
		{
		    entry = assignStates (entry, false);
		    string cache = lookup (entry, "name", "");
		    used = add (used, cache);
		    if (contains (style, `test))
		    {
y2error ("Printer to sum: %1", entry);
			if ((Spooler::Get () == "cups" && lookup (entry, "cups-state", "") != "void")
			    || (Spooler::Get () == "lprng" && lookup (entry, "lprng-state", "") != "void"))
			{
			    cache = sformat ("%1 [<a href=\"%1\">test</a>]", cache);
			}
		    }
		    if (contains (style, `short))
		    {
			found = found + ("" != found ? ", " : "") + cache;
		    }
		    else
		    {
			string state = "";
			if (Spooler::Get () == "cups")
			    state = entry["cups-state"]:"changed";
			else if (Spooler::Get () == "lprng")
			    state = entry["lprng-state"]:"changed";
			if (state != "" && state != nil)
			{
			    if (state == "commited")
			    {
				state = " - " + HTML::Colorize (
				    // summary part, printer state
				    _("ready"), "green");
			    }
			    else if (state == "changed")
			    {
				state = " - " + HTML::Colorize (
				    // summary part, printer state
				    _("changed, not yet saved"), "orange");
			    }
			    else if (state == "void")
			    {
				// summary part, printer state
                                state = " - " + HTML::Colorize (
                                    _("invalid for current spooler"), "red");
			    }
			    else state = "";
			}
			found = found + ("" != found ? "<br>" : "") + cache + state;
		    }
		}
	    });
	    if ("" == found)
	    {
		if (!contains (style, `nonew))
		    summary = add (summary, Summary::Device (dev, Summary::NotConfigured ()));
	    }
	    else
		summary = add (summary, Summary::Device (dev, contains (style, `short) ? sformat (format, found) : sformat (format + "<br>", found)));
	});
//	y2milestone ("Listing others");
	// other than autodetected printers
	map other_printers = $[];
	foreach (`i, printcap, ``{
	    string cache = lookup (i, "name", "");
	    if (!contains (used, cache))
	    {
		string type = lookup (i, "type", "yast2");
		string cfg = "";
		if (type == "yast2")
		{
		    string model = "";
		    model = i["ppd_info", "manufacturer"]:"" + " "
			+ i["ppd_info", "model"]:"";

		    if (model == " ")
		    {
			string ppd = i["ppd"]:"";
			if (isPpd (ppd))
			{
			    map info = i["ppd_info"]:$[];
			    model = info["manufacturer"]:"" + " "
				+ info["model"]:"";
			}
		    }

		    i = assignStates (i, false);
		    boolean raw = i["raw"]:false;
		    string dev = (raw ?
			// menu item, %1 is URI
			sformat (_("Raw queue: %1"), Printerlib::getUriNiceName (lookup (i, "uri", "")))
			:
			sformat ("%1: %2", model, Printerlib::getUriNiceName (lookup (i, "uri", "")))
		    );
		    if (contains (style, `test))
		    {
			if ((Spooler::Get () == "cups" && lookup (i, "cups-state", "") != "void")
			    || (Spooler::Get () == "lprng" && lookup (i, "lprng-state", "") != "void"))
			{
			    cache = sformat ("%1 [<a href=\"%1\">test</a>]", cache);
			}
		    }
		    if (!contains (style, `short))
		    {
			if (nil != cfg && "" != cfg)
			    cache = cache + "  -  " + cfg;

                        string state = "";
                        if (Spooler::Get () == "cups")
                            state = i["cups-state"]:"changed";
                        else if (Spooler::Get () == "lprng")
                            state = i["lprng-state"]:"changed";
                        if (state != "" && state != nil)
                        {
                            if (state == "commited")
                            {
                                state = " - " + HTML::Colorize (
                                    // summary part, printer state
				    _("ready"), "green");
                            }
                            else if (state == "changed")
                            {
                                state = " - " + HTML::Colorize (
                                    // summary part, printer state
				    _("changed, not yet saved"), "orange");
                            }
                            else if (state == "void")
                            {
                                state = " - " + HTML::Colorize (
                                    // summary part, printer state
				    _("invalid for current spooler"), "red");
			    }
                            else state = "";
                        }
			cache = cache + state;
		    }
		    if (haskey (other_printers, dev))
			other_printers = add (other_printers, dev, lookup (other_printers, dev, "???") + (contains (style, `short) ? ", " : "<br>") + cache);
		    else
			other_printers = add (other_printers, dev, cache);
		}
		else
		{
		    // This printer was not configured using YaST2. Item in table. SHORT!
		    if (contains (style, `test))
			cache = sformat ("%1"/* [<a href=\"%1\">test</a>]"*/, cache);
		    // menu item part
		    if (haskey (other_printers, _("- not YaST2 -")))
			// menu item part
			other_printers = add (other_printers, _("- not YaST2 -"), lookup (other_printers, _("- not YaST2 -"), "???") + ", " + cache);
		    else
			// menu item part
			other_printers = add (other_printers, _("- not YaST2 -"), cache);
		}
	    }
	});
	foreach (`k, `v, other_printers, ``{
	    summary = add (summary, Summary::Device (k, sformat (format, v)));
	});
	if (Spooler::Get () == "cups")
	{
	    if (CUPS::cups_server_settings["Browsing"]:"On" == "On")
	    {
		// part of summary
		summary = add (summary, _("<LI>Listen to remote CUPS servers to get comfortable access to remote queues.</LI>"));
	    }
	}
	return Summary::DevicesList (summary);
    }
    /**
     * get list of names of deleted printers.
     * @return List of names.
     */
    global define list DeletedNames () ``{
	return toset (maplist (`i, deleted, ``(lookup (i, "name", ""))));
//	return toset (union (deleted, deleted_classes));
    }

    /**
     * Get type of currently selected printer. Just a shortcut
     * to Printerlib::getUriType (...)
     * @return printer type
     */
    global define string getUriType () ``{
	return Printerlib::getUriType (lookup (printer, "uri", ""));
    }


    /**
     * Constructor only grabs Args
     */
    global define void Printer () ``{
	integer i = 0;
	while (i < size (Args ()))
	{
	    i = i + 1;
	}
	return ;
    }
    /**
     * Prepare detected printer to be configured.
     * @param det map of detected printer
     */
    global define void editDetected (map det) ``{
	index = -1;
	y2debug ("Editing printer %1", det);
	string config = Printerdb::getAutoPpdFile (
	    det["vendor_db"]:"", det["device_db"]:"", nil);
	string filename = Printerdb::foomatic[det["vendor_db"]:"",
	    det["device_db"]:"", config, "filename"]:"";
	y2error ("Filename: %1", filename);
	filename = SCR::Read (.ppd.file.open,
	    [filename, SCR::Read (.target.tmpdir)]);
	printer = $[
	    "detected" : det,
	    "unique_key" : det["unique_key"]:"",
	    "uri" : det["uri"]:"",
	    "info": det["info"]:"",
            "location": det["location"]:"",
            "accepting": true,
            "state": "idle",
	    "options" : $[],
	    "name" : generateQueueName (nil, det["uri"]:"",
		det["vendor_db"]:"", det["device_db"]:"",
		getForbiddenNames ()),
	    "ppd" : filename,
	    "ppd_info" : ppdInfo (filename),
	];
	y2milestone ("Detected printer after editation: %1", printer);
    }
    /**
     * Has the printer been already configured?
     * @param uk unique key of the printer
     * @return true or false
     */
    global define boolean alreadyConfigured (string uk) ``{
	boolean was = false;
	foreach (`i, printcap, ``{
	    if (!was && lookup (i, "unique_key", ".a") == uk)
		was = true;
	});
	return was;
    }

    /**
     * Autoconfigure all printers that haven't been configured yet.
     */
    global define void Propose () ``{
	if (Spooler::Get () == "cups")
	    Printerlib::setCupsUsbDevicesInfo ();
	// settings are read and hw is detected
	list forbidden_names = getForbiddenNames ();
	symbol page_size = Printerlib::getDefaultPaperSize ();
	foreach (`i, autodetected, ``{
	    if (!alreadyConfigured (i["unique_key"]:""))
	    {
		editDetected (i);
		string vdb = printer["detected", "vendor_db"]:"";
		string mdb = printer["detected", "device_db"]:"";
		string ppd_file = Printerdb::getAutoPpdFile (vdb, mdb, nil);
		string support = Printerdb::foomatic[vdb, mdb, `support]:"";
		boolean configure = (support == "full" || support == "partially"
		    || support == "");
		if (ppd_file != nil && configure)
		{
		    boolean ok = true;
		    printer["name"] = generateQueueName (nil, printer["uri"]:"",
			printer["vendor"]:"", printer["device"]:"",
			getForbiddenNames ());
		    foreach (string paperentry, ["ImageableArea",
			"PageRegion", "PageSize", "PaperDimension"],
		    ``{
			if (page_size == `letter)
			    printer["options", paperentry] = "Letter";
			else
			    printer["options", paperentry] = "A4";
		    });
		    if (ok)
		    {
			printer = assignStates (printer, true);
			y2milestone ("Configuring autodetected printer %1",
			    printer);
			storePrinter ();
		    }
		}
	    }
	});
	assignDefault ();
    }
    /**
     * Check if queue name is OK. Otherwise adds number at the end.
     * @param name printer name
     * @param forbidden_names forbidden names
     * @return new queue name.
     */
    global define string adjustQueueName (string name, list forbidden_names) ``{
	if (!contains (forbidden_names, name))
	    return name;
	name = name + "%1";
	integer i = 1;
	while (contains (forbidden_names, sformat (name, i)))
	{
	    i = i + 1;
	}
	return sformat (name, i);
    }
    /**
     * Get the suffix for the queue name.
     * @param queues list of new queues. Keys are the names of the queues.
     * @return suffix
     */
    global define string getQueueSuffix (list queues) ``{
	integer highest = 0;
	integer work = 0;
	foreach (`v, queues, ``{
	    integer end = size (lookup (v, "name", ""));
	    foreach (`i, printcap, ``{
		if (substring (lookup (i, "name", ""), 0, end) == lookup (v, "name", ""))
		{
		    if (regexpmatch (substring (lookup (i, "name", ""), end),
			"^[0-9]*$"))
		    {
			string workstr = substring (i["name"]:"", end);
			if (workstr != "")
			    work = tointeger (workstr);
			else
			    work = 0;
			if (work + 1 > highest)
			    highest = work + 1;
		    }
		}
	    });
	});
	if (0 == highest)
	    return "";
	return sformat ("%1", highest);
    }
    /**
      * does file exist?
      * @param file string filename to test
      * @return true if exists
      */
    global define boolean isFile (string file) ``{
	integer filesize = SCR::Read (.target.size, file);
	if (filesize < 0)
	    return false;
	return true;
    }
    /**
      * Is file a ppd file?
      * @param file string filename to test
      * @return true if yes
      */
    global define boolean isPpd (string file) ``{
	if (! isFile (file))
	    return false;
	return SCR::Read (.ppd.file.isppd, file);
    }
    /**
      * Get PPD file info
      * @param file string filename to get info from
      * @return map of informations
      */
    global define map ppdInfo (string file) ``{
	return SCR::Read (.ppd.file.ppdinfo, file);
    }
    /**
      * Add unpresent entries into a map
      * @param p map of printer
      * @return modified map
      */
    global define map fixPrinter (map p) ``{
	if (p["accepting"]:true == true)
	    p["accepting"] = true;
	if (p["state"]:"idle" == "idle")
	    p["state"] = "idle";
	if (p["bannerstart"]:"" == "")
	    p["bannerstart"] = "none";
	if (p["bannerend"]:"" == "")
	    p["bannerend"] = "none";
	if (p["allowusers"]:[] == [])
	    p["allowusers"] = [];
	if (p["denyusers"]:[] == [])
	    p["denyusers"] = [];
	return p;
    }


    /**
     * TODO: create test case
     * @param name printer name
     * @param uri string queue uri
     * @param vendor_name string name of the printer vendor
     * @param device_name string name of the printer device
     * @param forbidden_names list of forbidden names
     * @return new queue name
     */
    global define string generateQueueName (string name, string uri,
	string vendor_name, string device_name, list forbidden_names)
    ``{
	if (name == nil)
	{
	    name = "";
	    string uri_type = Printerlib::getUriType (uri);
	    if (contains (["lpd", "ipp", "samba", "novell"], uri_type) && Printerlib::getUriRemoteQueue (uri) != "")
	    {
	        name = Printerlib::getUriRemoteQueue (uri);
	        integer i = findlastof (name, "/");
	            if (i != nil)
		    name = substring (name, i);
	        name = filterchars (name,
		    "_0123456789abcdefghijklmnopqrstuvwxyz");
		if (size (name) >= 20)
		    name = substring (name, 0, 20);
	    }
	    if (name == "" && device_name != "")
	    {
	        name = filterchars (
		    tolower (vendor_name + "_" + device_name),
		    "_0123456789abcdefghijklmnopqrstuvwxyz");
		if (size (name) >= 20)
		{
		    name = filterchars (
			tolower (device_name),
			"_0123456789abcdefghijklmnopqrstuvwxyz");
		}
		if (size (name) >= 20)
		    name = substring (name, 0, 20);
	    }
	if (name == "")
	    name = "printer";
	}

	integer i = 1;
	string original = name;
	while (contains (forbidden_names, name))
	{
	    name = sformat ("%1%2", original, i);
	    i = i + 1;
	}
	return name;
    }




}
