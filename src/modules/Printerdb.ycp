/**
 * File:
 *   modules/Printerdb.ycp
 *
 * Package:
 *   printer configuration tool
 *
 * Summary:
 *   Defines for handling PPD files and database of PPD files
 *
 * Authors:
 *  Jiri Srain <jsrain@suse.cz>   2002
 *
 * $Id$
 *
 */

{
    module "Printerdb";

    textdomain "printer";

    import "Label";
    import "Mode";
    import "Printerlib";
    import "Report";
    import "Spooler";

// global variables

    /**
      * map of foomatic printers database
      */
    global map foomatic = nil;

// local functions

    /**
      * Get the default encoding of the PPD file according to the language
      * @param language string language in the form it is present in PPD file
      * @return encoding in the form it is present in PPD file
      */
    global define string Language2Encoding (string language) ``{
	map mapping = $[
	    "English" : "ISOLatin1",
	    "Danish" : "ISOLatin1",
	    "Dutch" : "ISOLatin1",
	    "Finnish" : "ISOLatin1",
	    "French" : "ISOLatin1",
	    "German" : "ISOLatin1",
	    "Italian" : "ISOLatin1",
	    "Japanese" : "JIS83-RKSJ,",
	    "Norwegian" : "ISOLatin1",
	    "Portuguese" : "ISOLatin1",
	    "Spanish" : "ISOLatin1",
	    "Swedish" : "ISOLatin1",
	    "Czech" : "ISOLatin2",
	];
	return mapping[language]:"None";
    }

    /**
      * Get the characters encoding from the form in it is present in PPD file
      * to the form that can be passed to iconv
      * @param ppd_enc string encoding in the form for PPD file
      * @return string encoding in the form for iconv
      */
    global define string PPDenc2UIenc (string ppd_enc) ``{
	map mapping = $[
	    "ISOLatin1" : "ISO-8859-1",
	    "ISOLatin2" : "ISO-8859-2",
	    "ISOLatin5" : "ISO-8859-5",
	    "JIS83-RKSJ" : "SHIFT-JIS",
	    "MacStandard" : "MAC",
	    "WindowsANSI" : "MS_ANSI",
	];
	return mapping[ppd_enc]:"";
    }

// global functions

    /**
     * Get the options of the PPD file
     * @param filename string file name of the PPD file
     * @return list of all options of the PPD file (in UTF-8)
     */
    global define list<map> getPpdFileOptions (string filename) ``{
	map options = (map)SCR::Read (.ppd.file.options, [filename, ""]);
	list<map> optlist = options["data"]:[];
	y2debug ("First option: %1", optlist[0]:$[]);
	optlist = filter (map o, optlist, ``(
	    o["name"]:"" != "PageRegion"
	    && o["name"]:"" != "ImageableArea"
	    && o["mame"]:"" != "PaperDimension"));

	// change the encoding of printable strings
	map ppdinfo = (map)SCR::Read (.ppd.file.ppdinfo, filename);
	string encoding = ppdinfo["lang_encoding"]:"";
	if (encoding == "")
	    encoding = Language2Encoding (ppdinfo["lang_version"]:"");
	encoding = PPDenc2UIenc (encoding);
	if (encoding != "")
	{
	    optlist = maplist (map o, optlist, ``{
		if (o["name"]:"" != "PageSize"
		    && o["name"]:"" != "InputSlot")
		{
		    o["gui"] = UI::Recode (encoding, "UTF-8", o["gui"]:"");
		}
		o["values"] = mapmap (string k, string v, o["values"]:$[], ``{
		    if (k != "Custom" && o["name"]:"" != "PageSize")
		    {
			v = (string)UI::Recode (encoding, "UTF-8", v);
		    }
		    return $[k: v];
		});
		return o;
	    });
	}
	return optlist;
    }

    /**
      * Get proposed default queue when using foomatic db
      * @param queues list of queues
      * @return proposed default queue name
      */
    global define string getFoomaticDefaultQueue (list<any> queues) ``{
        string default_queue = (string) (queues[0, "name"]:nil);
        foreach (map q, queues, ``{
            if (regexpmatch (q["name"]:"", "normal[0-9]")
                 || q["name"]:"" == "normal")
            {
                default_queue = q["name"]:"";
            }
        });
        return default_queue;
    }

    /**
      * Check whether foomatic database has been loaded, and if not, then
      * load it
      */
    global define void loadFoomaticIfNeeded () ``{
        if (foomatic != nil)
            return;
	boolean contains_flag = 0 == SCR::Execute (.target.bash, "/bin/grep '#this database was generated during package building' /var/lib/YaST2/ppd_db.ycp");
        y2milestone ("Checking foomatic database");
        if (((boolean)SCR::Read (.ppd.db.changed) || contains_flag) && ! Mode::test)
        {
            y2milestone ("Database changed");
            boolean fast_update = false;
            if (Mode::cont)
            {
                fast_update = true;
                SCR::Write (.ppd.db.check_method, `size);
            }
            SCR::Write (.ppd.db.create, "");
            UI::OpenDialog (`VBox (
                `HSpacing (50),
                `ProgressBar (`id(`pr),
                        // progress bar label
                        _("The list of installed drivers has changed.
Building database of drivers..."), 100, 0)));
            integer result = 0;
            while (true)
            {
                    result = (integer)SCR::Read (.ppd.db.creation_status);
                    if (result < 0)
                        break;
                    if (result == 100)
                        break;
                    UI::ChangeWidget (`id (`pr), `Value, result);
                    sleep (1000);
            }
            UI::CloseDialog ();
            if (result < 0)
            {
                    // error report
                    Report::Error (_("An error occurred while creating the database
of printers.
"));
            }
            if (fast_update)
            {
                SCR::Write (.ppd.db.check_method, `checksum);
            }
        }
        foomatic= (map)SCR::Read (.target.ycp, "/var/lib/YaST2/ppd_db.ycp");
    }

    /**
      * Sort PPD files according to preference list
      * @param vendor_db string vendor database key
      * @param device_db string model database key
      * @param ppd_nicks list of PPD file nicknames, if nil, then PPD nicknames
      *   are taken from foomatic database
      * @return list of sorted PPD nicknames
      */
    global define list sortPpds (string vendor_db, string device_db,
	list ppd_nicks)
    ``{
	vendor_db = (string)SCR::Read (.ppd.db.vendorname, vendor_db);
	device_db = (string)SCR::Read (.ppd.db.modelname, [vendor_db, device_db]);
        SCR::Execute (.target.bash, sformat (
	    "/usr/bin/touch %1/ppd_preference_list",
	    Printerlib::baseDataDir));
        map order = (map)SCR::Read (.target.ycp,
	    sformat ("%1/ppd_preference_list", Printerlib::baseDataDir));
        if (order == nil)
            order = $[];

        list<string> preferred = [];
        foreach (string k, map v, order, ``{
            if (regexpmatch (vendor_db, k))
            {
                foreach (string kk, list vv, v, ``{
                    if (regexpmatch (device_db, kk))
                    {
                        y2debug ("Matched %1, %2", k, kk);
                        preferred = order[k, kk]:[];
                    }
                });
                if (preferred == [])
                {
                    preferred = order[k, "__default__"]:[];
                }

            }
        });
        if (preferred == [])
            preferred = order["__default__"]:[];
        y2debug ("Order preferred list: %1", preferred);

        map recom = $[];
        map other = $[];
	map downrec = $[];
	map downoth = $[];
	loadFoomaticIfNeeded ();
	map ppds = $[];

	if (ppd_nicks == nil)
	    ppds = filter (`k, `v, foomatic[vendor_db, device_db]:$[],
		``(is (k, string)));
	else
	    ppds = listmap (string k, ppd_nicks, ``($[k: $[]]));

        foreach (string k, map v, ppds, ``{
            boolean found = false;
            foreach (string i, preferred, ``{
                if (! found && regexpmatch (k, i))
                {
		  if (issubstring (v["filename"]:"",
		    "/usr/share/cups/model/downloaded/"))
		  {
                    if (issubstring (k, "(recommended)"))
                    {
                        downrec[i] = add (downrec[i]:[], k);
                    }
                    else
                    {
                        downoth[i] = add (downoth[i]:[], k);
                    }
		  }
		  else
		  {
                    if (issubstring (k, "(recommended)"))
                    {
                        recom[i] = add (recom[i]:[], k);
                    }
                    else
                    {
                        other[i] = add (other[i]:[], k);
                    }
		  }
                  found = true;
                }

            });
            if (! found)
            {
	      if (issubstring (v["filename"]:"",
		"/usr/share/cups/model/downloaded/"))
	      {
                if (issubstring (k, "(recommended)"))
                {
                    downrec["other"] = add (downrec["other"]:[], k);
                }
                else
                {
                    downoth["other"] = add (downoth["other"]:[], k);
                }
	      }
	      else
	      {
                if (issubstring (k, "(recommended)"))
                {
                    recom["other"] = add (recom["other"]:[], k);
                }
                else
                {
                    other["other"] = add (other["other"]:[], k);
                }
	      }
            }
        });

        list result = [];

        y2debug ("Recom: %1, other: %2", recom, other);
	y2debug ("Downloaded: Recom: %1, other: %2", downrec, downoth);

        foreach (`i, preferred, ``{
            result = merge (result, downrec[i]:[]);
        });
        result = merge (result, downrec["other"]:[]);

        foreach (`i, preferred, ``{
            result = merge (result, downoth[i]:[]);
        });
        result = merge (result, downoth["other"]:[]);


        foreach (`i, preferred, ``{
            result = merge (result, recom[i]:[]);
        });
        result = merge (result, recom["other"]:[]);

        foreach (`i, preferred, ``{
            result = merge (result, other[i]:[]);
        });
        result = merge (result, other["other"]:[]);

        y2debug ("Sorted PPD files: %1", result);
        return result;
    }


    /**
      * Get the PPD file for automatic installation
      * @param vendor_db string vendor database key
      * @param device_db string model database key
      * @param ppd_nicks list of PPD file nicknames, if nil, then PPD nicknames
      *   are taken from foomatic database
      * @return name of the PPD file (of database, not filename),
      *   nil if no is usable
      */
    global define string getAutoPpdFile (string vendor_db, string device_db,
	list ppd_nicks)
    ``{
	list ppds = sortPpds (vendor_db, device_db, ppd_nicks);
	if (size (ppds) == 0)
	    return nil;
	if (Spooler::Get () == "cups")
	    return (string) (ppds[0]:nil);
	// for LPRng find first with foomatic-rip as filter
	return (string)find (string s, ppds, ``(
	    foomatic[vendor_db, device_db, s, "filter"]:""
		== "foomatic-rip"));
    }

    /**
      * Get PPD file updated according to printer options and add it's name to
      * printer description map
      * @param entry map of printer
      * @return map updated printer map
      */
    global define map getUpdatedPpdFile (map entry) ``{
        string src_ppd = entry["ppd"]:"";
	string dst_ppd = (string)SCR::Read (.target.tmpdir) + "/patched_ppd_"
	    + entry["name"]:"";
	if (! Mode::test)
	{
	    while (SCR::Read (.target.size, dst_ppd) > 0)
		dst_ppd = dst_ppd + "x"; // FIXME this isn't the best
			// solution, but should work fine, EXCEPT TESTSUITES
	}
        boolean raw = entry["raw"]:false;
        if (raw)
        {
            entry["ppd"] = "";
	    return entry;
        }

	if (src_ppd == "")
	{
	    // message popup
	    Report::Error (sformat (_("An error occurred while saving queue %1.

Incorrect internal data. Try selecting the
printer model again.
"), entry["name"]:""));
	    return nil;
	}

	SCR::Write (.ppd.file.modify,
	    [src_ppd, dst_ppd, entry["ppd_options"]:$[]]);
	entry["ppd"] = dst_ppd;
//	SCR::Execute (.target.remove, src_ppd);
        return entry;
    }


    /**
      * get configurations, which may be usable for detected printer
      * @param vendor_db string name of printer vendor
      * @param device_db string printer model name
      * @return map of ppd files (filename -> description)
      */
    global define map getPpdFiles (string vendor_db, string device_db) ``{
	loadFoomaticIfNeeded ();
	map ppd_db = foomatic[vendor_db, device_db]:$[];
	ppd_db = filter (`k, `v, ppd_db, ``(is (k, string)));
	map ret = mapmap (string k, map v, ppd_db, ``{
	    string filename = v["filename"]:"";
	    return $["filename" : k];
	});
	ret = filter (`k, `v, ret, ``(k != "" && v != ""));
	return ret;
    }

    /**
      * Process downloaded PPD files
      * @param dir string directory with downloaded PPD files
      * @return boolean true on success
      */
    global define boolean processPpdFiles (string dir) ``{
	string log = dir + "/log";
	string target_dir = "/usr/share/cups/model/downloaded";
	integer test = (integer)SCR::Execute (.target.bash, sformat (
	    "/usr/lib/YaST2/bin/process_ppd_files %1 %2 %3", dir,
	    target_dir, log));
	y2milestone ("Test status: %1", test);
	if (test != 0)
	{
	    term text = `RichText (`opt (`plainText), SCR::Read (.target.string, log));
	    UI::OpenDialog(`opt ( `decorated ),
		`VBox (`HSpacing(75),
		// heading
		`Heading(_("Error: No Suitable PPD File Downloaded")),
		text,
		`PushButton( `id(`ok), `opt(`default),
		     Label::OKButton ())
		)
	    );

	    UI::SetFocus(`id(`ok) );
	    any r = UI::UserInput();
	    UI::CloseDialog();
	    return false;
	}
	integer count = tointeger (SCR::Read (.target.string, dir + "/count"));
	// reported message
	Report::Message (sformat (_("%1 file was added to the database",
	    "%1 files were added to the database", count),
	    count));
	foomatic = nil;
	loadFoomaticIfNeeded ();
	return true;
    }


}
