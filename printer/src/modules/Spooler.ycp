/**
 * File:
 *   modules/Spooler.ycp
 *
 * Package:
 *   Printing spooler library.
 *
 * Summary:
 *   Some utility functions for spooler settings
 *
 * Authors:
 *   Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 * Printer library exported functions. What else?!?
 */

{
    module "Spooler";

    textdomain "printer";

    import "CommandLine";
    import "CUPS";
    import "Mode";
    import "Label";
    import "Package";
    import "PackageAI";
    import "PackageSystem";
    import "Printerdb";
    import "Popup";
    import "Report";
    import "Service";

// local variables

    /**
      * Currently used spooler, cups or unknown (means none installed)
      */
    string spooler = "unknown";

    /**
     * Printer's name mustn't be the same as a name of one of the files
     * in the /etc/lpdfilter directory. These are the files. If it is nil,
     * the list hasn't been initialized yet. Use function
     * getSystemForbiddenNames for accessing this list.
     */
    list<string> sys_forbidden_names = nil;

// global variables

// local functions

/**
 * display CUPS initialization popup
 */
define void showCupsInitPopup () ``{
    if (Mode::commandline ())
    {
	CommandLine::Print (_("Initializing CUPS server...
This usually takes one or two minutes"));
    }
    else
    {
        // popup
        UI::OpenDialog(`opt(`decorated ),`VBox (
                // label
            `Label(_("Initializing CUPS server...
This usually takes one or two minutes")),
            `ProgressBar (`id (`cups_prog), "", 60 * 10)));
    }
}



// global functions

    /**
      * Get the currently used spooler
      * FIXME TODO if not known, detect
      * @return currently used spooler
      */
    global define string Get() ``{
	return spooler;
    }

    /**
      * Set the spooler that is used
      * FIXME high-level functions should be used instead of this one, this
      *       should get local
      * @param spooler_type string spooler that is used
      */
    global define void Set (string spooler_type) ``{
	spooler = spooler_type;
	if (spooler == "cups")
	{
	    Printerdb::SetDriverPackages (
		["cups-drivers", "cups-drivers-stp", "filters",
                "foomatic-filters", "manufacturer-PPDs"]
	    );
	    Printerdb::SetSupportedFilters (nil);
	}
	else // unknown spooler
	{
	    Printerdb::SetDriverPackages ([]);
	    Printerdb::SetSupportedFilters (nil);
	}
	sys_forbidden_names = nil;
    }

    /**
      * get RadioButtonGroup for spooler selection
      * @param spooler string currently used spooler (cups, cups-client,
      *  or current)
      * @param none boolean show leaving current status
      * @return term RadioButtonGroup widget
      */
    global define term getSpoolerItems (string spooler, boolean none) ``{
	return `RadioButtonGroup (
	    `id (`spooler),
	    `HBox (`HSpacing (1), `VBox (
		`VSpacing (1),
		`RadioButton (`id (`cups_server),
		    `opt (`hstretch, `notify),
		    // radiobutton
		    _("CUPS full &server installation"),
		    spooler == "cups"),
		`VSpacing (0.5),
		`RadioButton (`id (`cups_client),
		    `opt (`hstretch, `notify),
		    // radiobutton
		    _("CUPS &client-only installation"),
		    spooler == "cups-client"),
		none ? `VSpacing (0.5) : `VSpacing (0),
		none ? `RadioButton (`id (`none),
		    `opt (`hstretch, `notify),
		    // radiobutton
		    _("L&eave current status"),
		    spooler == "current")
		    : `VSpacing (0),
		`VSpacing (1)
	     ), `HSpacing (1)
	));
    }

    /**
      * Shows a question to a user what spooler he wants.
      * @param msg string to be displayed
      * @param abort_msg label of abort button
      * @return symbol specifying users selecion (cups, cups_client, exit)
      */
    global define symbol chooseSpooler(string msg, string abort_msg)
    ``{
	symbol ret = `none_symbol;
	UI::OpenDialog (
            `VBox (
		`Label (msg),
		getSpoolerItems ("current", true),
		`HBox (
		    `HWeight (1, `PushButton (`id (`ok), `opt (`key_F10), Label::OKButton ())),
		    `HWeight (1, `PushButton (`id (`cancel), `opt (`key_F9), abort_msg))))
	);
	while (true)
	{
	    ret = (symbol)UI::UserInput ();
	    if (ret == `ok || ret == `cancel)
		break;
	}
	if (`ok == ret)
	{
	    ret = (symbol)UI::QueryWidget (`id (`spooler), `CurrentButton);
	}
	UI::CloseDialog();
	return ret;
    }

/**
 * Get list of names that are forbidden by the currently used spooler
 * @return a list of strings -- these strings are not allowed as queue names.
 */
global list GetSystemForbiddenNames () {
    if (nil == sys_forbidden_names)
    {
	if (Get () == "cups")
	{
	    sys_forbidden_names = CUPS::GetSystemForbiddenNames ();
	}
	else
	{
	    sys_forbidden_names = [];
	}
    }
    return sys_forbidden_names;
}

    /**
      * stop currently running printer spooler service
      */
    global define void StopServices () ``{
	if (Mode::config ())
	    return;
	SCR::Execute (.target.bash, "test -f /etc/init.d/lpd && /etc/init.d/lpd stop");
	SCR::Execute (.target.bash, "test -f /etc/init.d/cups && /etc/init.d/cups stop");
    }

    /**
     * Test which spooling system is most probably used.
     * @return integer with some bits set:<br>
     *    1 if lpd is installed<br>
     *    2 if cups is installed<br>
     *      (therefore 0 if none is installed)<br>
     *      (therefore 3 if both are installed)<br>
     *  256 is added if the instalation doesn't seem to be complete
     */
    global define integer getSpoolSystem () ``{
	// first try if some of the systems exists.
	boolean cups_exists = PackageSystem::Installed("cups-client");
	// for lpd we need to check the file because
	boolean lpd_exists = PackageSystem::Installed ("lprng");
	y2milestone ("CUPS exists: %1, LPRng exists: %2",
	    cups_exists, lpd_exists);
	boolean cups_complete = PackageSystem::InstalledAll (
	    ["cups", "cups-client"]);
	boolean lpd_complete = true;

	if (cups_exists && !lpd_exists)
	    {
		if (cups_complete)
		    return 2;
		else
		{
		    boolean cups_client =
			PackageSystem::Installed ("cups-libs")
			&& ! PackageSystem::Installed ("cups");
		    if (cups_client)
			return 512 + 2;
		    else
			return 256 + 2;
		}
	    }
	if (!cups_exists && lpd_exists)
	    {
		if (lpd_complete)
		    return 1;
		else
		    return 256 + 1;
	    }
	if (cups_exists && lpd_exists)
	    {
		return 3;
	    }
	return 0;
    }

    /**
     * Uninstalls print spoolers and installs selected one.
     * Stops all spoolers before installation.
     * @param to Spooler to install. Should be one of "cups" "cups_client"
     */
    global define void switchTo (string to) ``{
	y2milestone ("Switching spooler to %1", to);
	PackageSystem::EnsureTargetInit ();
	PackageSystem::EnsureSourceInit ();
	list<string> del = ["plp", "lprold", "lprng", "cups", "cups-client",
            "cups-drivers", "cups-drivers-cs", "cups-drivers-de",
            "cups-drivers-stp", "lpdfilter", "filters", "foomatic-filters",
	    "manufacturer-PPDs" ];
	list<string> inst = [];

	list<string> inst_cups = [ "cups", "cups-drivers", "cups-client",
	    "cups-drivers-stp", "filters", "foomatic-filters",
	    "manufacturer-PPDs"];
	list<string> inst_cups_client = [ "cups-client"];
	list<string> inst_other = [ to, "filters", "lpdfilter", "foomatic-filters",
	    "cups-drivers"];

	if ("cups" == to)
        {
            inst = inst_cups;
        }
        else if ("cups_client" == to)
        {
            inst = inst_cups_client;
	    del = filter (string d, del, ``(! contains (inst_cups, d)));
        }
        else
        {
	    // after switch from CUPS to LPRng printcap with imported queues
	    // can be left. remove it (#29440)
	    y2milestone ("Removing /etc/printcap");
	    SCR::Execute (.target.bash,
		"test -f /etc/printcap && /bin/rm /etc/printcap");
	    inst = inst_other;
        }
	del = filter (string e, del, ``(! contains (inst, e)));


	if (Mode::config ())
	{
	    Spooler::Set (to);
	    PackageAI::RemoveAll (del);
	    PackageAI::InstallAll (inst);
	    if (Spooler::Get () == "cups")
	    {
		// using the fact that if I mark package for deletion, it gets
		// deleted during the PackageSystem::InstallAll () call.
		foreach (string p, del, {Pkg::PkgDelete (p);});
		PackageSystem::InstallAll (inst);
		foreach (string p, del, {Pkg::PkgNeutral (p);});
	    }
	    return;
	}
	StopServices ();
	Service::Disable ("lpd");
	Service::Disable ("cups");
	del = filter (string e, del, ``(Pkg::IsProvided (e) == true));
	inst = filter (string i, inst, ``(! Pkg::IsProvided (i)));
	if (! (Pkg::IsProvided ("ghostscript-x11")
	    || Pkg::IsProvided ("ghostscript-serv")))
	{
	    inst = add (inst, "ghostscript-x11");
	}
	if (del != [] || inst != [])
	{
	    import "PackageCallbacksInit";
	    PackageCallbacksInit::InitPackageCallbacks ();
	    y2milestone("-------- deleting = %1", del);
	    foreach (string e, del, ``{Pkg::PkgDelete (e);});
	    y2milestone("-------- installing = %1", inst);
	    foreach (string e, inst, ``{Pkg::PkgInstall (e);});
	    Pkg::PkgSolve (false);
	    Pkg::PkgCommit (0);
	    PackageSystem::RunSUSEconfig ();
	}
	if (to == "cups" || to == "cups_client")
	{
	    // after switch from CUPS to LPRng printcap with imported queues
	    // can be left. remove it (#29440)
	    // deleting when switching to CUPS doesn't break anything
	    y2milestone ("Removing /etc/printcap");
	    SCR::Execute (.target.bash,
		"test -f /etc/printcap && /bin/rm /etc/printcap");
	}
	if ("cups" == to)
        {
	    // create symlink /etc/printcap -> /etc/cups/printcap (#29671)
	    y2milestone ("Creating /etc/printcap symlink");
	    SCR::Execute (.target.bash,
		"/bin/ln -sf /etc/cups/printcap /etc/printcap");
	}
	Set (to);
	sys_forbidden_names = nil;
    }

    /**
      * check whether spooler (if needed to be running) runns, if not start it
      * @param showPopup boolean true if shall show a popup if needed
      */
    global define void RestartIfNeeded (boolean showPopup) ``{
	if (Mode::config ())
	    return;
        if (Spooler::Get () == "cups")
        {
            if (`server == CUPS::InstallationType ())
            {
		boolean close_dialog = false;
		integer status = (integer)SCR::Execute (.target.bash, "/usr/bin/lpstat -r 2>/dev/null");
                if (status == 0)
                    return;
		if (SCR::Read (.target.size, "/etc/cups/ppds.dat") <= 0)
		{
		    close_dialog = true;
		    showCupsInitPopup ();
		}
                status = (integer)SCR::Execute (.target.bash, "/etc/init.d/cups status");
                if (0 != status)
		{
                    SCR::Execute (.target.bash_background, "/etc/init.d/cups start");
		    sleep (1000);
		}
                status = 1;
		integer attempts = 0;
                while (true)
                {
                    status = (integer)SCR::Execute (.target.bash, "/usr/bin/lpstat -r 2>/dev/null");
                    if (status == 0)
                        break;
		    attempts = attempts + 1;
		    if (attempts > 5 && ! close_dialog)
		    {
			close_dialog = true;
			showCupsInitPopup ();
		    }
		    if (attempts>60*10)
		    {
			break;
		    }
                    if (close_dialog && ! Mode::commandline ())
                        UI::ChangeWidget (`id (`cups_prog), `Value, attempts);
                    sleep (1000);
                    status = (integer)SCR::Execute (.target.bash, "/etc/init.d/cups status");
                    if (0 != status)
                    {
                        Popup::Error (
                            // error popup
                            _("CUPS daemon died during initialization"));
			break;
                    }
                }
		if (close_dialog && ! Mode::commandline ())
		{
		    UI::CloseDialog ();
		}
            }
        }
    }

    /**
      * Adjust services for runlevel, set them to state needed for writing
      * @param have_some_queue true if at least one queue was configured
      * @return boolean true on success
      */
    global define boolean AdjustServices (boolean have_some_queue) ``{
	// FIXME error checking
	StopServices();

	if (Spooler::Get () == "cups")
	{
	    if ((boolean)SCR::Read (.init.scripts.exists, "lpd"))
		Service::Disable ("lpd");
            if (`client == CUPS::InstallationType ())
	    {
		if ((boolean)SCR::Read (.init.scripts.exists, "cups"))
		    Service::Disable ("cups");
	    }
	    else
	    {
		Service::Enable ("cups");
	    }
	}
	else
	{
	    if ((boolean)SCR::Read (.init.scripts.exists, "cups"))
		Service::Disable ("cups");
	    if ((boolean)SCR::Read (.init.scripts.exists, "lpd") && have_some_queue)
		Service::Enable ("lpd");
	}
	Spooler::RestartIfNeeded (true);
	return true;
    }

    /**
     * Check what spool system is installed. Don't ask user.
     * @return string spooler
     */
    global define string checkSpoolSystemNoDialog () ``{
	integer spool_sys = Spooler::getSpoolSystem ();
	spool_sys = spool_sys & 0xFF;
	if (1 == spool_sys) //lpd is installed
	{
	    spooler = "unknown"; // LPD is not supported
	}
	else if (2 == spool_sys) //cups is installed
	{
	    spooler = "cups";
	}
	else
	{
	    spooler = "unknown";
	}
	Set (spooler);
	return spooler;
    }

    /**
     * Check what spool system is installed. Ask user if needed and install spooler if wanted.
     * @return string spooler
     */
    global define string checkSpoolSystem () ``{
	integer spool_sys = Spooler::getSpoolSystem ();
	if (2 == spool_sys) //cups is installed
	{
	    spooler = "cups";
	    return "cups";
	}
	else if (0 == spool_sys || 3 == spool_sys || 256 + 1 == spool_sys
	    || 256 + 2 == spool_sys || 1 == spool_sys)
	{
	    string message = "";
	    if (0 == spool_sys) //none installed
	    {
		// popup message
		message = _("No printing system installed.
Select the CUPS installation type
to install and configure.");
	    }
	    else if (3 == spool_sys) //both spoolers are installed
	    {
		// popup message
	message = _("Both LPRng and CUPS are installed.
YaST supports only CUPS, so LPRng will be removed.
Select the CUPS installation type
to install and configure.");
	    }
	    else if (256 + 1 == spool_sys || 1 == spool_sys)
		 // lpd is installed
	    {
		// popup message
		message = _("An LPD-compatible spooler is installed.
Select the CUPS installation type
to install and configure.");
	    }
	    else if (256 + 2 == spool_sys) // cups is installed, but seems
					   // to be not complete
	    {
		// popup message
		message =_("The CUPS spooler is installed, but the installation 
does not seem complete. Choose to reinstall
CUPS or leave the current status. 
To repair the current configuration, select the 
CUPS full server installation.
If you leave the current status, CUPS
may not run properly.");
	    }
	    symbol result = chooseSpooler (message,
		// pushbutton
		_("Abo&rt setup"));
	    if (`cups_server == result)
	    {
		Spooler::switchTo ("cups");
		spooler = "cups";
		return "cups";
	    }
	    else if (`cups_client == result)
            {
                Spooler::switchTo ("cups_client");
		spooler = "cups";
                return "cups";
            }
            else if (`cancel == result)
                return "exit";
	    else
		return "unknown";
	}
	else if (512 + 2 == spool_sys) // only client installation of cups
				       // is installed
	{
	    spooler = "cups";
	    return "cups";
	}
	//should be never reached
	y2error ("CheckSpoolSystem: Unknown spooler selected: %1", spool_sys);
	return "";
    }

/**
 * Test whether spooler supports queue type
 * @param queue string queue type (eg. parallel)
 * @param spooler string spooler name ("cups")
 * @return boolean true if supports
 */
global boolean testSupportedQueueBySpooler (string queue, string spooler) {
    list<string> supported = [];
    if (spooler == "cups")
	supported = CUPS::GetSupportedUriTypes ();

    if (supported == [])// unknown spooler
	return true;
    return contains (supported, queue);
}

/**
 * Test whether currently used spooler supports queue type
 * @param queue string queue type (eg. parallel)
 * @return boolean true if supports
 */
global define boolean testSupportedQueue (string queue) {
    return testSupportedQueueBySpooler (queue, Spooler::Get ());
}

    /**
      * Restart printer daemon
      * @param have_some_queue true if at least one queue was configured
      * @return boolean true on success
      */
    global define boolean restartServices (boolean have_some_queue) ``{
	Spooler::StopServices ();
// always adjust CUPS to be run (bugzilla 29413)
	if (have_some_queue || (Spooler::Get () == "cups"))
	{
	    if (Spooler::Get () == "cups")
		SCR::Execute (.target.bash,
		    "test -f /etc/init.d/cups && /etc/init.d/cups start");
	    else
		SCR::Execute (.target.bash,
		    "test -f /etc/init.d/lpd && /etc/init.d/lpd start");
	}
	return true;
    }

    /**
      * List all available queues (local and remote)
      * @return a list of strings all available queues
      */
    global define list<string> GetAvailableQueues () ``{
	if (Spooler::Get () == "cups")
	{
	    return CUPS::GetAvailableQueues ();
	}
    }

/**
 * Initialize current spooler
 * @return boolean true on success
 */
global boolean Initialize () {
    if (Get () == "cups")
    {
	if (`server == CUPS::InstallationType ())
	{
	    integer status = (integer)SCR::Execute (.target.bash,
		"/usr/bin/lpstat -r 2>/dev/null");
	    if (status != 0)
	    {
		Spooler::RestartIfNeeded (true);
	    }
	}
    }
}



} // EOF
