#! /bin/bash
#
# Johannes Meixner <jsmeix@suse.de>, 2007, 2008

#set -x

export PATH="/sbin:/usr/sbin:/usr/bin:/bin"
export LC_ALL="POSIX"
export LANG="POSIX"
umask 022

MY_NAME=${0##*/}

KEY="$1"
if test -z "$KEY"
then echo -en "\nUsage:\n$MY_NAME keyword [ new value ]\n" 1>&2
     echo "Without a new value, the current value is reported." 1>&2
     echo "Supported keywords and possible new values are:" 1>&2
     echo "Browsing [ On | Off ]" 1>&2
     echo "BrowseAllow [ all | none | @LOCAL | host-address | network-address/netmask ]" 1>&2
     echo "E.g.: BrowseAllow '@LOCAL 192.168.100.1 192.168.200.0/255.255.255.0'" 1>&2
     echo "Listen [ all | localhost | network-address ]" 1>&2
     echo "E.g.: Listen '192.168.100.0 192.168.200.0' (localhost is added automatically)" 1>&2
     echo "      Listen 'localhost' (to have only 'Listen 127.0.0.1:631')" 1>&2
     echo "There is a strict syntax for keywords and values:" 1>&2
     echo "Case matters." 1>&2
     echo "Multiple values for a keyword must be separated by space." 1>&2
     exit 1
fi

# Remove duplicates (ignore case) and remove duplicate, leading and trailing spaces:
VALUE="$( for V in $2 ; do echo $V ; done | sort -b -f -u | tr -s '[:space:]' ' ' | sed -e 's/ *$//' )"

CUPSDCONF="/etc/cups/cupsd.conf"
if ! test -r $CUPSDCONF -a -w $CUPSDCONF
then echo "Cannot read or write $CUPSDCONF." 1>&2
     exit 2
fi

# Function to deal with 'Browsing [On|Off]'
Browsing()
{ if test -n "$VALUE"
  then # If a value was specified, only 'On' or 'Off' (case sensitive) are allowed:
       if ! test "On" = "$VALUE" -o "Off" = "$VALUE"
       then echo "Only '$KEY [ On | Off ]' is supported." 1>&2
            exit 4
       fi
       # Try to substitute an existing Browsing line (ignore case):
       sed -i.yast2save -e "s/^.*$KEY.*/$KEY $VALUE/i" $CUPSDCONF
       # There may exist no Browsing line:
       if ! grep -q "^$KEY $VALUE$" $CUPSDCONF
       then # Append a Browsing line below the last 'Brows' line (ignore case)
            # to have the new Browsing line at the matching place
            # but if no 'Brows' line exists, append at the end of the file:
            LAST_BROWSE_LINE="$( sed -n -e '/Brows/I=' $CUPSDCONF | tail -n 1 )"
            if test -n "$LAST_BROWSE_LINE"
            then sed -i -e "${LAST_BROWSE_LINE}a$KEY $VALUE" $CUPSDCONF
            else echo -en "\n$KEY $VALUE\n\n" >>$CUPSDCONF
            fi
       fi
  fi
  # Report the resulting setting in any case:
  # The 'tr ... [:blank:]' makes sure that all active Browsing entries
  # are found if there is more than one which is a broken config.
  # Remove trailing spaces (needed for the test below).
  RESULT="$( grep -i "^$KEY " $CUPSDCONF | tr -s '[:blank:]' ' ' | cut -s -d' ' -f2 | tr -s '\n' ' ' | sed -e 's/ *$//' )"
  echo -n "$RESULT"
  # For a nicer output on a terminal where stdout and stderr is mixed up,
  # output a '\n' on stderr to get subsequent stuff (e.g. the shell prompt
  # or an error message because of a failed test below) on a new line:
  echo 1>&2
  # Test if the result is the expected one if a value was specified:
  if test -n "$VALUE" -a "$RESULT" != "$VALUE"
  then echo "Failed to set '$KEY $VALUE' in $CUPSDCONF." 1>&2
       exit 5
  fi
}

# Function to deal with 'BrowseAllow [ all | none | @LOCAL | host-address | network-address/netmask ]'
BrowseAllow()
{ if test -n "$VALUE"
  then # If a value was specified, only 'all' or 'none' or '@LOCAL' (case sensitive)
       # or one or more IP-addresses are allowed:
       for V in $VALUE
       do if ! test "all" = "$V" -o "none" = "$V" -o "@LOCAL" = "$V"
          then # Test if value matches to IP-address syntax:
               if ! echo "$V" | egrep -q '^([0-9]{1,3}\.){3}[0-9]{1,3}(/([0-9]{1,2})|/(([0-9]{1,3}\.){3}[0-9]{1,3}))?$'
               then echo "Only '$KEY [ all | none | @LOCAL | host-address | network-address/netmask ]' is supported." 1>&2
                    exit 4
               fi
          fi
       done
       # Set 'BrowseOrder allow,deny' to deny browse packets by default
       # and then allow them from certain sources via BrowseAllow entries
       # and finally deny from certain sources via BrowseDeny entries.
       # All existing BrowseOrder lines are removed (ignore case).
       sed -i.yast2save -e '/^BrowseOrder.*/Id' $CUPSDCONF
       # Append the new BrowseOrder line below the last 'Brows' line (ignore case)
       # to have the new BrowseOrder line at the matching place
       # but if no 'Brows' line exists, append at the end of the file:
       LAST_BROWSE_LINE="$( sed -n -e '/Brows/I=' $CUPSDCONF | tail -n 1 )"
       if test -n "$LAST_BROWSE_LINE" 
       then sed -i -e "${LAST_BROWSE_LINE}aBrowseOrder allow,deny" $CUPSDCONF
       else echo -en "\nBrowseOrder allow,deny\n\n" >>$CUPSDCONF
       fi
       # All existing active BrowseAllow lines are removed (ignore case).
       # Those lines can be removed because YaST supports BrowseAllow lines
       # (YaST shows the BrowseAllow entries in the "printing via network" dialog)
       # so that no BrowseAllow information is silently deleted:
       sed -i -e '/^BrowseAllow.*/Id' $CUPSDCONF
       # All existing active BrowseDeny lines are deactivated (ignore case).
       # Those lines are not removed because YaST does not support BrowseDeny lines
       # so that a remove would silently delete BrowseDeny information:
       sed -i -e 's/^\(BrowseDeny.*\)$/#\1/i' $CUPSDCONF
       # Insert BrowseAllow lines before the BrowseOrder line
       # to have the new BrowseAllow lines at the matching place
       # and in the ordering of the values (needed for the test below):
       for V in $VALUE
       do sed -i -e "/^BrowseOrder /i$KEY from $V" $CUPSDCONF
       done
  fi
  # Report the resulting setting in any case:
  # The 'tr ... [:blank:]' makes sure that all active BrowseAllow entries
  # are found if there is more than one which is allowed.
  # Remove trailing spaces (needed for the test below).
  RESULT="$( grep -i "^$KEY " $CUPSDCONF | sed -e 's/from//I' | tr -s '[:blank:]' ' ' | cut -s -d' ' -f2 | tr -s '\n' ' ' | sed -e 's/ *$//' )"
  echo -n "$RESULT"
  # For a nicer output on a terminal where stdout and stderr is mixed up,
  # output a '\n' on stderr to get subsequent stuff (e.g. the shell prompt
  # or an error message because of a failed test below) on a new line:
  echo 1>&2
  # Test if the result is the expected one if a value was specified:
  if test -n "$VALUE" -a "$RESULT" != "$VALUE"
  then echo "Failed to set '$KEY from $VALUE' in $CUPSDCONF." 1>&2
       exit 5
  fi
}

# Function to deal with 'Listen [ all | localhost | network-address ]'
Listen()
{ if test -n "$VALUE"
  then # If a value was specified, only 'all' or 'localhost' or one or more network-addresses are allowed:
       if ! test "localhost" = "$VALUE"
       then for V in $VALUE
            do if ! test "all" = "$V"
               then # Test if value matches to IP-address syntax:
                    if ! echo "$V" | egrep -q '^([0-9]{1,3}\.){3}[0-9]{1,3}$'
                    then echo "Only '$KEY [ all | network-address ]' or '$KEY localhost' is supported." 1>&2
                         exit 4
                   fi
              fi
           done
       fi
       # Determine if it listens on the domain socket:
       LISTEN_DOMAIN_SOCKET_LINE="$( grep -i '^Listen.*/cups.sock' $CUPSDCONF | head -n 1 )"
       # All existing active Port lines are deactivated (ignore case).
       # Those lines are not removed because YaST does not support Port lines
       # so that a remove would silently delete Port information:
       sed -i.yast2save -e 's/^\(Port.*\)$/#\1/i' $CUPSDCONF
       # Determine the first 'Listen' line (ignore case):
       FIRST_LISTEN_LINE="$( sed -n -e '/Listen/I=' $CUPSDCONF | head -n 1 )"
       # All existing active Listen lines are removed (ignore case).
       # Those lines can be removed because YaST supports Listen lines
       # (YaST shows the Listen entries in the "share printers" dialog)
       # so that no Listen information is silently deleted:
       sed -i -e '/^Listen.*/Id' $CUPSDCONF
       # Append the mandatory 'Listen localhost' line (see http://www.cups.org/str.php?L2834
       # "What is *not* supported is a configuration where only a domain socket is enabled")
       # below the first 'Listen' line (ignore case)
       # to have the new Listen line at the matching place
       # but if no 'Listen' line exists, append at the end of the file:
       if test -n "$FIRST_LISTEN_LINE"
       then sed -i -e "${FIRST_LISTEN_LINE}aListen localhost:631" $CUPSDCONF
       else echo -en "\nListen localhost:631\n\n" >>$CUPSDCONF
       fi
       # Append a Listen line for the domain socket (if such a line was there):
       if test -n "$LISTEN_DOMAIN_SOCKET_LINE"
       then sed -i -e "/^Listen localhost/a$LISTEN_DOMAIN_SOCKET_LINE" $CUPSDCONF
       fi
       # Insert Listen lines before the 'Listen localhost' line
       # to have the new Listen lines at the matching place
       # and in the ordering of the values (needed for the test below):
       for V in $VALUE
       do if test "all" = "$V"
          then V="*"
          fi
          if ! test "localhost" = "$V"
          then sed -i -e "/^Listen localhost/i$KEY $V:631" $CUPSDCONF
          fi
       done
  fi
  # Report the resulting setting in any case:
  # The 'tr ... [:blank:]' makes sure that all active Listen entries
  # are found if there is more than one which is allowed.
  # Remove trailing spaces (needed for the test below).
  RESULT="$( grep -i "^$KEY " $CUPSDCONF | sed -e 's/:631//' -e 's/\*/all/' | tr -s '[:blank:]' ' ' | cut -s -d' ' -f2 | tr -s '\n' ' ' | sed -e 's/ *$//' )"
  echo -n "$RESULT"
  # For a nicer output on a terminal where stdout and stderr is mixed up,
  # output a '\n' on stderr to get subsequent stuff (e.g. the shell prompt
  # or an error message because of a failed test below) on a new line:
  echo 1>&2
  # Test if the result is the expected one if a value was specified:
  if test -n "$VALUE"
  then if test "localhost" = "$VALUE"
       then SPECIFIC_RESULT="$( echo "$RESULT" | sed -e 's/[^ ]*\/cups\.sock//' -e 's/ *$//' )"
       else SPECIFIC_RESULT="$( echo "$RESULT" | sed -e 's/localhost.*//' -e 's/ *$//' )"
       fi
       if test "$SPECIFIC_RESULT" != "$VALUE"
       then echo "Failed to set '$KEY $VALUE' in $CUPSDCONF." 1>&2
            exit 5
       fi
  fi
}

case "$KEY" in
     Browsing) Browsing;;
     BrowseAllow) BrowseAllow;;
     Listen) Listen;;
     *) echo "Ignoring keyword '$KEY'" 1>&2
        exit 3 ;;
esac

exit 0

